{
    "docs": [
        {
            "location": "/",
            "text": "Atomist Overview\n\u00b6\n\n\nAtomist enables you to ship software in less time and respond to\noperational events more quickly.  By automating tasks, integrating\ntools, and providing timely, correlated, and actionable information,\nAtomist makes software delivery faster, more standardized, and more\nfun.\n\n\nTimely, correlated, and actionable information results from capturing\nyour processes and operations in code.  Atomist knows the platforms\nand tools you already use: GitHub, Slack, Travis CI.  Atomist\nunderstands your code: Java, C#, JavaScript, Scala, Python, Clojure,\neven Dockerfiles and Maven POMs.  Most importantly, Atomist\nunderstands the relationship between your code, your tools, your\nenvironments, and your running services and brings this information to\nwhere you live: chat.\n\n\nIf you spend time upgrading dependencies across multiple repositories,\nintegrating code repositories and CI, configuring and managing\ndeployment platforms, figuring out who to ask about an error in a log,\nor switching from IDE to chat to web browser ad infinitum, let Atomist\nremove the drudgery and reduce the context switching so your team can\nfocus on what matters: shipping great software.\n\n\nAtomist is SaaS\n\u00b6\n\n\nThe Atomist service consumes events from your systems: source code\nrepositories, continuous integration servers, deployment platforms,\nand chat.  The information from these systems is correlated together:\npushes with builds, artifacts with deployments, stack traces with\ncommits.  The correlation of these events is then used to\nautomatically respond: retry a build, start an integration test,\nmessage a committer.\n\n\nThe Atomist service provides:\n\n\n\n\nthe SaaS platform to ingest and correlate events\n\n\na core set of integrations and event responses\n\n\nthe ability for teams to customize the events, correlation, and\n    actions for their existing processes\n\n\n\n\nAtomist is events\n\u00b6\n\n\nWithin Atomist, all events are captured and actionable.  As events are\nconsumed from your systems, event handlers are triggered.  These\nhandlers respond to events, by taking action themselves and/or\ncreating new events, which can in turn trigger other handlers.  Event\nhandlers can do anything from trigger a deployment of a new version of\nyour service to page the developer whose commit led to a runtime error\nin production to modify code directly to fix errors.\n\n\nAtomist events enable you to:\n\n\n\n\ncodify your workflow\n\n\ncapture best practices in code\n\n\nreduce incident time-to-resolution\n\n\n\n\nAtomist is code\n\u00b6\n\n\nWe\u2019ve all heard that \nsoftware is eating the world\n.  Atomist\neats software.  Atomist consumes your code, understanding your files,\nclasses, variables, exceptions and more.  This understanding is used\nto modify code directly and to connect code changes to runtime\nchanges.\n\n\nAtomist is code that:\n\n\n\n\nunderstands \nyour\n code\n\n\nunderstands your processes\n\n\nunderstands your operations\n\n\ncan \nmodify\n your code\n\n\n\n\nAtomist ties everything together\n\u00b6\n\n\nAtomist is the next phase in the evolution of software.\nInfrastructure-as-code captures infrastructure architecture and\nconfiguration in software.  DevOps automates IT operations with\nsoftware.  Atomist goes further, capturing how we develop and operate\nsoftware \nin software\n.  Atomist lets you say goodbye to the boring,\nrepetitive tasks surrounding software development by giving you the\ntools to automate them away, once and for all.\n\n\n\n\nIn a world where everything is code,\n\nAtomist\n ties everything together.  By bringing software\ndevelopment processes, IT operations, and infrastructure-as-code\ntogether with a deep understanding of the code itself, \nAtomist\n\nis able to surface the right information to the right person at\nthe right time in the right place to speed software delivery and\nstabilize IT operations.\n\n\n\n\nTo help you learn more about Atomist, this documentation contains\n\n\n\n\nThe rest of this overview: Atomist \nconcepts\n\n    and \ncapabilities\n\n\nGetting Started\n instructions\n\n\nLearn how to customize Atomist by working through\n    our \nTutorials\n\n\nThe Atomist \nUser Guide\n explaining each part of\n    Atomist and how it is used\n\n\nDetailed \nReference Documentation\n\n\n\n\nIf you are new to Atomist, we recommend working through\nthe \nGetting Started\n instructions to get Atomist set\nup.  Once you are set up, you can get more information on using\nAtomist in the \nUser Guide\n.  If you are developing new\nAtomist functionality and need to answer a technical question,\nthe \nReference Documentation\n is probably the best place to\nlook.\n\n\nTo stay up to date with Atomist, get announcements on new features,\nand interact with the Atomist team, please\n\n\n\n\nJoin the \nAtomist Community Slack\n\n\nFollow our blog, \nThe Composition\n\n\nFollow \n@atomist\n on Twitter\n\n\n\n\nWe sincerely hope you enjoy using Atomist!",
            "title": "Introduction"
        },
        {
            "location": "/#atomist-overview",
            "text": "Atomist enables you to ship software in less time and respond to\noperational events more quickly.  By automating tasks, integrating\ntools, and providing timely, correlated, and actionable information,\nAtomist makes software delivery faster, more standardized, and more\nfun.  Timely, correlated, and actionable information results from capturing\nyour processes and operations in code.  Atomist knows the platforms\nand tools you already use: GitHub, Slack, Travis CI.  Atomist\nunderstands your code: Java, C#, JavaScript, Scala, Python, Clojure,\neven Dockerfiles and Maven POMs.  Most importantly, Atomist\nunderstands the relationship between your code, your tools, your\nenvironments, and your running services and brings this information to\nwhere you live: chat.  If you spend time upgrading dependencies across multiple repositories,\nintegrating code repositories and CI, configuring and managing\ndeployment platforms, figuring out who to ask about an error in a log,\nor switching from IDE to chat to web browser ad infinitum, let Atomist\nremove the drudgery and reduce the context switching so your team can\nfocus on what matters: shipping great software.",
            "title": "Atomist Overview"
        },
        {
            "location": "/#atomist-is-saas",
            "text": "The Atomist service consumes events from your systems: source code\nrepositories, continuous integration servers, deployment platforms,\nand chat.  The information from these systems is correlated together:\npushes with builds, artifacts with deployments, stack traces with\ncommits.  The correlation of these events is then used to\nautomatically respond: retry a build, start an integration test,\nmessage a committer.  The Atomist service provides:   the SaaS platform to ingest and correlate events  a core set of integrations and event responses  the ability for teams to customize the events, correlation, and\n    actions for their existing processes",
            "title": "Atomist is SaaS"
        },
        {
            "location": "/#atomist-is-events",
            "text": "Within Atomist, all events are captured and actionable.  As events are\nconsumed from your systems, event handlers are triggered.  These\nhandlers respond to events, by taking action themselves and/or\ncreating new events, which can in turn trigger other handlers.  Event\nhandlers can do anything from trigger a deployment of a new version of\nyour service to page the developer whose commit led to a runtime error\nin production to modify code directly to fix errors.  Atomist events enable you to:   codify your workflow  capture best practices in code  reduce incident time-to-resolution",
            "title": "Atomist is events"
        },
        {
            "location": "/#atomist-is-code",
            "text": "We\u2019ve all heard that  software is eating the world .  Atomist\neats software.  Atomist consumes your code, understanding your files,\nclasses, variables, exceptions and more.  This understanding is used\nto modify code directly and to connect code changes to runtime\nchanges.  Atomist is code that:   understands  your  code  understands your processes  understands your operations  can  modify  your code",
            "title": "Atomist is code"
        },
        {
            "location": "/#atomist-ties-everything-together",
            "text": "Atomist is the next phase in the evolution of software.\nInfrastructure-as-code captures infrastructure architecture and\nconfiguration in software.  DevOps automates IT operations with\nsoftware.  Atomist goes further, capturing how we develop and operate\nsoftware  in software .  Atomist lets you say goodbye to the boring,\nrepetitive tasks surrounding software development by giving you the\ntools to automate them away, once and for all.   In a world where everything is code, Atomist  ties everything together.  By bringing software\ndevelopment processes, IT operations, and infrastructure-as-code\ntogether with a deep understanding of the code itself,  Atomist \nis able to surface the right information to the right person at\nthe right time in the right place to speed software delivery and\nstabilize IT operations.   To help you learn more about Atomist, this documentation contains   The rest of this overview: Atomist  concepts \n    and  capabilities  Getting Started  instructions  Learn how to customize Atomist by working through\n    our  Tutorials  The Atomist  User Guide  explaining each part of\n    Atomist and how it is used  Detailed  Reference Documentation   If you are new to Atomist, we recommend working through\nthe  Getting Started  instructions to get Atomist set\nup.  Once you are set up, you can get more information on using\nAtomist in the  User Guide .  If you are developing new\nAtomist functionality and need to answer a technical question,\nthe  Reference Documentation  is probably the best place to\nlook.  To stay up to date with Atomist, get announcements on new features,\nand interact with the Atomist team, please   Join the  Atomist Community Slack  Follow our blog,  The Composition  Follow  @atomist  on Twitter   We sincerely hope you enjoy using Atomist!",
            "title": "Atomist ties everything together"
        },
        {
            "location": "/concepts/",
            "text": "Atomist is a new approach to software development that pushes the\nlimits of automation and blurs the boundaries between projects, code,\ntooling, and operations.  It extends some well-known concepts and\nintroduces some new ideas.  In this section, we present overarching\nconcepts integral to Atomist and how it helps you ship better software\nfaster.\n\n\n\n\n\n\n\nAt its core, Atomist is a partner that improves your development process\nthrough automation.  The automation we are talking about goes well\nbeyond what traditionally comes to mind when talking about IT\nautomation.  Atomist is not a configuration management system.\nAtomist is not a templating system.  Atomist is not\ninfrastructure-as-code.  Atomist is not a DevOps platform.  Atomist is\nnot a ChatOps platform.  Atomist brings all of those things\ntogether\u2026 and more.  Bringing the events and information from\nthe systems and tools you already use together in one place, providing\ninsight into what is happening in your day-to-day development flow, is\njust the beginning.  Once the information is collected, it can be\ncorrelated and contextualized, providing a coherent view of your\ndevelopment landscape.  Even more importantly, Atomist provides the\nability to take action on information and events, both automatically\nand by prompting the appropriate users.  In short, Atomist provides\nyou with the information, context, and tooling to help you make better\ndecision more quickly.\n\n\nSoftware as a Service\n\u00b6\n\n\nAtomist is offered as a service, ingesting events from various sources\nand correlating them for our users.  Atomist manages infrastructure to\nsupport the ingestion and storage of events from external sources.\nAtomist provides and runs the software to process these events,\nperform the appropriate operations, and respond, e.g., via the Atomist\nBot.\n\n\nEvents\n\u00b6\n\n\nAtomist takes \nevent-driven programming\n and applies it to\nprogramming itself.  Everything from commits to pushes to CI builds to\ndeployments to stack traces in production logs\u2014these are\ncaptured as events.  Atomist responds to events in two ways: it learns\nabout relationships and takes automated action.  For instance, a\ncommit event \nteaches\n Atomist who changed code on a branch; a failed\nbuild event for that branch results in the \naction\n of messaging that\ncommitter.  Recognizing each crucial event lets Atomist\n\n\n\n\nOrchestrate a delivery flow across multiple projects and systems\n\n\nImplement workflow that CI can\u2019t model\n\n\nReplace manual pieces of your development process\n\n\nSend in-context, actionable notifications to the right people\n\n\n\n\n\n\n\n\n\n\nMore than just ingesting and understanding events, Atomist remembers\nkey contextual information about the events it sees, and bases future\nresponses on it.  Atomist understands the relationships between\nevents: how a user changes a line of code, that is part of a commit,\nthat is part of a push, that triggers a CI build, that creates a\nDocker image, that gets deployed to a staging environment, that\ncreates a Kubernetes pod, that generates a error-level log message.\nThis allows you to create event responses that, for example, message\nthe author of the code change that led to an error in your staging\nenvironment but only if that commit was made within the last 24 hours\nand it is normal working hours for the author.\n\n\nRug\n\u00b6\n\n\n\n\n\nRug is a programming model and runtime.\n\n\nThe Rug programming model defines the interface, which is \u201cWhat events\ndoes this program respond to?\u201d and \u201cHow does it respond?\u201d.  Programs\nthat implement this model are called Rugs, and they execute inside a\nRug runtime.\n\n\nRugs can automate and codify all manner of steps in a development or\noperations workflow.  For example, Rugs can\n\n\n\n\nAlert the author whose change caused an error at runtime\n\n\nAutomate deployment by linking your CI system, your integration\n    tests, and your runtime platform\n\n\nIdentify a commit leading to a regression in production, revert\n    the commit, and release the \u201cnew\u201d version!\n\n\n\n\nThese are just a few ways Rugs are able to tie all the events of a\nteam together into a coherent model.\n\n\nAtomist ships with a core set of Rugs.  Anyone using Atomist can\nimplement additional Rugs for their team.  These custom Rugs are\ndynamically discovered by Atomist and used when processing all\nsubsequent events.\n\n\nIntegrations\n\u00b6\n\n\nAtomist integrates with chat, with version control, with CI systems,\nand more.  Atomist integrations with a system can receive events from\nand perform operations on that system.\n\n\nAtomist uses the native integration technology for each platform or\ntool.  For example, to integrate with GitHub.com and Travis CI we use\nwebhooks; to integrate with Slack we use their native real-time\nmessaging (RTM) API.  For each platform we integrate with, we ask for\nthe minimal set of permissions required for the operations Atomist\nsupplies.\n\n\nDo you use a system or tool Atomist does not natively support?  We\nalso provide our users with the ability to implement their own\nintegrations, empowering them to unleash Atomist\u2019s integrative power\nacross all their systems and processes.  Users can use native\ncapabilities provided by Atomist to call a third-party service\u2019s REST\nAPI and have the response ingested as an event in Atomist.\n\n\nInterfaces\n\u00b6\n\n\nAtomist interfaces with people.  It brings information to you, and\nreceives orders from you, where you are.\n\n\nBot\n - Atomist strongly believes in the power of ChatOps.\nSpecifically, we believe chat \ncan\n be a driving force for shipping\nbetter software faster.  For ChatOps to achieve these goals, it must\nbe backed by an intelligent system that integrates all relevant\ninformation and delivers it to the appropriate users in actionable\nways.  The Atomist Bot provides this exact interface for everyone\nworking in and around software development and delivery.\n\n\nCLI\n - Many developers prefer working on the command line,\nprototyping and hacking together clever solutions to vexing problems.\nAtomist provides a powerful Rug CLI that not only supports running\nRugs, but also a provides immediate feedback when developing and\ntesting Rugs.\n\n\nNone\n - The real power of Atomist is achieved when no interface is\nnecessary.  Put another way, Atomist is about driving to \ncomplete\n\nautomation.  When every aspect of your workflow has been fully\nautomated, both its \u201chappy path\u201d and remediations for\nerror modes, you can focus on what matters: writing great code.",
            "title": "Concepts"
        },
        {
            "location": "/concepts/#software-as-a-service",
            "text": "Atomist is offered as a service, ingesting events from various sources\nand correlating them for our users.  Atomist manages infrastructure to\nsupport the ingestion and storage of events from external sources.\nAtomist provides and runs the software to process these events,\nperform the appropriate operations, and respond, e.g., via the Atomist\nBot.",
            "title": "Software as a Service"
        },
        {
            "location": "/concepts/#events",
            "text": "Atomist takes  event-driven programming  and applies it to\nprogramming itself.  Everything from commits to pushes to CI builds to\ndeployments to stack traces in production logs\u2014these are\ncaptured as events.  Atomist responds to events in two ways: it learns\nabout relationships and takes automated action.  For instance, a\ncommit event  teaches  Atomist who changed code on a branch; a failed\nbuild event for that branch results in the  action  of messaging that\ncommitter.  Recognizing each crucial event lets Atomist   Orchestrate a delivery flow across multiple projects and systems  Implement workflow that CI can\u2019t model  Replace manual pieces of your development process  Send in-context, actionable notifications to the right people     More than just ingesting and understanding events, Atomist remembers\nkey contextual information about the events it sees, and bases future\nresponses on it.  Atomist understands the relationships between\nevents: how a user changes a line of code, that is part of a commit,\nthat is part of a push, that triggers a CI build, that creates a\nDocker image, that gets deployed to a staging environment, that\ncreates a Kubernetes pod, that generates a error-level log message.\nThis allows you to create event responses that, for example, message\nthe author of the code change that led to an error in your staging\nenvironment but only if that commit was made within the last 24 hours\nand it is normal working hours for the author.",
            "title": "Events"
        },
        {
            "location": "/concepts/#rug",
            "text": "Rug is a programming model and runtime.  The Rug programming model defines the interface, which is \u201cWhat events\ndoes this program respond to?\u201d and \u201cHow does it respond?\u201d.  Programs\nthat implement this model are called Rugs, and they execute inside a\nRug runtime.  Rugs can automate and codify all manner of steps in a development or\noperations workflow.  For example, Rugs can   Alert the author whose change caused an error at runtime  Automate deployment by linking your CI system, your integration\n    tests, and your runtime platform  Identify a commit leading to a regression in production, revert\n    the commit, and release the \u201cnew\u201d version!   These are just a few ways Rugs are able to tie all the events of a\nteam together into a coherent model.  Atomist ships with a core set of Rugs.  Anyone using Atomist can\nimplement additional Rugs for their team.  These custom Rugs are\ndynamically discovered by Atomist and used when processing all\nsubsequent events.",
            "title": "Rug"
        },
        {
            "location": "/concepts/#integrations",
            "text": "Atomist integrates with chat, with version control, with CI systems,\nand more.  Atomist integrations with a system can receive events from\nand perform operations on that system.  Atomist uses the native integration technology for each platform or\ntool.  For example, to integrate with GitHub.com and Travis CI we use\nwebhooks; to integrate with Slack we use their native real-time\nmessaging (RTM) API.  For each platform we integrate with, we ask for\nthe minimal set of permissions required for the operations Atomist\nsupplies.  Do you use a system or tool Atomist does not natively support?  We\nalso provide our users with the ability to implement their own\nintegrations, empowering them to unleash Atomist\u2019s integrative power\nacross all their systems and processes.  Users can use native\ncapabilities provided by Atomist to call a third-party service\u2019s REST\nAPI and have the response ingested as an event in Atomist.",
            "title": "Integrations"
        },
        {
            "location": "/concepts/#interfaces",
            "text": "Atomist interfaces with people.  It brings information to you, and\nreceives orders from you, where you are.  Bot  - Atomist strongly believes in the power of ChatOps.\nSpecifically, we believe chat  can  be a driving force for shipping\nbetter software faster.  For ChatOps to achieve these goals, it must\nbe backed by an intelligent system that integrates all relevant\ninformation and delivers it to the appropriate users in actionable\nways.  The Atomist Bot provides this exact interface for everyone\nworking in and around software development and delivery.  CLI  - Many developers prefer working on the command line,\nprototyping and hacking together clever solutions to vexing problems.\nAtomist provides a powerful Rug CLI that not only supports running\nRugs, but also a provides immediate feedback when developing and\ntesting Rugs.  None  - The real power of Atomist is achieved when no interface is\nnecessary.  Put another way, Atomist is about driving to  complete \nautomation.  When every aspect of your workflow has been fully\nautomated, both its \u201chappy path\u201d and remediations for\nerror modes, you can focus on what matters: writing great code.",
            "title": "Interfaces"
        },
        {
            "location": "/capabilities/",
            "text": "Atomist is all about helping you ship high-quality software in less\ntime.  Whether you are working with large legacy codebases, your own\n\u201cmajestic monoliths\u201d, or aiming for \u201czero-overhead microservices\u201d,\nAtomist provides you with the tools to speed development, smooth\noperations, and close the code/runtime feedback loop.\n\n\nBringing everything together\n\u00b6\n\n\nAtomist consumes events from the platforms and tools you use every day.\nBy linking related events from source code repositories, continuous\nintegration, testing, and runtime environments, Atomist can present\nthem in a unified manner to appropriate team members via direct or\ngroup messages.  The result is massive reductions in context-switching\ncosts and and shorter incident time-to-resolution.\n\n\n\n\n\n\n\nRug ties everything together\n\n\n\n\nRug is the programming model and runtime that ties everything\ntogether.  Rug not only understands individual events, but can learn\nrelationships between events and respond to events with appropriate,\nautomated actions.\n\n\nDevelopment lifecycle automation\n\u00b6\n\n\nAtomist helps you develop better software more quickly by greatly\nenhancing your ability to automate your software development\nlifecycle.  By intelligently linking your source code repository, your\nCI system, your deployment platform, your logs, and your alerting\nsystem, Atomist connects code changes to runtime changes and provides\nthat information back, with its full context, back to the appropriate\nteam member.  It can can even automate remediation, obviating the need\nto alert anyone.\n\n\nThe Rug programming model was created to help you streamline and\nbetter manage your software delivery lifecycle.  By writing Rugs,\ni.e., programs that implement the Rug programming model, you are able\nto automate code modifications and API calls up through complex\nworkflows and decision points.  There are several different types of\nRugs, each providing a different way to help you improve your\ndevelopment and operations lifecycle.\n\n\n\n\nEvent-driven actions: \nEvent Handlers\n\n\nRug \nevent handlers\n respond to\nevents.  Event handlers can use the information on an event and\nits related events to message the right team members, take direct\naction, and/or create new events, which can trigger other event\nhandlers.  Need to notify someone when their commit causes a stack\ntrace in production?  Automate that with an event handler.\n\n\nChatDev and ChatOps: \nCommand Handlers\n\n\nRug \ncommand handlers\n respond to\nmessages in chat, allowing you quickly create bot commands to\nautomate common tasks in software development and operation.  Want\nto automate the release of a new version of your service to\nproduction?  Write a command handler so you can initiate the\nrelease right from chat.\n\n\nProject updates: \nEditors\n\n\nRug \neditors\n modify code directly and\nconsistently.  They can modify any code, in any project,\nregardless of whether the project was created by Atomist or not.\nNeed to add or update a dependency and add some boilerplate code\nfor it?  Codify it in an editor.\n\n\nProject creation: \nGenerators\n\n\nRug \ngenerators\n create new projects\nfrom a model project.  More powerful than templating approaches,\ngenerators are real projects operating under native tooling.  Need\nto stamp out a bunch of new microservice projects?  Stop the\ncopy/paste/find/replace cycle and use a generator.\n\n\n\n\n\n\n\n\n\n\nIndividual Rugs can be composed.  For example, editors can be used by\nRug handlers, commands, and generators to modify code in a consistent\nmanner across many repositories.  Handlers can execute commands.\nEvents can fire reviewers, e.g., every PR can trigger a reviewer that\nensures it complies with your coding and submission standards.\n\n\nEvents and code selection\n\u00b6\n\n\nHow does a handler know what event it should act on?  How does an\neditor know what part of what file to edit?  Atomist provides a\npowerful mechanism for pinpoint selection of events and\ncode: \npath expressions\n.  Inspired by \nXPath\n, path\nexpressions provide a concise abstraction for navigating the various\nelements in your code and development environment.  Path expressions\nselect related events satisfying specific criteria, e.g., a Slack user\nwhose GitHub user authored a commit that was in a push that triggered\na CI build that failed, and specific blocks of code in specific files,\ne.g., all Scala methods that return \nBoolean\n.\n\n\nDeveloping Rugs\n\u00b6\n\n\nAtomist is extensible.  Atomist ships with many useful capabilities,\nbut the ways in which Atomist can improve your development and\noperations do not stop there.  The primary supported development\nlanguage for writing Rugs is \nTypeScript\n, although any language\nthat compiles to JavaScript can be used.  You can modify existing Rugs\nor create your own Rugs to match your processes and workflows.\n\n\nAtomist meets you where you are.  It doesn\u2019t make you change how your\nteam develops and ships code.  It improves your code and speeds the\nshipping of great software.",
            "title": "Capabilities"
        },
        {
            "location": "/capabilities/#bringing-everything-together",
            "text": "Atomist consumes events from the platforms and tools you use every day.\nBy linking related events from source code repositories, continuous\nintegration, testing, and runtime environments, Atomist can present\nthem in a unified manner to appropriate team members via direct or\ngroup messages.  The result is massive reductions in context-switching\ncosts and and shorter incident time-to-resolution.    Rug ties everything together   Rug is the programming model and runtime that ties everything\ntogether.  Rug not only understands individual events, but can learn\nrelationships between events and respond to events with appropriate,\nautomated actions.",
            "title": "Bringing everything together"
        },
        {
            "location": "/capabilities/#development-lifecycle-automation",
            "text": "Atomist helps you develop better software more quickly by greatly\nenhancing your ability to automate your software development\nlifecycle.  By intelligently linking your source code repository, your\nCI system, your deployment platform, your logs, and your alerting\nsystem, Atomist connects code changes to runtime changes and provides\nthat information back, with its full context, back to the appropriate\nteam member.  It can can even automate remediation, obviating the need\nto alert anyone.  The Rug programming model was created to help you streamline and\nbetter manage your software delivery lifecycle.  By writing Rugs,\ni.e., programs that implement the Rug programming model, you are able\nto automate code modifications and API calls up through complex\nworkflows and decision points.  There are several different types of\nRugs, each providing a different way to help you improve your\ndevelopment and operations lifecycle.   Event-driven actions:  Event Handlers  Rug  event handlers  respond to\nevents.  Event handlers can use the information on an event and\nits related events to message the right team members, take direct\naction, and/or create new events, which can trigger other event\nhandlers.  Need to notify someone when their commit causes a stack\ntrace in production?  Automate that with an event handler.  ChatDev and ChatOps:  Command Handlers  Rug  command handlers  respond to\nmessages in chat, allowing you quickly create bot commands to\nautomate common tasks in software development and operation.  Want\nto automate the release of a new version of your service to\nproduction?  Write a command handler so you can initiate the\nrelease right from chat.  Project updates:  Editors  Rug  editors  modify code directly and\nconsistently.  They can modify any code, in any project,\nregardless of whether the project was created by Atomist or not.\nNeed to add or update a dependency and add some boilerplate code\nfor it?  Codify it in an editor.  Project creation:  Generators  Rug  generators  create new projects\nfrom a model project.  More powerful than templating approaches,\ngenerators are real projects operating under native tooling.  Need\nto stamp out a bunch of new microservice projects?  Stop the\ncopy/paste/find/replace cycle and use a generator.     Individual Rugs can be composed.  For example, editors can be used by\nRug handlers, commands, and generators to modify code in a consistent\nmanner across many repositories.  Handlers can execute commands.\nEvents can fire reviewers, e.g., every PR can trigger a reviewer that\nensures it complies with your coding and submission standards.",
            "title": "Development lifecycle automation"
        },
        {
            "location": "/capabilities/#events-and-code-selection",
            "text": "How does a handler know what event it should act on?  How does an\neditor know what part of what file to edit?  Atomist provides a\npowerful mechanism for pinpoint selection of events and\ncode:  path expressions .  Inspired by  XPath , path\nexpressions provide a concise abstraction for navigating the various\nelements in your code and development environment.  Path expressions\nselect related events satisfying specific criteria, e.g., a Slack user\nwhose GitHub user authored a commit that was in a push that triggered\na CI build that failed, and specific blocks of code in specific files,\ne.g., all Scala methods that return  Boolean .",
            "title": "Events and code selection"
        },
        {
            "location": "/capabilities/#developing-rugs",
            "text": "Atomist is extensible.  Atomist ships with many useful capabilities,\nbut the ways in which Atomist can improve your development and\noperations do not stop there.  The primary supported development\nlanguage for writing Rugs is  TypeScript , although any language\nthat compiles to JavaScript can be used.  You can modify existing Rugs\nor create your own Rugs to match your processes and workflows.  Atomist meets you where you are.  It doesn\u2019t make you change how your\nteam develops and ships code.  It improves your code and speeds the\nshipping of great software.",
            "title": "Developing Rugs"
        },
        {
            "location": "/getting-started/",
            "text": "Welcome!  If you want to get started with Atomist you\u2019re in the right\nplace.  Before you can start automating development tasks with\nAtomist, Atomist needs to be able to communicate with your various\ndevelopment platforms like chat, source code repositories, and your\ncontinuous integration (CI) platform.  This guide will walk you\nthrough connecting Atomist to your development systems and how to\nstart using the Atomist Bot.  If you, or someone else on your team,\nhas already connected Atomist to your development environment, you can\njump to the \nUsing the Atomist Bot\n section.\n\n\n\n\nPrerequisites\n\n\nConnect Atomist to Slack\n\n\nConnect Atomist to GitHub\n\n\nConnect Atomist to CI\n\n\nUsing the Atomist Bot",
            "title": "Overview"
        },
        {
            "location": "/getting-started/prerequisites/",
            "text": "To use Atomist, you\u2019ll need three things:\n\n\n\n\nAn invitation to the \nAtomist Alpha\n\n\nA \nSlack\n team\n\n\nA \nGitHub.com\n user\n\n\n\n\n\n\nIf you already have an Atomist Alpha invitation, Slack team,\nand GitHub.com account, you can proceed to the next step by clicking\nNext at the bottom-right of this page.\n\n\n\n\nAtomist Alpha\n\u00b6\n\n\nIf you have not yet requested access to the Atomist Alpha, please fill\nout the \nrequest form\n.  Using the information provided in the\nform, we will reach out to you with further instructions for\ncompleting your enrollment.  If you have filled out the form and have\nyet to receive the email with further instructions, please reach out\nto us in the \nAtomist Community Slack\n \n#support\n channel.\n\n\nSlack\n\u00b6\n\n\nChat is one of the main interfaces for Atomist.  Currently we support\nthe \nSlack\n chat platform.  You can use any Slack team you are\ncurrently a member of with Atomist.  If you do not currently use Slack\nor prefer to use a new Slack team with Atomist, you can \ncreate a new Slack team\n for free.\n\n\nGitHub\n\u00b6\n\n\nAtomist wants to get to know your code.  Currently Atomist integrates\nwith \nGithub.com\n.  If you already have a GitHub.com account,\nyou can use Atomist with that.  If you do not have a GitHub.com\naccount, you can \ncreate an\naccount\n for free.",
            "title": "Prerequisites"
        },
        {
            "location": "/getting-started/prerequisites/#atomist-alpha",
            "text": "If you have not yet requested access to the Atomist Alpha, please fill\nout the  request form .  Using the information provided in the\nform, we will reach out to you with further instructions for\ncompleting your enrollment.  If you have filled out the form and have\nyet to receive the email with further instructions, please reach out\nto us in the  Atomist Community Slack   #support  channel.",
            "title": "Atomist Alpha"
        },
        {
            "location": "/getting-started/prerequisites/#slack",
            "text": "Chat is one of the main interfaces for Atomist.  Currently we support\nthe  Slack  chat platform.  You can use any Slack team you are\ncurrently a member of with Atomist.  If you do not currently use Slack\nor prefer to use a new Slack team with Atomist, you can  create a new Slack team  for free.",
            "title": "Slack"
        },
        {
            "location": "/getting-started/prerequisites/#github",
            "text": "Atomist wants to get to know your code.  Currently Atomist integrates\nwith  Github.com .  If you already have a GitHub.com account,\nyou can use Atomist with that.  If you do not have a GitHub.com\naccount, you can  create an\naccount  for free.",
            "title": "GitHub"
        },
        {
            "location": "/getting-started/slack/",
            "text": "Atomist integrates with \nSlack\n via the Atomist Bot, which\nprovides a chat-based interface to Atomist\u2019s capabilities.\n\n\nAfter you filled out the \nAtomist Alpha\n form, you should have\nreceived an email invitation that looks something like the following:\n\n\n\n  \n\n\n\n\n\nTo invite the Atomist Bot into your Slack team, simply click the\n\u201cInstall Atomist Bot in Slack\u201d button in the Atomist Alpha\ninvitation email.\n\n\nClicking the button will send you to a web page where you will be\nasked to sign into your Slack team if you are not already signed in.\nProvide your Slack team domain and click Continue.\n\n\n\n  \n\n\n\n\n\nOn the next page, provide your email address and password to complete\nthe Slack sign-in.  If you have trouble signing in, check\nout \nSlack help\n.\n\n\n\n  \n\n\n\n\n\nAfter successfully signing in, you will see the authorization page for\nthe Atomist app, including the Slack permissions requested.  Confirm\nthat the correct Slack team is selected and click \u201cAuthorize\u201d.\n\n\n\n  \n\n\n\n\n\nFor information on the permissions requested, see \nSlack Permissions\n.\n\n\n\n\n\nOnce you have successfully authorized the Atomist Bot in your Slack\nteam, you will be redirected to a confirmation page.  You can close\nthis page and go back to Slack to continue this guide.\n\n\n\n  \n\n\n\n\n\nBy default, the Atomist Bot will be named \n@atomist\n and will join the\n\n#general\n channel in your Slack team.  You can invite the Atomist Bot\ninto any other channel in the same way you would invite any other\nuser: an \n@\n mention and invite, the \n/invite @atomist\n command, or\nvia the channel settings > \u201cInvite team members to join \u2026\u201d.\n\n\n\n  \n\n\n\n\n\nThis video provides a brief introduction to the Atomist Bot\u2019s\ncapabilities and how to interact with it.\n\n\n\n  \n\n\n\n\n\nFor a complete list of the things the Atomist Bot can do, send the bot\na \nhelp\n message.\n\n\n\n  \n\n\n\n\n\nClick the \u201cNext\u201d link in the bottom-right of this page to continue the\nGetting Started guide.",
            "title": "Connect Atomist to Slack"
        },
        {
            "location": "/getting-started/github/",
            "text": "To help streamline your development flow, Atomist needs access to your\nsource code. Currently Atomist supports integrating\nwith \nGitHub.com\n.\n\n\n\n\nAtomist works with GitHub.com. GitHub Enterprise is not currently supported.\n\n\n\n\nThere are two kinds of authorization Atomist asks for to work with\nGitHub:\n\n\n\n\n\n\nGitHub Account Authorization:\n this authorization determines\n    the GitHub individual account or GitHub organization that Atomist\n    will connect to your Slack team.  For example, if you want to\n    receive notifications and take actions in your team\u2019s primary\n    GitHub organization, you should select that organization when\n    authorizing Atomist to GitHub.  If you want to use Atomist with\n    your individual account, then you should select your user when\n    authorizing Atomist to GitHub.\n\n\n\n\nDepending on the third-party application access policy in your\nGitHub organization, your GitHub user may need to have the\n\u201cOwner\u201d role in the organization or, if not, you may have to\nrequest access to authorize Atomist.\n\n\n\n\n\n\n\n\nGitHub User Authorization:\n this authorization is done so that\n    commands and actions you ask the Atomist Bot to perform on your\n    behalf are carried out as your GitHub user.  For example, if you\n    ask the Atomist Bot to create a GitHub issue, it needs to be\n    authorized to create the issue as you.  Every person in your Slack\n    team who wants to ask the Atomist Bot to perform actions against\n    GitHub will need to authorize their GitHub user in this way.\n\n\n\n\n\n\nGitHub Account Authorization\n\u00b6\n\n\nThis section will walk you through the GitHub account authorization\nprocess.  You can perform these steps in any Slack channel that the\nAtomist Bot has been invited to, or you can directly message the\nAtomist Bot.  By default the Atomist Bot is named \n@atomist\n and these\ninstructions assume that is its name in your Slack team.  If the\nAtomist Bot has a different user name in your Slack team, address\nmessages to that user.\n\n\nFirst, ask the Atomist Bot about your GitHub authorizations.\n\n\n@atomist github\n\n\n\n\nIf this Slack team does not have a GitHub Account authorized, the\nAtomist Bot will show a message requesting you to authorize.\n\n\n\n  \n\n\n\n\n\nYou will see messages for both GitHub account authorization (the first\nmessage) and GitHub user authorization (the second message). First,\nlet\u2019s do the account authorization. Click on the \u201cAuthorize GitHub\nAccount\u201d link in the message. You will be redirected to the GitHub\nauthorization page in your browser.\n\n\n\n  \n\n\n\n\n\nFor information on the permissions requested, see \nGitHub Permissions\n.\n\n\nClick the \u201cAuthorize application\u201d button to authorize Atomist and you\nwill then be redirected back to your Slack team in the browser.\n\n\nIf you are not a member of any GitHub organizations, your individual\nGitHub account will be automatically selected, and you will not see\nany organizations listed.  If you are a member of one or more GitHub\norganizations, after authorizing Atomist, you will receive a direct\nmessage in Slack from the Atomist Bot asking whether to use your\nindividual GitHub account or one of your organizations as the GitHub\naccount to associate with Atomist.\n\n\n\n  \n\n\n\n\n\nSelect the GitHub account (your individual account or an organization)\nto associate with Atomist by clicking its button.  Once selected, the\nAtomist Bot will show a confirmation message in Slack.\n\n\n\n  \n\n\n\n\n\nCongratulations, your GitHub account is now authorized.\n\n\nGitHub User Authorization\n\u00b6\n\n\nNow, let\u2019s associate your GitHub user with your Slack user.  To do\nthis, scroll back in the history or enter \n@atomist github\n to show\nthe GitHub authorization message again.\n\n\n\n  \n\n\n\n\n\nClick on the \u201cAuthorize GitHub User\u201d link in the message.  You will be\nredirected to the GitHub authorization page in your browser.\n\n\n\n  \n\n\n\n\n\nClick the \u201cAuthorize application\u201d button to authorize Atomist and you\nwill then be redirected back to your Slack team in the browser, where\nyou will see a confirmation message.\n\n\n\n  \n\n\n\n\n\nIf you use a native client for Slack, you can close the Slack browser\nwindow and go back to your preferred Slack client.  If you use your\nweb browser to access Slack, you will likely have several Slack tabs\nor windows open at this point.  Feel free to close all but one.\n\n\n\n\nNow that you have have connected Atomist in your Slack team and\nGitHub account, you can start using it. Skip to\nthe \nAtomist Bot section\n to get going now.  Atomist can also\nautomate CI notifications and actions. To do so, go through the\nsteps in \nConnect Atomist to CI\n.",
            "title": "Connect Atomist to GitHub"
        },
        {
            "location": "/getting-started/github/#github-account-authorization",
            "text": "This section will walk you through the GitHub account authorization\nprocess.  You can perform these steps in any Slack channel that the\nAtomist Bot has been invited to, or you can directly message the\nAtomist Bot.  By default the Atomist Bot is named  @atomist  and these\ninstructions assume that is its name in your Slack team.  If the\nAtomist Bot has a different user name in your Slack team, address\nmessages to that user.  First, ask the Atomist Bot about your GitHub authorizations.  @atomist github  If this Slack team does not have a GitHub Account authorized, the\nAtomist Bot will show a message requesting you to authorize.  \n     You will see messages for both GitHub account authorization (the first\nmessage) and GitHub user authorization (the second message). First,\nlet\u2019s do the account authorization. Click on the \u201cAuthorize GitHub\nAccount\u201d link in the message. You will be redirected to the GitHub\nauthorization page in your browser.  \n     For information on the permissions requested, see  GitHub Permissions .  Click the \u201cAuthorize application\u201d button to authorize Atomist and you\nwill then be redirected back to your Slack team in the browser.  If you are not a member of any GitHub organizations, your individual\nGitHub account will be automatically selected, and you will not see\nany organizations listed.  If you are a member of one or more GitHub\norganizations, after authorizing Atomist, you will receive a direct\nmessage in Slack from the Atomist Bot asking whether to use your\nindividual GitHub account or one of your organizations as the GitHub\naccount to associate with Atomist.  \n     Select the GitHub account (your individual account or an organization)\nto associate with Atomist by clicking its button.  Once selected, the\nAtomist Bot will show a confirmation message in Slack.  \n     Congratulations, your GitHub account is now authorized.",
            "title": "GitHub Account Authorization"
        },
        {
            "location": "/getting-started/github/#github-user-authorization",
            "text": "Now, let\u2019s associate your GitHub user with your Slack user.  To do\nthis, scroll back in the history or enter  @atomist github  to show\nthe GitHub authorization message again.  \n     Click on the \u201cAuthorize GitHub User\u201d link in the message.  You will be\nredirected to the GitHub authorization page in your browser.  \n     Click the \u201cAuthorize application\u201d button to authorize Atomist and you\nwill then be redirected back to your Slack team in the browser, where\nyou will see a confirmation message.  \n     If you use a native client for Slack, you can close the Slack browser\nwindow and go back to your preferred Slack client.  If you use your\nweb browser to access Slack, you will likely have several Slack tabs\nor windows open at this point.  Feel free to close all but one.   Now that you have have connected Atomist in your Slack team and\nGitHub account, you can start using it. Skip to\nthe  Atomist Bot section  to get going now.  Atomist can also\nautomate CI notifications and actions. To do so, go through the\nsteps in  Connect Atomist to CI .",
            "title": "GitHub User Authorization"
        },
        {
            "location": "/getting-started/ci/",
            "text": "Atomist can listen for continuous integration (CI) events, correlate\nthem with the commits that triggered the build, and show\ncontextualized notifications in an appropriate Slack channel.\nTo enable this, you need to connect Atomist to your CI system.\nAtomist currently integrates with the following CI systems:\n\n\n\n\nTravis CI\n\n\nJenkins\n\n\n\n\nClick on the appropriate link above for instructions to connect\nAtomist with your CI system.",
            "title": "Overview"
        },
        {
            "location": "/getting-started/travis-ci/",
            "text": "Travis CI\n integrates tightly with \nGitHub.com\n.\nAtomist leverages the Travis CI/GitHub.com integration to perform all\noperations it requires.  In other words, once you have set up Travis\nCI with your GitHub account, you are ready to go; no additional\nauthorization is required.  If you have not yet setup Travis and want\nto as part of getting started with Atomist, please see\nthe \nTravis getting started\n documentation.\n\n\n\n\nAtomist works with Travis-CI.org and Travis-CI.com. Travis\nEnterprise is not currently supported.\n\n\n\n\nYou will need to enable your projects to be built using Travis if they\naren\u2019t already set up. See the \nTravis documentation\n to\nset up Travis builds.\n\n\nNext, configure all your Travis builds to send notifications to\nAtomist.  In the \n.travis.yml\n configuration file in each project\nrepository, add the following webhook configuration.\n\n\nnotifications\n:\n\n  \nwebhooks\n:\n\n    \nurls\n:\n\n      \n-\n \nhttps://webhook.atomist.com/travis\n\n    \non_success\n:\n \nalways\n\n    \non_failure\n:\n \nalways\n\n    \non_start\n:\n \nalways\n\n    \non_cancel\n:\n \nalways\n\n    \non_error\n:\n \nalways\n\n\n\n\n\nOnce you commit and push those changes, Travis CI events will start\nflowing to Atomist.  You should go to\nthe \ngetting started with the Atomist Bot\n page to see how build\nevents are integrated into messages with the other events in your\ndevelopment flow.",
            "title": "Travis CI"
        },
        {
            "location": "/getting-started/jenkins/",
            "text": "There are several ways to connect Atomist to \nJenkins\n.  If\nyou are \nnot\n using a \nJenkinsfile\n to configure your build, the\neasiest way to connect Atomist to Jenkins is using\nthe \nNotification plugin\n.  If you \nare\n using a\n\nJenkinsfile\n to configure either a Pipeline or Multibranch Pipeline\njob, you can connect Atomist and Jenkins using the pipeline\nconfiguration in the \nJenkinsfile\n.\n\n\nNotification plugin\n\u00b6\n\n\nIf you don\u2019t already have the \nNotification plugin\n\ninstalled, go to the Plugin Manager in the Jenkins administrative\ninterface, select it, and complete the installation.\n\n\n\n  \n\n\n\n\n\nTo enable the plugin, be sure to restart Jenkins after installation.\n\n\n\n  \n\n\n\n\n\nNow that the Notification plugin is installed and enabled, it\u2019s time\nto configure the plugin to notify Atomist.  Select a project that you\nwould like Atomist to get events from then select \u201cConfigure\u201d from the\nleft column.\n\n\n\n  \n\n\n\n\n\nIn the \u201cJob Notifications\u201d section of the project configuration, click\nthe \u201cAdd Endpoint\u201d button.\n\n\n\n  \n\n\n\n\n\nOn the \u201cJob Notifications\u201d configuration tab, add an endpoint, setting\nthe \u201cNotifications Endpoints\u201d URL to\n\nhttps://webhook.atomist.com/atomist/jenkins\n and leave the other\nvalues at their defaults: Format: JSON, Protocol: HTTP, Event: All\nEvents, Timeout: 30000, and Log: 0.\n\n\n\n  \n\n\n\n\n\nNow, Jenkins is set up to send build notifications to Atomist.  You\nshould go to the \ngetting started with the Atomist Bot\n page to\nsee how build events are integrated into messages with the other\nevents in your development flow.\n\n\nJenkinsfile\n\u00b6\n\n\nIf your Jenkins build is configured using a \nJenkinsfile\n, you\ncan connect Atomist and Jenkins by adding a bit of \u201cpipeline code\u201d to\nthe same \nJenkinsfile\n.  The rest of these instructions assume your\nJenkins instance already has the Pipeline plugins installed and it is\nproperly configured for your project.  If you do not have the Pipeline\nplugins installed and configured, use\nthe \nNotification plugin\n to connect Atomist and\nJenkins.  The instructions below will work for properly\nconfigured \nPipeline\n\nand \nMultibranch Pipeline\n jobs.\n\n\nBefore we configure Jenkins to send build events to Atomist, we add a\ncouple functions to our \nJenkinsfile\n.  First, we add a function that\ngathers information from Git.\n\n\n/*\n\n\n * Retrieve current SCM information from local checkout\n\n\n */\n\n\ndef\n \ngetSCMInformation\n()\n \n{\n\n    \ndef\n \ngitRemoteUrl\n \n=\n \nsh\n(\nreturnStdout:\n \ntrue\n,\n \nscript:\n \n'git config --get remote.origin.url'\n).\ntrim\n()\n\n    \ndef\n \ngitCommitSha\n \n=\n \nsh\n(\nreturnStdout:\n \ntrue\n,\n \nscript:\n \n'git rev-parse HEAD'\n).\ntrim\n()\n\n    \ndef\n \ngitBranchName\n \n=\n \nsh\n(\nreturnStdout:\n \ntrue\n,\n \nscript:\n \n'git name-rev --always --name-only HEAD'\n).\ntrim\n().\nreplace\n(\n'remotes/origin/'\n,\n \n''\n)\n\n\n    \nreturn\n \n[\n\n        \nurl:\n \ngitRemoteUrl\n,\n\n        \nbranch:\n \ngitBranchName\n,\n\n        \ncommit:\n \ngitCommitSha\n\n    \n]\n\n\n}\n\n\n\n\n\nThe \ngetSCMInformation\n()\n function shells out to run the\n\ngit\n command to collect the Git remote URL, commit SHA, and branch\nname, and then returns that information.\n\n\nThe second function shells out to use \ncURL\n to post a JSON\npayload to the Atomist webhook URL.\n\n\nimport\n \ngroovy.json.JsonOutput\n\n\n\n/*\n\n\n * Notify the Atomist services about the status of a build based from a\n\n\n * git repository.\n\n\n */\n\n\ndef\n \nnotifyAtomist\n(\nbuildStatus\n,\n \nbuildPhase\n=\n\"FINALIZED\"\n,\n\n                  \nendpoint\n=\n\"https://webhook.atomist.com/atomist/jenkins\"\n)\n \n{\n\n\n    \ndef\n \npayload\n \n=\n \nJsonOutput\n.\ntoJson\n([\n\n        \nname:\n \nenv\n.\nJOB_NAME\n,\n\n        \nduration:\n \ncurrentBuild\n.\nduration\n,\n\n        \nbuild\n      \n:\n \n[\n\n            \nnumber:\n \nenv\n.\nBUILD_NUMBER\n,\n\n            \nphase:\n \nbuildPhase\n,\n\n            \nstatus:\n \nbuildStatus\n,\n\n            \nfull_url:\n \nenv\n.\nBUILD_URL\n,\n\n            \nscm:\n \ngetSCMInformation\n()\n\n        \n]\n\n    \n])\n\n\n    \nsh\n \n\"curl --silent -XPOST -H 'Content-Type: application/json' -d '${payload}' ${endpoint}\"\n\n\n}\n\n\n\n\n\nNote that the \nnotifyAtomist\n()\n function calls the \ngetSCMInformation\n()\n function.  The rest of the JSON payload is\nconstructed from the build environment provided by Jenkins as\nenvironment variables.\n\n\nWith those functions defined, we can now configure our Pipeline or\nMultibranch Pipeline job.  First, we call the \nnotifyAtomist\n()\n function from within our build step.\n\n\npipeline\n \n{\n\n    \n// ...\n\n    \nstages\n \n{\n\n        \n// ...\n\n        \nstage\n(\n'Build'\n)\n \n{\n\n            \nsteps\n \n{\n\n                \n// notifiy Atomist the buid starts now\n\n                \nnotifyAtomist\n(\n\"UNSTABLE\"\n,\n \n\"STARTED\"\n)\n\n                \n// ...\n\n            \n}\n\n            \n// ...\n\n        \n}\n\n    \n}\n\n    \n// ...\n\n\n}\n\n\n\n\n\nIt is best to call the \nnotifyAtomist\n()\n function as early in\nthe build process as possible.  The commented ellipses, \n// ...\n,\nindicate that we are only showing the portions of the \nJenkinsfile\n\nrelevant to adding the single function call.\n\n\nWe also add calls to the \nnotifyAtomist\n()\n function in\nthe \npost\n section of the \npipeline\n configuration to\nnotify Atomist when the build completes.\n\n\npipeline\n \n{\n\n    \n// ...\n\n    \npost\n \n{\n\n        \nsuccess\n \n{\n\n            \nnotifyAtomist\n(\n\"SUCCESS\"\n)\n\n        \n}\n\n        \nunstable\n \n{\n\n            \nnotifyAtomist\n(\n\"UNSTABLE\"\n)\n\n        \n}\n\n        \nfailure\n \n{\n\n            \nnotifyAtomist\n(\n\"FAILURE\"\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nIf your configuration already contains a \npost\n section, simply add\nthe calls to \nnotifyAtomist\n()\n to the \nsuccess\n, \nunstable\n,\nand \nfailure\n subsections.\n\n\nOnce Jenkins picks up those changes, CI events will start flowing to\nAtomist.  You should go to\nthe \ngetting started with the Atomist Bot\n page to see how build\nevents are integrated into messages with the other events in your\ndevelopment flow.",
            "title": "Jenkins"
        },
        {
            "location": "/getting-started/jenkins/#notification-plugin",
            "text": "If you don\u2019t already have the  Notification plugin \ninstalled, go to the Plugin Manager in the Jenkins administrative\ninterface, select it, and complete the installation.  \n     To enable the plugin, be sure to restart Jenkins after installation.  \n     Now that the Notification plugin is installed and enabled, it\u2019s time\nto configure the plugin to notify Atomist.  Select a project that you\nwould like Atomist to get events from then select \u201cConfigure\u201d from the\nleft column.  \n     In the \u201cJob Notifications\u201d section of the project configuration, click\nthe \u201cAdd Endpoint\u201d button.  \n     On the \u201cJob Notifications\u201d configuration tab, add an endpoint, setting\nthe \u201cNotifications Endpoints\u201d URL to https://webhook.atomist.com/atomist/jenkins  and leave the other\nvalues at their defaults: Format: JSON, Protocol: HTTP, Event: All\nEvents, Timeout: 30000, and Log: 0.  \n     Now, Jenkins is set up to send build notifications to Atomist.  You\nshould go to the  getting started with the Atomist Bot  page to\nsee how build events are integrated into messages with the other\nevents in your development flow.",
            "title": "Notification plugin"
        },
        {
            "location": "/getting-started/jenkins/#jenkinsfile",
            "text": "If your Jenkins build is configured using a  Jenkinsfile , you\ncan connect Atomist and Jenkins by adding a bit of \u201cpipeline code\u201d to\nthe same  Jenkinsfile .  The rest of these instructions assume your\nJenkins instance already has the Pipeline plugins installed and it is\nproperly configured for your project.  If you do not have the Pipeline\nplugins installed and configured, use\nthe  Notification plugin  to connect Atomist and\nJenkins.  The instructions below will work for properly\nconfigured  Pipeline \nand  Multibranch Pipeline  jobs.  Before we configure Jenkins to send build events to Atomist, we add a\ncouple functions to our  Jenkinsfile .  First, we add a function that\ngathers information from Git.  /*   * Retrieve current SCM information from local checkout   */  def   getSCMInformation ()   { \n     def   gitRemoteUrl   =   sh ( returnStdout:   true ,   script:   'git config --get remote.origin.url' ). trim () \n     def   gitCommitSha   =   sh ( returnStdout:   true ,   script:   'git rev-parse HEAD' ). trim () \n     def   gitBranchName   =   sh ( returnStdout:   true ,   script:   'git name-rev --always --name-only HEAD' ). trim (). replace ( 'remotes/origin/' ,   '' ) \n\n     return   [ \n         url:   gitRemoteUrl , \n         branch:   gitBranchName , \n         commit:   gitCommitSha \n     ]  }   The  getSCMInformation ()  function shells out to run the git  command to collect the Git remote URL, commit SHA, and branch\nname, and then returns that information.  The second function shells out to use  cURL  to post a JSON\npayload to the Atomist webhook URL.  import   groovy.json.JsonOutput  /*   * Notify the Atomist services about the status of a build based from a   * git repository.   */  def   notifyAtomist ( buildStatus ,   buildPhase = \"FINALIZED\" , \n                   endpoint = \"https://webhook.atomist.com/atomist/jenkins\" )   { \n\n     def   payload   =   JsonOutput . toJson ([ \n         name:   env . JOB_NAME , \n         duration:   currentBuild . duration , \n         build        :   [ \n             number:   env . BUILD_NUMBER , \n             phase:   buildPhase , \n             status:   buildStatus , \n             full_url:   env . BUILD_URL , \n             scm:   getSCMInformation () \n         ] \n     ]) \n\n     sh   \"curl --silent -XPOST -H 'Content-Type: application/json' -d '${payload}' ${endpoint}\"  }   Note that the  notifyAtomist ()  function calls the  getSCMInformation ()  function.  The rest of the JSON payload is\nconstructed from the build environment provided by Jenkins as\nenvironment variables.  With those functions defined, we can now configure our Pipeline or\nMultibranch Pipeline job.  First, we call the  notifyAtomist ()  function from within our build step.  pipeline   { \n     // ... \n     stages   { \n         // ... \n         stage ( 'Build' )   { \n             steps   { \n                 // notifiy Atomist the buid starts now \n                 notifyAtomist ( \"UNSTABLE\" ,   \"STARTED\" ) \n                 // ... \n             } \n             // ... \n         } \n     } \n     // ...  }   It is best to call the  notifyAtomist ()  function as early in\nthe build process as possible.  The commented ellipses,  // ... ,\nindicate that we are only showing the portions of the  Jenkinsfile \nrelevant to adding the single function call.  We also add calls to the  notifyAtomist ()  function in\nthe  post  section of the  pipeline  configuration to\nnotify Atomist when the build completes.  pipeline   { \n     // ... \n     post   { \n         success   { \n             notifyAtomist ( \"SUCCESS\" ) \n         } \n         unstable   { \n             notifyAtomist ( \"UNSTABLE\" ) \n         } \n         failure   { \n             notifyAtomist ( \"FAILURE\" ) \n         } \n     }  }   If your configuration already contains a  post  section, simply add\nthe calls to  notifyAtomist ()  to the  success ,  unstable ,\nand  failure  subsections.  Once Jenkins picks up those changes, CI events will start flowing to\nAtomist.  You should go to\nthe  getting started with the Atomist Bot  page to see how build\nevents are integrated into messages with the other events in your\ndevelopment flow.",
            "title": "Jenkinsfile"
        },
        {
            "location": "/getting-started/bot/",
            "text": "Atomist can now be put to work: reporting on events in your\ndevelopment systems, creating projects, editing code, managing issues,\nand generally tying your whole development process together.  Let\u2019s\nkick things off by connecting some of your existing code repositories\nto your chat channels.  After that, we\u2019ll use the Atomist Bot to\ncreate a new project for us using a generator.\n\n\nUsing Atomist on existing projects\n\u00b6\n\n\nYou almost certainly have many existing projects that you would like\nAtomist\u2019s help keeping track of.  To get Atomist\u2019s help with an\nexisting GitHub repository, simply invite the Atomist Bot to a channel\nwhere you discuss that repository.  You can invite the Atomist Bot to\na channel just as you would invite any other user, e.g., by using the\n\n/invite @atomist\n command.  Once the Atomist Bot is in the channel,\nyou can tell the Atomist Bot what repository to associate with the\nchannel by sending it the \nrepo\n message.  The \nrepo\n command takes a\nsingle argument, the name of the repository you want to associate with\nthe channel.  You supply just the name of the repository, not\nincluding the repository owner since the Atomist Bot already knows\nwhat GitHub organization is associated with your Slack team.\n\n\n@atomist repo REPOSITORY_NAME\n\n\n\n\n\n\nIf you are working through these steps in\nthe \nAtomist Community Slack\n, associations can only be\nmade with repositories in the \natomist\n GitHub organization.\n\n\n\n\nAt any time you can ask the Atomist Bot to tell you what repository is\nassociated with the current channel by sending it the \nrepos\n message.\n\n\n@atomist repos\n\n\n\n\nThe Atomist Bot will respond with the repositories linked to the\ncurrent channel, providing links to the repositories and buttons to\nallow you to quickly un-link the channel and repository.\n\n\n\n  \n\n\n\n\n\nYou can link more than one repository to a chat channel if you have a\nset of related repositories that are all discussed in a single\nchannel.\n\n\n\n\nWhile you can also link a single repository to multiple chat\nchannels, repository and build messages for that repository will\nonly be sent to one of the channels, so we do not recommend it.\n\n\n\n\nGitHub and CI notifications\n\u00b6\n\n\nOnce the association between a repository and chat channel is made,\nthe Atomist Bot will begin reporting on activity in the associated\nrepository.  You can see these messages by committing and pushing a\nchange to the repository.  The Atomist Bot will post a message to the\nchat channel detailing the commits in the push and, if you have\nconnected Atomist with your CI system, build status, updating it as\nthe build goes from started to successful.\n\n\n\n  \n\n\n\n\n\nThe Atomist Bot will also send messages when \nissues\n\nand \npull requests (PRs)\n are created, changed, and closed.\nHere\u2019s an example of a message the Atomist Bot sends when someone\ncloses an issue.\n\n\n\n  \n\n\n\n\n\nChanging GitHub from Slack\n\u00b6\n\n\nGetting well-formatted message in Slack about what is happening to\nyour project on GitHub is nice, but it only scratches the surface of\nwhat Atomist can do.  In addition to passively receiving and then\ndisplaying GitHub events, Atomist can generate and modify code and\nopen issues and PRs, all without you ever having to leave Slack.  To\ndemonstrate this capability, you will use the Atomist Bot to create a\nGitHub Issue.\n\n\nYou can open GitHub Issues without leaving chat by sending a \ncreate\nissue\n message to the Atomist Bot.  When running commands like this,\nthe Atomist Bot is aware of the context in which it is asked to run\nthe skill.  This allows the Atomist Bot to collect less information in\ncertain situations.  What does this mean?  This can be illustrated by\nrunning the same command in two different channels.  First, run the\n\ncreate issue\n command in the \n#general\n channel, which is not\nassociated with any repository, of your Slack team.\n\n\n@atomist create issue\n\n\n\n\nThe Atomist Bot responds in a thread, collecting the information it\nneeds to create the issue.\n\n\n\n  \n\n\n\n\n\nSince the \n#general\n channel is not linked to a specific GitHub\nrepository, the Atomist Bot must ask you in what repository you\nwant to create the issue.\n\n\nCompare this to sending the same \ncreate issue\n message to the Atomist\nBot in a channel associated with a repository.  As usual, your Atomist\nBot will start a thread to collect all the information necessary it\nneeds to complete the request, but it will not ask you to enter a\nrepository.\n\n\n\n  \n\n\n\n\n\nSince there is already an association between the channel in which the\nmessage was sent and a repository, the Atomist Bot will automatically\npass the associated repository along with the request.  No need for\nyou to enter it in!\n\n\nWith either approach, once you have entered all the needed\ninformation, your Atomist Bot will respond with a summary and the\noption to submit or cancel.\n\n\n\n  \n\n\n\n\n\nClick the \u201cSubmit\u201d button and Atomist will create the issue and then\nrespond back in the channel where the thread started.\n\n\n\n  \n\n\n\n\n\nBut that\u2019s not where the interaction stops.  The Atomist Bot will also\npost a message in the repository channel containing a summary of the\nnewly created issue \nand\n some buttons for common actions taken on\nissues: assign it someone, add a label, add a comment, etc.\n\n\n\n  \n\n\n\n\n\nGo ahead and click on the link to see the issue on GitHub.\n\n\n\n  \n\n\n\n\n\nNow head back to the repository channel in Slack and click on the\n\u201cBug\u201d button to add the \u201cbug\u201d label to the issue:\n\n\n\n  \n\n\n\n\n\nWe see the Atomist Bot responding that it has successfully edited the\nissue.  Let\u2019s make sure.  Click on the link to open up the issue in\nGitHub.\n\n\n\n  \n\n\n\n\n\nWe can see that Atomist, as us, has labeled the issue a bug, just as\nwe asked.\n\n\nNow imagine that you are another team member who has noticed this new\nissue and wants to add a comment from inside GitHub.  Using the GitHub\nweb interface, add a comment and click the \u201cComment\u201d button.\n\n\n\n  \n\n\n\n\n\nYou will see a new message in the \n#sprocket\n channel from the Atomist\nBot notifying you that the issue has been updated.\n\n\n\n  \n\n\n\n\n\nAfter connecting Atomist and GitHub, we can see GitHub events in\nSlack, take action on them, and see the result in GitHub and Slack.\n\n\nCreate a new project\n\u00b6\n\n\nYou can ask the Atomist Bot to create a new project for you either\nthrough a direct message or by addressing the Bot in a channel it has\nbeen invited to.  For our purposes, we will assume you are starting\nthe conversation in your Slack team\u2019s \n#general\n channel, which the\nAtomist Bot joins when invited to your Slack team, and that the\nAtomist Bot is named \n@atomist\n.  In the \n#general\n channel, type the\nfollowing message.\n\n\n@atomist generators\n\n\n\n\nThe Atomist Bot will reply with a list of project generators that it\ncan use on your behalf to create a new project in GitHub.  The Atomist\nBot will respond with a list of project generators something like the\nfollowing.\n\n\n\n  \n\n\n\n\n\nWhile the full list of project generators \ncan\n be useful if you are\njust browsing, we want to create a \nSpring Boot\n REST service,\nso we can narrow down the list by providing a search term, \u201cspring\u201d in\nthis case.\n\n\n@atomist generators spring\n\n\n\n\nThis time the Atomist Bot will respond with a list of project\ngenerators matching the search term, including the\n\nNewSpringBootRestService\n generator.\n\n\n\n  \n\n\n\n\n\nClick on the \u201cGenerate project\u201d button to begin the process of\ncreating your new project.\n\n\n\n  \n\n\n\n\n\nThe Atomist Bot will respond with a message telling you what project\ngenerator you created and then start a \nthread\n off that message to\ngather the information it needs to generate the project.  Click now on\nthe \u201c1 reply\u201d link below the message to open up the thread in Slack.\nYou will see that the Atomist Bot has asked you a question in the\nthread.\n\n\n\n  \n\n\n\n\n\nType in a name for your new project and press \nEnter\n.  The project\nname must be a valid GitHub repository name, containing only letters,\nnumbers, dashes (\n-\n), and underscores (\n_\n).  Since the project name\nis the only required input parameter for the\n\nNewSpringBootRestService\n generator, the Atomist Bot will respond\nwith a message showing the project name you entered and the default\nvalues for all the other input parameters.\n\n\n\n  \n\n\n\n\n\n\n\nIf the name of the project you created is longer than 21\ncharacters, the channel name will be truncated to 21 characters,\nthe maximum length channel name Slack allows.\n\n\n\n\nYou can change the value for any of the parameters by typing in \nset\n<parameter> <value>\n before you click on \nGenerate project\n.\n\n\nNow click on \nGenerate project\n and you\u2019ll see several things happen:\n\n\n\n\nIn the thread, the Atomist Bot will announce \u201cOne moment while I\n    run the generator.\u201d\n\n\nAtomist will go and create the repository for you in the GitHub\n    account you previously authorized.\n\n\nThe Atomist Bot will announce that it has \u201cSuccessfully generated\n    your project\u201d back in the main channel where the project creation\n    thread was started in, in our case that would be \n#general\n.  The\n    announcement will contain a link to the newly generated project.\n\n\nAtomist will create a new channel in your Slack team for the new\n    project, that will also be associated with the project\u2019s\n    repository so when you want to work on that project, you do it in\n    that channel.\n\n\n\n\n\n\nIf you are working through these steps in\nthe \nAtomist Community Slack\n, the new repository will\nbe created under your personal GitHub account and the Atomist Bot\nwill \nnot\n create a Slack channel for the repository.  You can see\nexample GitHub and CI notifications in channels associated with\nthe Atomist open source project repositories like \n#rug\n and\n\n#rug-cli\n.\n\n\n\n\nHere\u2019s what the successful project creation message looks like:\n\n\n\n  \n\n\n\n\n\nClick on the project link to see your project in GitHub.\n\n\n\n  \n\n\n\n\n\nClone your new repository from GitHub and you will have a new, working\nproject courtesy of Atomist.",
            "title": "Atomist Bot"
        },
        {
            "location": "/getting-started/bot/#using-atomist-on-existing-projects",
            "text": "You almost certainly have many existing projects that you would like\nAtomist\u2019s help keeping track of.  To get Atomist\u2019s help with an\nexisting GitHub repository, simply invite the Atomist Bot to a channel\nwhere you discuss that repository.  You can invite the Atomist Bot to\na channel just as you would invite any other user, e.g., by using the /invite @atomist  command.  Once the Atomist Bot is in the channel,\nyou can tell the Atomist Bot what repository to associate with the\nchannel by sending it the  repo  message.  The  repo  command takes a\nsingle argument, the name of the repository you want to associate with\nthe channel.  You supply just the name of the repository, not\nincluding the repository owner since the Atomist Bot already knows\nwhat GitHub organization is associated with your Slack team.  @atomist repo REPOSITORY_NAME   If you are working through these steps in\nthe  Atomist Community Slack , associations can only be\nmade with repositories in the  atomist  GitHub organization.   At any time you can ask the Atomist Bot to tell you what repository is\nassociated with the current channel by sending it the  repos  message.  @atomist repos  The Atomist Bot will respond with the repositories linked to the\ncurrent channel, providing links to the repositories and buttons to\nallow you to quickly un-link the channel and repository.  \n     You can link more than one repository to a chat channel if you have a\nset of related repositories that are all discussed in a single\nchannel.   While you can also link a single repository to multiple chat\nchannels, repository and build messages for that repository will\nonly be sent to one of the channels, so we do not recommend it.",
            "title": "Using Atomist on existing projects"
        },
        {
            "location": "/getting-started/bot/#github-and-ci-notifications",
            "text": "Once the association between a repository and chat channel is made,\nthe Atomist Bot will begin reporting on activity in the associated\nrepository.  You can see these messages by committing and pushing a\nchange to the repository.  The Atomist Bot will post a message to the\nchat channel detailing the commits in the push and, if you have\nconnected Atomist with your CI system, build status, updating it as\nthe build goes from started to successful.  \n     The Atomist Bot will also send messages when  issues \nand  pull requests (PRs)  are created, changed, and closed.\nHere\u2019s an example of a message the Atomist Bot sends when someone\ncloses an issue.",
            "title": "GitHub and CI notifications"
        },
        {
            "location": "/getting-started/bot/#changing-github-from-slack",
            "text": "Getting well-formatted message in Slack about what is happening to\nyour project on GitHub is nice, but it only scratches the surface of\nwhat Atomist can do.  In addition to passively receiving and then\ndisplaying GitHub events, Atomist can generate and modify code and\nopen issues and PRs, all without you ever having to leave Slack.  To\ndemonstrate this capability, you will use the Atomist Bot to create a\nGitHub Issue.  You can open GitHub Issues without leaving chat by sending a  create\nissue  message to the Atomist Bot.  When running commands like this,\nthe Atomist Bot is aware of the context in which it is asked to run\nthe skill.  This allows the Atomist Bot to collect less information in\ncertain situations.  What does this mean?  This can be illustrated by\nrunning the same command in two different channels.  First, run the create issue  command in the  #general  channel, which is not\nassociated with any repository, of your Slack team.  @atomist create issue  The Atomist Bot responds in a thread, collecting the information it\nneeds to create the issue.  \n     Since the  #general  channel is not linked to a specific GitHub\nrepository, the Atomist Bot must ask you in what repository you\nwant to create the issue.  Compare this to sending the same  create issue  message to the Atomist\nBot in a channel associated with a repository.  As usual, your Atomist\nBot will start a thread to collect all the information necessary it\nneeds to complete the request, but it will not ask you to enter a\nrepository.  \n     Since there is already an association between the channel in which the\nmessage was sent and a repository, the Atomist Bot will automatically\npass the associated repository along with the request.  No need for\nyou to enter it in!  With either approach, once you have entered all the needed\ninformation, your Atomist Bot will respond with a summary and the\noption to submit or cancel.  \n     Click the \u201cSubmit\u201d button and Atomist will create the issue and then\nrespond back in the channel where the thread started.  \n     But that\u2019s not where the interaction stops.  The Atomist Bot will also\npost a message in the repository channel containing a summary of the\nnewly created issue  and  some buttons for common actions taken on\nissues: assign it someone, add a label, add a comment, etc.  \n     Go ahead and click on the link to see the issue on GitHub.  \n     Now head back to the repository channel in Slack and click on the\n\u201cBug\u201d button to add the \u201cbug\u201d label to the issue:  \n     We see the Atomist Bot responding that it has successfully edited the\nissue.  Let\u2019s make sure.  Click on the link to open up the issue in\nGitHub.  \n     We can see that Atomist, as us, has labeled the issue a bug, just as\nwe asked.  Now imagine that you are another team member who has noticed this new\nissue and wants to add a comment from inside GitHub.  Using the GitHub\nweb interface, add a comment and click the \u201cComment\u201d button.  \n     You will see a new message in the  #sprocket  channel from the Atomist\nBot notifying you that the issue has been updated.  \n     After connecting Atomist and GitHub, we can see GitHub events in\nSlack, take action on them, and see the result in GitHub and Slack.",
            "title": "Changing GitHub from Slack"
        },
        {
            "location": "/getting-started/bot/#create-a-new-project",
            "text": "You can ask the Atomist Bot to create a new project for you either\nthrough a direct message or by addressing the Bot in a channel it has\nbeen invited to.  For our purposes, we will assume you are starting\nthe conversation in your Slack team\u2019s  #general  channel, which the\nAtomist Bot joins when invited to your Slack team, and that the\nAtomist Bot is named  @atomist .  In the  #general  channel, type the\nfollowing message.  @atomist generators  The Atomist Bot will reply with a list of project generators that it\ncan use on your behalf to create a new project in GitHub.  The Atomist\nBot will respond with a list of project generators something like the\nfollowing.  \n     While the full list of project generators  can  be useful if you are\njust browsing, we want to create a  Spring Boot  REST service,\nso we can narrow down the list by providing a search term, \u201cspring\u201d in\nthis case.  @atomist generators spring  This time the Atomist Bot will respond with a list of project\ngenerators matching the search term, including the NewSpringBootRestService  generator.  \n     Click on the \u201cGenerate project\u201d button to begin the process of\ncreating your new project.  \n     The Atomist Bot will respond with a message telling you what project\ngenerator you created and then start a  thread  off that message to\ngather the information it needs to generate the project.  Click now on\nthe \u201c1 reply\u201d link below the message to open up the thread in Slack.\nYou will see that the Atomist Bot has asked you a question in the\nthread.  \n     Type in a name for your new project and press  Enter .  The project\nname must be a valid GitHub repository name, containing only letters,\nnumbers, dashes ( - ), and underscores ( _ ).  Since the project name\nis the only required input parameter for the NewSpringBootRestService  generator, the Atomist Bot will respond\nwith a message showing the project name you entered and the default\nvalues for all the other input parameters.  \n      If the name of the project you created is longer than 21\ncharacters, the channel name will be truncated to 21 characters,\nthe maximum length channel name Slack allows.   You can change the value for any of the parameters by typing in  set\n<parameter> <value>  before you click on  Generate project .  Now click on  Generate project  and you\u2019ll see several things happen:   In the thread, the Atomist Bot will announce \u201cOne moment while I\n    run the generator.\u201d  Atomist will go and create the repository for you in the GitHub\n    account you previously authorized.  The Atomist Bot will announce that it has \u201cSuccessfully generated\n    your project\u201d back in the main channel where the project creation\n    thread was started in, in our case that would be  #general .  The\n    announcement will contain a link to the newly generated project.  Atomist will create a new channel in your Slack team for the new\n    project, that will also be associated with the project\u2019s\n    repository so when you want to work on that project, you do it in\n    that channel.    If you are working through these steps in\nthe  Atomist Community Slack , the new repository will\nbe created under your personal GitHub account and the Atomist Bot\nwill  not  create a Slack channel for the repository.  You can see\nexample GitHub and CI notifications in channels associated with\nthe Atomist open source project repositories like  #rug  and #rug-cli .   Here\u2019s what the successful project creation message looks like:  \n     Click on the project link to see your project in GitHub.  \n     Clone your new repository from GitHub and you will have a new, working\nproject courtesy of Atomist.",
            "title": "Create a new project"
        },
        {
            "location": "/getting-started/what-next/",
            "text": "Congratulations, you\u2019ve made it through the Atomist Getting Started\nguide.  Now that you\u2019re up and running with Atomist, please be sure\nto:\n\n\n\n\nLearn how to customize Atomist by working through our \ntutorials\n\n\nJoin the \nAtomist Community Slack\n\n\nFollowing our blog, \nThe Composition\n\n\nFollow \n@atomist\n on Twitter\n\n\n\n\nIf you want more detailed documentation on all aspects of Atomist, you\ncan head directly to our \nAtomist User Guide\n.",
            "title": "What next"
        },
        {
            "location": "/tutorials/",
            "text": "In the \nGetting Started\n section, you connected Atomist to your\ndevelopment systems and learned how to use some of the built-in\nfunctionality that Atomist provides.  These tutorials will teach you\nhow to extend and customize Atomist, tailoring it to your own\ndevelopment workflow and processes.\n\n\nPrerequisites\n\u00b6\n\n\nCompleting the \nGetting Started\n steps so that Atomist Bot is in your\nSlack team and connected to your GitHub account is a prerequisite for the tutorials.\n\n\nThe tutorials are organized so that the first few ensure that you are set up for\nwriting and publishing Rug scripts.",
            "title": "Introduction"
        },
        {
            "location": "/tutorials/#prerequisites",
            "text": "Completing the  Getting Started  steps so that Atomist Bot is in your\nSlack team and connected to your GitHub account is a prerequisite for the tutorials.  The tutorials are organized so that the first few ensure that you are set up for\nwriting and publishing Rug scripts.",
            "title": "Prerequisites"
        },
        {
            "location": "/tutorials/setup-cli/",
            "text": "This is the quick version of the Rug CLI setup on Mac OS X using Homebrew. If you use\na different operating system or run into issues, please see the full\n\nRug CLI installation\n documentation.\n\n\nInstall Rug CLI\n\u00b6\n\n\n$\n brew tap atomist/tap\n\n$\n brew install rug-cli\n\n\n\n\nConfigure Rug CLI GitHub Access\n\u00b6\n\n\nUse the \nrug login\n command to set up your Rug CLI configuration for\naccess to GitHub.  Provide your GitHub.com login name and password\nwhen prompted.\n\n\n$\n rug login\n\nResolving dependencies for com.atomist:rug (0.26.1\u00b7jar) completed\n\n\n\nThe Rug CLI needs your GitHub login to identify you.\n\n\n\nThe command will create a GitHub Personal Access Token with scope 'read:org'\n\n\nwhich you can revoke any time on https://github.com/settings/tokens.  Your\n\n\npassword will not be displayed or stored.  Your sensitive information will not\n\n\nbe sent to Atomist; only to api.github.com.\n\n\n\n  \u2192 Username : jrday\n\n\n  \u2192 Password : **************\n\n\n\n  Please provide a MFA code\n\n\n  \u2192 MFA code : ******\n\n\n\nSuccessfully logged in to GitHub and stored token in ~/.atomist/cli.yml\n\n\n\n\n\nThe Rug CLI will authenticate against GitHub and create\na \npersonal access token\n with \u201cread:org\u201d scope and store it so\nit can determine what GitHub orgs you are in when configuring your\nrepositories (see below).\n\n\n\n\nDo not enter a personal access token\n\n\nGitHub requires that you authenticate with your password, not a\npersonal access token, when creating a personal access token so be\nsure to provide your GitHub username and \npassword\n.\n\n\n\n\nIf you have two-factor authentication configure on your GitHub account,\nyou will be prompted for your second factor code as \nMFA code\n.\n\n\n\n\nAtomist does not store your GitHub credentials\n\n\nAs the command output says, Atomist does not store your GitHub\ncredentials.  They are used to authenticate against the GiTHub API\nto create a properly scoped personal access token.\n\n\n\n\nConfigure Repositories\n\u00b6\n\n\nRun the \nrug configure repositories\n command so the Rug CLI can use\nyour GitHub authentication to configure all of your private Rug\narchive repositories and enables them for publication with the\n\npublish\n command.\n\n\n$\n rug configure repositories\n\nResolving dependencies for com.atomist:rug (0.26.1\u00b7jar) completed\n\n\nConfiguring team-scoped repositories completed\n\n\n\n\u2192 Repositories\n\n\n  t489lv5qf (sfz)\n\n\n  \u2514\u2500\u2500 https://atomist.jfrog.io/atomist/T489LV5QF\n\n\n\nSuccessfully configured team-scoped repositories\n\n\n\n\n\nNow, your local CLI is configured and ready to publish Rug projects.",
            "title": "Setup Rug CLI"
        },
        {
            "location": "/tutorials/setup-cli/#install-rug-cli",
            "text": "$  brew tap atomist/tap $  brew install rug-cli",
            "title": "Install Rug CLI"
        },
        {
            "location": "/tutorials/setup-cli/#configure-rug-cli-github-access",
            "text": "Use the  rug login  command to set up your Rug CLI configuration for\naccess to GitHub.  Provide your GitHub.com login name and password\nwhen prompted.  $  rug login Resolving dependencies for com.atomist:rug (0.26.1\u00b7jar) completed  The Rug CLI needs your GitHub login to identify you.  The command will create a GitHub Personal Access Token with scope 'read:org'  which you can revoke any time on https://github.com/settings/tokens.  Your  password will not be displayed or stored.  Your sensitive information will not  be sent to Atomist; only to api.github.com.    \u2192 Username : jrday    \u2192 Password : **************    Please provide a MFA code    \u2192 MFA code : ******  Successfully logged in to GitHub and stored token in ~/.atomist/cli.yml   The Rug CLI will authenticate against GitHub and create\na  personal access token  with \u201cread:org\u201d scope and store it so\nit can determine what GitHub orgs you are in when configuring your\nrepositories (see below).   Do not enter a personal access token  GitHub requires that you authenticate with your password, not a\npersonal access token, when creating a personal access token so be\nsure to provide your GitHub username and  password .   If you have two-factor authentication configure on your GitHub account,\nyou will be prompted for your second factor code as  MFA code .   Atomist does not store your GitHub credentials  As the command output says, Atomist does not store your GitHub\ncredentials.  They are used to authenticate against the GiTHub API\nto create a properly scoped personal access token.",
            "title": "Configure Rug CLI GitHub Access"
        },
        {
            "location": "/tutorials/setup-cli/#configure-repositories",
            "text": "Run the  rug configure repositories  command so the Rug CLI can use\nyour GitHub authentication to configure all of your private Rug\narchive repositories and enables them for publication with the publish  command.  $  rug configure repositories Resolving dependencies for com.atomist:rug (0.26.1\u00b7jar) completed  Configuring team-scoped repositories completed  \u2192 Repositories    t489lv5qf (sfz)    \u2514\u2500\u2500 https://atomist.jfrog.io/atomist/T489LV5QF  Successfully configured team-scoped repositories   Now, your local CLI is configured and ready to publish Rug projects.",
            "title": "Configure Repositories"
        },
        {
            "location": "/tutorials/create-rug-project/",
            "text": "We provide a generator that can be run from your Slack team to create\na new Rug project using standard setup, sensible defaults, and starter\nRugs.\n\n\n\n\nPrerequisites\n\n\nCompleting the \nGetting Started Guide\n is a\nprerequisite for this tutorial.\n\n\n\n\nIn \n#general\n or any channel in your Slack team that Atomist Bot has\nbeen invited to, type this message:\n\n\n@atomist generators starter\n\n\n\n\nThe Bot will show generators with the tag \nstarter\n like following.\n\n\n\n  \n\n\n\n\n\nClick on the \u201cGenerate project\u201d button for the \nNewStarterRugProject\n generator.\n\n\nThe Atomist Bot will respond with a message telling you what project\ngenerator you created and then start a \nthread\n off that message to\ngather the information it needs to generate the project.  Click now on\nthe \u201c1 reply\u201d link below the message to open up the thread in Slack.\nYou will see that the Atomist Bot has asked you a question in the\nthread.\n\n\n\n  \n\n\n\n\n\nType in a name for your new project and press \nEnter\n.  A new\nrepository with this name will be created, so the project name must be\na valid GitHub repository name.\n\n\n\n  \n\n\n\n\n\nNow click on \u201cGenerate project\u201d and the Atomist Bot will create the\nproject in a new GitHub repository, then confirm with a message\nsimilar to the following.\n\n\n\n  \n\n\n\n\n\nYou now have a starter Rug project to write new Rugs in. Click on the project link\nto see your project in GitHub.\n\n\nWe recommend you make a local clone of this new repository for use in other tutorials.",
            "title": "Create Rug Project"
        },
        {
            "location": "/tutorials/setup-typescript/",
            "text": "Atomist Rugs are most often developed using \nTypeScript\n.  To\nsuccessfully complete the rest of the tutorials, you will need to have\nseveral TypeScript-related tools installed locally on your system.\n\n\nNPM\n\u00b6\n\n\nYou will need the \nNode.js package manager\n, \nnpm\n, installed on\nyour system to install the Rug TypeScript dependencies.  The easiest\nway to install NPM is to install \nNode.js\n, whose installation\nincludes NPM.  There are links to install Node.js right on its home\npage.  You can install either the LTS or Current version.\n\n\nTypeScript\n\u00b6\n\n\nOnce you have NPM installed, you should install TypeScript\nand \nTSLint\n with the following command.\n\n\n$\n npm install --global tslint typescript\n\n\n\n\nThe \ntypescript\n package will install the TypeScript compiler and\nother tools.  TSLint, like linting programs for other languages,\nprovides and enforces a set of development best-practices to your\nRugs.\n\n\nFor a smooth development experience, we recommend you\nuse \nVisual Studio Code\n with the \nTSLint plugin\n.",
            "title": "Setup TypeScript"
        },
        {
            "location": "/tutorials/setup-typescript/#npm",
            "text": "You will need the  Node.js package manager ,  npm , installed on\nyour system to install the Rug TypeScript dependencies.  The easiest\nway to install NPM is to install  Node.js , whose installation\nincludes NPM.  There are links to install Node.js right on its home\npage.  You can install either the LTS or Current version.",
            "title": "NPM"
        },
        {
            "location": "/tutorials/setup-typescript/#typescript",
            "text": "Once you have NPM installed, you should install TypeScript\nand  TSLint  with the following command.  $  npm install --global tslint typescript  The  typescript  package will install the TypeScript compiler and\nother tools.  TSLint, like linting programs for other languages,\nprovides and enforces a set of development best-practices to your\nRugs.  For a smooth development experience, we recommend you\nuse  Visual Studio Code  with the  TSLint plugin .",
            "title": "TypeScript"
        },
        {
            "location": "/tutorials/publish-rug-project/",
            "text": "To make new or modified Rug scripts in your Rug project available\nin your team, you will need to publish the Rug project.\n\n\n\n\nPrerequisites\n\n\nCompleting the \nGetting Started Guide\n\nand the \nRug CLI setup\n,\n\nRug project creation\n, and \nTypeScript setup\n\ntutorials are prerequisites for this tutorial.\n\n\n\n\nInstall Dependencies\n\u00b6\n\n\nThe Rug project contains \nNPM\n module dependencies that need to\nbe installed before we publish.  Run the following command from within\nyour Rug project directory to install its dependencies.\n\n\n$\n \n(\n \ncd\n .atomist \n&&\n npm install \n)\n\n\n\n\n\nIdentify Slack Team ID\n\u00b6\n\n\nSince you may be in multiple Slack teams that have the Atomist Bot\ninstalled (for example, atomist-community public Slack team and your\nown Slack team), you will need to tell the Rug CLI which team to\npublish this Rug project to.\n\n\nYou can find the team ID from within your Slack team. Send this\nmessage in \n#general\n or any channel that the Atomist Bot has been\ninvited to.\n\n\n@atomist team\n\n\n\n\n\n  \n\n\n\n\n\nIn this example, the Slack team ID is \u201cT489LV5QF\u201d.\n\n\nPublish\n\u00b6\n\n\nNow that you know your Slack team ID, you can publish your Rug project\narchive.  Pass the lower-cased version of your Slack team ID to the\n\nrug publish\n command like this.\n\n\n$\n rug publish --id\n=\nt489lv5qf\n\nResolving dependencies for atomist-contrib:atomist-tutorials (0.1.0\u00b7local) completed\n\n\nInvoking compilers on project sources completed\n\n\nLoading atomist-contrib:atomist-tutorials (0.1.0\u00b7local) completed\n\n\nGenerating archive metadata completed\n\n\nPublishing archive into remote repository completed\n\n\n\n\u2192 Archive\n\n\n  ~/github/jrday/atomist-tutorials/.atomist/target/atomist-tutorials-0.1.0.zip (360 kb in 338 files)\n\n\n\n\u2192 URL\n\n\n  https://atomist.jfrog.io/atomist/T489LV5QF/atomist-contrib/atomist-tutorials/0.1.0/atomist-tutorials-0.1.0.zip\n\n\n\nSuccessfully published archive for atomist-contrib:atomist-tutorials (0.1.0)\n\n\n\n\n\nYou have successfully published a Rug project archive!",
            "title": "Publish Rug Project"
        },
        {
            "location": "/tutorials/publish-rug-project/#install-dependencies",
            "text": "The Rug project contains  NPM  module dependencies that need to\nbe installed before we publish.  Run the following command from within\nyour Rug project directory to install its dependencies.  $   (   cd  .atomist  &&  npm install  )",
            "title": "Install Dependencies"
        },
        {
            "location": "/tutorials/publish-rug-project/#identify-slack-team-id",
            "text": "Since you may be in multiple Slack teams that have the Atomist Bot\ninstalled (for example, atomist-community public Slack team and your\nown Slack team), you will need to tell the Rug CLI which team to\npublish this Rug project to.  You can find the team ID from within your Slack team. Send this\nmessage in  #general  or any channel that the Atomist Bot has been\ninvited to.  @atomist team  \n     In this example, the Slack team ID is \u201cT489LV5QF\u201d.",
            "title": "Identify Slack Team ID"
        },
        {
            "location": "/tutorials/publish-rug-project/#publish",
            "text": "Now that you know your Slack team ID, you can publish your Rug project\narchive.  Pass the lower-cased version of your Slack team ID to the rug publish  command like this.  $  rug publish --id = t489lv5qf Resolving dependencies for atomist-contrib:atomist-tutorials (0.1.0\u00b7local) completed  Invoking compilers on project sources completed  Loading atomist-contrib:atomist-tutorials (0.1.0\u00b7local) completed  Generating archive metadata completed  Publishing archive into remote repository completed  \u2192 Archive    ~/github/jrday/atomist-tutorials/.atomist/target/atomist-tutorials-0.1.0.zip (360 kb in 338 files)  \u2192 URL    https://atomist.jfrog.io/atomist/T489LV5QF/atomist-contrib/atomist-tutorials/0.1.0/atomist-tutorials-0.1.0.zip  Successfully published archive for atomist-contrib:atomist-tutorials (0.1.0)   You have successfully published a Rug project archive!",
            "title": "Publish"
        },
        {
            "location": "/tutorials/add-bot-command/",
            "text": "You can write custom commands that the Atomist Bot can run in your team. We\ncall these \nskills\n, and you can teach the bot new skills to\nautomate common tasks your team routinely performs. Those skills are\nimplemented inside Rug command handlers and this tutorial will show you\nhow to create a new one.\n\n\n\n\nPrerequisites\n\n\nCompleting the \nGetting Started Guide\n\nand the \nRug CLI setup\n,\n\nRug project creation\n, \nTypeScript setup\n,\nand \nRug archive publishing\n tutorials are prerequisites\nfor this tutorial.\n\n\n\n\nSearch StackOverflow from Slack\n\u00b6\n\n\nIn this example, you will teach the Atomist Bot to search\nStackOverflow and show you the first few results right in chat.\n\n\nHere is the TypeScript code for a command that does this.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\nimport\n \n{\n\n    \nCommandHandler\n,\n \nIntent\n,\n \nParameter\n,\n \nParseJson\n,\n\n    \nResponseHandler\n,\n \nTags\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Decorators\"\n;\n\n\nimport\n \n{\n\n    \nCommandPlan\n,\n \nHandleCommand\n,\n \nHandlerContext\n,\n \nHandleResponse\n,\n\n    \nMessageMimeTypes\n,\n \nResponse\n,\n \nResponseMessage\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Handlers\"\n;\n\n\nimport\n \n*\n \nas\n \nmustache\n \nfrom\n \n\"mustache\"\n;\n\n\n\nconst\n \napiSearchUrl\n \n=\n\n    \n`http://api.stackexchange.com/2.2/search/advanced?pagesize=3&order=desc&sort=relevance&site=stackoverflow&q=`\n;\n\n\nconst\n \nwebSearchUrl\n \n=\n \n`http://stackoverflow.com/search?order=desc&sort=relevance&q=`\n;\n\n\n\n@CommandHandler\n(\n\"SearchStackOverflow\"\n,\n \n\"Query Stack Overflow\"\n)\n\n\n@Tags\n(\n\"stack-overflow\"\n)\n\n\n@Intent\n(\n\"search SO\"\n)\n\n\nclass\n \nSearchStackOverflow\n \nimplements\n \nHandleCommand\n \n{\n\n\n    \n@Parameter\n({\n \ndescription\n:\n \n\"your search query\"\n,\n \npattern\n:\n \n\"^.*$\"\n \n})\n\n\n    \npublic\n \nquery\n: \nstring\n;\n\n\n\n    \npublic\n \nhandle\n(\nctx\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nconst\n \nplan\n \n=\n \nnew\n \nCommandPlan\n();\n\n\n        \nplan\n.\nadd\n({\n\n            \ninstruction\n:\n \n{\n\n                \nkind\n:\n \n\"execute\"\n,\n\n                \nname\n:\n \n\"http\"\n,\n\n                \nparameters\n:\n \n{\n\n                    \nmethod\n:\n \n\"get\"\n,\n\n                    \nurl\n: \nencodeURI\n(\napiSearchUrl\n \n+\n \nthis\n.\nquery\n),\n\n                \n},\n\n            \n},\n\n            \nonSuccess\n:\n \n{\n\n                \nkind\n:\n \n\"respond\"\n,\n\n                \nname\n:\n \n\"SendStackOverflowResults\"\n,\n\n                \nparameters\n: \nthis\n,\n\n            \n},\n\n        \n});\n\n        \nreturn\n \nplan\n;\n\n    \n}\n\n\n}\n\n\nexport\n \nconst\n \nsearchStackOverflow\n \n=\n \nnew\n \nSearchStackOverflow\n();\n\n\n\n@ResponseHandler\n(\n\"SendStackOverflowResults\"\n,\n\n    \n\"Shows answers to a query on Stack Overflow\"\n)\n\n\nclass\n \nStackOverflowResponder\n \nimplements\n \nHandleResponse\n<\nany\n>\n \n{\n\n\n    \n@Parameter\n({\n \ndescription\n:\n \n\"your search query\"\n,\n \npattern\n:\n \n\"^.*$\"\n \n})\n\n    \npublic\n \nquery\n: \nstring\n;\n\n\n    \npublic\n \nhandle\n(\n \n@ParseJson\n \nresponse\n: \nResponse\n<\nany\n>\n)\n:\n \nCommandPlan\n \n{\n\n        \nreturn\n \nCommandPlan\n.\nofMessage\n(\n\n            \nrenderResults\n(\nresponse\n.\nbody\n,\n \nencodeURI\n(\nthis\n.\nquery\n)),\n\n        \n);\n\n    \n}\n\n\n}\n\n\nexport\n \nlet\n \nresponder\n \n=\n \nnew\n \nStackOverflowResponder\n();\n\n\n\nfunction\n \nrenderResults\n(\nresult\n: \nany\n,\n \nquery\n: \nstring\n)\n:\n \nResponseMessage\n \n{\n\n\n    \nif\n \n(\nresult\n.\nitems\n.\nlength\n \n===\n \n0\n)\n \n{\n\n        \nreturn\n \nnew\n \nResponseMessage\n(\n\"No results found.\"\n,\n\n            \nMessageMimeTypes\n.\nPLAIN_TEXT\n);\n\n    \n}\n\n\n    \n// mark the last item for rendering purpose by mustache\n\n    \nresult\n.\nitems\n[\nresult\n.\nitems\n.\nlength\n \n-\n \n1\n].\nlast\n \n=\n \ntrue\n;\n\n    \nconst\n \nthumbUrl\n \n=\n \n\"https://slack-imgs.com/?c=1&o1=wi75.he75&url=https%3A%2F%2Fcdn.sstatic.net\"\n \n+\n\n        \n\"%2FSites%2Fstackoverflow%2Fimg%2Fapple-touch-icon%402.png%3Fv%3D73d79a89bded\"\n;\n\n\n    \nreturn\n \nnew\n \nResponseMessage\n(\nmustache\n.\nrender\n(\n`{\n\n\n  \"attachments\": [\n\n\n{{#answers.items}}\n\n\n    {\n\n\n      \"fallback\": \"{{{title}}}\",\n\n\n      \"author_name\": \"{{{owner.display_name}}}\",\n\n\n      \"author_link\": \"{{{owner.link}}}\",\n\n\n      \"author_icon\": \"{{{owner.profile_image}}}\",\n\n\n      \"title\": \"{{{title}}}\",\n\n\n      \"title_link\": \"{{{link}}}\",\n\n\n      \"thumb_url\": \"\n${\nthumbUrl\n}\n\",\n\n\n      \"footer\": \"{{#tags}}{{.}}  {{/tags}}\",\n\n\n      \"ts\": {{{last_activity_date}}}\n\n\n    }{{^last}},{{/last}}\n\n\n{{/answers.items}},\n\n\n        {\n\n\n            \"title\": \"See more >\",\n\n\n            \"title_link\": \"\n${\nwebSearchUrl\n \n+\n \nquery\n}\n\"\n\n\n        }\n\n\n  ]\n\n\n}`\n,\n\n        \n{\n \nanswers\n: \nresult\n \n}),\n \nMessageMimeTypes\n.\nSLACK_JSON\n);\n\n\n}\n\n\n\n\n\n\n\nThe \n@Intent\n specified in line 17, \nsearch SO\n, is the command that\nthe Atomist Bot will respond to by executing this \ncommand handler\n.\n\n\nThis command takes a single parameter called \nquery\n (line 21), which\nis the search term that will be passed to the StackOverflow\nAPI. Unless you provide a query parameter when calling this command,\nthe Atomist Bot will always prompt for it.\n\n\nLines 26\u201340 tell Atomist to call the StackOverflow REST API URL and,\non success, use the \nSendStackOverflowResults\n response handler,\ndefined starting on line 46. It simply formats the search results from\nthe StackOverflow API call.\n\n\n\n\nRug Command Handlers\n\n\nSee the \nRug command handler user-guide\n for more information.\n\n\n\n\nGet the Code Into Your Rug Project\n\u00b6\n\n\nAdd the code example above into a new file called \nSearchStackOverflow.ts\n in the\n\n.atomist/handlers/command\n directory of the local repo for your Rug project\nlike so:\n\n\n$\n \ncd\n atomist-tutorials\n\n$\n curl -o .atomist/handlers/command/SearchStackOverflow.ts \n\\\n\n    https://raw.githubusercontent.com/atomist/end-user-documentation/master/.atomist/handlers/command/SearchStackOverflow.ts\n\n\n\n\nYour command handler uses the \nhttp\n function, so you need to add that\ndependency as an extension into the \natomist\n section of your Rug\nproject\u2019s \npackage.json\n.\n\n\n{\n\n  \n\"name\"\n:\n \n\"@atomist-contrib/atomist-tutorials\"\n,\n\n  \n\"version\"\n:\n \n\"0.3.0\"\n,\n\n  \n...\n\n  \n\"atomist\"\n:\n \n{\n\n    \n\"requires\"\n:\n \n\"[1.0.0-m.4,2.0.0)\"\n,\n\n\n    \n\"extensions\"\n:\n \n{\n\n\n      \n\"com.atomist.rug:rug-function-http\"\n:\n \n\"[0.7.3,1.0.0)\"\n\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\nNow commit those changes to your Rug project.\n\n\n$\n \n(\n \ncd\n .atomist \n&&\n npm install \n)\n\n\n$\n git add .atomist/handlers/command/SearchStackOverflow.ts .atomist/package*.json\n\n$\n git commit -m \n'Added StackOverflow command handler'\n\n\n\n\n\nPublish\n\u00b6\n\n\nNow, publish your Rug project, which add your new Atomist Bot skill,\nusing the same team ID you determined in\nthe \nPublish a Rug Project\n tutorial.\n\n\n$\n rug publish -i <YOUR_TEAM_ID>\n\n\n\n\nMake it Active in Slack\n\u00b6\n\n\nIn \n#general\n or any channel in your Slack team that Atomist Bot has\nbeen invited to, type this message, replacing \n<group>\n and\n\n<artifact>\n with the values from the \nname\n property in your Rug\nproject\u2019s \n.atomist/package.json\n.  The scope of the name without the\nleading asterisk (\n@\n) is the \n<group>\n and the unqualified name is\nthe \n<artifact>\n.  The \nlatest\n at the end of the command ensure the\nAtomist Bot will always use the latest available version of your\narchive.\n\n\n@atomist add skills <group>:<artifact>:latest\n\n\n\n\nFor example, if the name in the \npackage.json\n file is\n\n@atomist-contrib/atomist-tutorials\n, then running the command would\nlook something like:\n\n\n\n  \n\n\n\n\n\nTell the Bot to load the new skills with this message:\n\n\n@atomist refresh skills\n\n\n\n\n\n  \n\n\n\n\n\nRunning the command in slack\n\u00b6\n\n\nOnce available in your team, you can use the new command:\n\n\n@atomist search SO\n\n\n\n\nUpon which the Atomist Bot will open a thread and ask you to enter a\nvalue for the query parameter.  Enter \u201cpython3 runtime error\u201d and\nsubmit.  The Atomist Bot will trigger the execution of your command\nhandler and return the results in the Slack channel.",
            "title": "Add Bot Command"
        },
        {
            "location": "/tutorials/add-bot-command/#search-stackoverflow-from-slack",
            "text": "In this example, you will teach the Atomist Bot to search\nStackOverflow and show you the first few results right in chat.  Here is the TypeScript code for a command that does this.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95 import   { \n     CommandHandler ,   Intent ,   Parameter ,   ParseJson , \n     ResponseHandler ,   Tags ,  }   from   \"@atomist/rug/operations/Decorators\" ;  import   { \n     CommandPlan ,   HandleCommand ,   HandlerContext ,   HandleResponse , \n     MessageMimeTypes ,   Response ,   ResponseMessage ,  }   from   \"@atomist/rug/operations/Handlers\" ;  import   *   as   mustache   from   \"mustache\" ;  const   apiSearchUrl   = \n     `http://api.stackexchange.com/2.2/search/advanced?pagesize=3&order=desc&sort=relevance&site=stackoverflow&q=` ;  const   webSearchUrl   =   `http://stackoverflow.com/search?order=desc&sort=relevance&q=` ;  @CommandHandler ( \"SearchStackOverflow\" ,   \"Query Stack Overflow\" )  @Tags ( \"stack-overflow\" )  @Intent ( \"search SO\" )  class   SearchStackOverflow   implements   HandleCommand   { \n\n     @Parameter ({   description :   \"your search query\" ,   pattern :   \"^.*$\"   })       public   query :  string ;  \n     public   handle ( ctx :  HandlerContext ) :   CommandPlan   { \n         const   plan   =   new   CommandPlan (); \n\n         plan . add ({ \n             instruction :   { \n                 kind :   \"execute\" , \n                 name :   \"http\" , \n                 parameters :   { \n                     method :   \"get\" , \n                     url :  encodeURI ( apiSearchUrl   +   this . query ), \n                 }, \n             }, \n             onSuccess :   { \n                 kind :   \"respond\" , \n                 name :   \"SendStackOverflowResults\" , \n                 parameters :  this , \n             }, \n         }); \n         return   plan ; \n     }  }  export   const   searchStackOverflow   =   new   SearchStackOverflow ();  @ResponseHandler ( \"SendStackOverflowResults\" , \n     \"Shows answers to a query on Stack Overflow\" )  class   StackOverflowResponder   implements   HandleResponse < any >   { \n\n     @Parameter ({   description :   \"your search query\" ,   pattern :   \"^.*$\"   }) \n     public   query :  string ; \n\n     public   handle (   @ParseJson   response :  Response < any > ) :   CommandPlan   { \n         return   CommandPlan . ofMessage ( \n             renderResults ( response . body ,   encodeURI ( this . query )), \n         ); \n     }  }  export   let   responder   =   new   StackOverflowResponder ();  function   renderResults ( result :  any ,   query :  string ) :   ResponseMessage   { \n\n     if   ( result . items . length   ===   0 )   { \n         return   new   ResponseMessage ( \"No results found.\" , \n             MessageMimeTypes . PLAIN_TEXT ); \n     } \n\n     // mark the last item for rendering purpose by mustache \n     result . items [ result . items . length   -   1 ]. last   =   true ; \n     const   thumbUrl   =   \"https://slack-imgs.com/?c=1&o1=wi75.he75&url=https%3A%2F%2Fcdn.sstatic.net\"   + \n         \"%2FSites%2Fstackoverflow%2Fimg%2Fapple-touch-icon%402.png%3Fv%3D73d79a89bded\" ; \n\n     return   new   ResponseMessage ( mustache . render ( `{    \"attachments\": [  {{#answers.items}}      {        \"fallback\": \"{{{title}}}\",        \"author_name\": \"{{{owner.display_name}}}\",        \"author_link\": \"{{{owner.link}}}\",        \"author_icon\": \"{{{owner.profile_image}}}\",        \"title\": \"{{{title}}}\",        \"title_link\": \"{{{link}}}\",        \"thumb_url\": \" ${ thumbUrl } \",        \"footer\": \"{{#tags}}{{.}}  {{/tags}}\",        \"ts\": {{{last_activity_date}}}      }{{^last}},{{/last}}  {{/answers.items}},          {              \"title\": \"See more >\",              \"title_link\": \" ${ webSearchUrl   +   query } \"          }    ]  }` , \n         {   answers :  result   }),   MessageMimeTypes . SLACK_JSON );  }    The  @Intent  specified in line 17,  search SO , is the command that\nthe Atomist Bot will respond to by executing this  command handler .  This command takes a single parameter called  query  (line 21), which\nis the search term that will be passed to the StackOverflow\nAPI. Unless you provide a query parameter when calling this command,\nthe Atomist Bot will always prompt for it.  Lines 26\u201340 tell Atomist to call the StackOverflow REST API URL and,\non success, use the  SendStackOverflowResults  response handler,\ndefined starting on line 46. It simply formats the search results from\nthe StackOverflow API call.   Rug Command Handlers  See the  Rug command handler user-guide  for more information.",
            "title": "Search StackOverflow from Slack"
        },
        {
            "location": "/tutorials/add-bot-command/#get-the-code-into-your-rug-project",
            "text": "Add the code example above into a new file called  SearchStackOverflow.ts  in the .atomist/handlers/command  directory of the local repo for your Rug project\nlike so:  $   cd  atomist-tutorials $  curl -o .atomist/handlers/command/SearchStackOverflow.ts  \\ \n    https://raw.githubusercontent.com/atomist/end-user-documentation/master/.atomist/handlers/command/SearchStackOverflow.ts  Your command handler uses the  http  function, so you need to add that\ndependency as an extension into the  atomist  section of your Rug\nproject\u2019s  package.json .  { \n   \"name\" :   \"@atomist-contrib/atomist-tutorials\" , \n   \"version\" :   \"0.3.0\" , \n   ... \n   \"atomist\" :   { \n     \"requires\" :   \"[1.0.0-m.4,2.0.0)\" ,       \"extensions\" :   {         \"com.atomist.rug:rug-function-http\" :   \"[0.7.3,1.0.0)\"       } \n   }  }   Now commit those changes to your Rug project.  $   (   cd  .atomist  &&  npm install  )  $  git add .atomist/handlers/command/SearchStackOverflow.ts .atomist/package*.json $  git commit -m  'Added StackOverflow command handler'",
            "title": "Get the Code Into Your Rug Project"
        },
        {
            "location": "/tutorials/add-bot-command/#publish",
            "text": "Now, publish your Rug project, which add your new Atomist Bot skill,\nusing the same team ID you determined in\nthe  Publish a Rug Project  tutorial.  $  rug publish -i <YOUR_TEAM_ID>",
            "title": "Publish"
        },
        {
            "location": "/tutorials/add-bot-command/#make-it-active-in-slack",
            "text": "In  #general  or any channel in your Slack team that Atomist Bot has\nbeen invited to, type this message, replacing  <group>  and <artifact>  with the values from the  name  property in your Rug\nproject\u2019s  .atomist/package.json .  The scope of the name without the\nleading asterisk ( @ ) is the  <group>  and the unqualified name is\nthe  <artifact> .  The  latest  at the end of the command ensure the\nAtomist Bot will always use the latest available version of your\narchive.  @atomist add skills <group>:<artifact>:latest  For example, if the name in the  package.json  file is @atomist-contrib/atomist-tutorials , then running the command would\nlook something like:  \n     Tell the Bot to load the new skills with this message:  @atomist refresh skills",
            "title": "Make it Active in Slack"
        },
        {
            "location": "/tutorials/add-bot-command/#running-the-command-in-slack",
            "text": "Once available in your team, you can use the new command:  @atomist search SO  Upon which the Atomist Bot will open a thread and ask you to enter a\nvalue for the query parameter.  Enter \u201cpython3 runtime error\u201d and\nsubmit.  The Atomist Bot will trigger the execution of your command\nhandler and return the results in the Slack channel.",
            "title": "Running the command in slack"
        },
        {
            "location": "/user-guide/",
            "text": "Welcome to the Atomist User Guide.  The Atomist User Guide contains\ndocumentation on all aspects of Atomist that its users, beginners\nthrough experts, can use to more effectively use Atomist to improve\ntheir processes and deliver value more quickly.\n\n\nIf you are not familiar with Atomist, you may want to start with\nthe \nAtomist Overview\n.  If you do not have Atomist set up\nin Slack, you may want to go through\nthe \nGetting Started\n guide.\n\n\nThe Atomist User Guide contains the following sections:\n\n\n\n\nRug\n: Atomist\u2019s enabling technology\n\n\nIntegrations\n: External platforms and tools that Atomist works with\n\n\nInterfaces\n: How users interact with Atomist\n\n\nSeeds\n: Projects that generate other projects\n\n\nFingerprints\n: How Atomist detects significant code changes\n\n\nPermissions\n: What permissions Atomist asks for\n\n\nSpring Agent\n: Installing and Using the \nSpring\n Agent\n\n\n\n\nClick on any of the links above to go directly to that section, or\nclick Next at the bottom right of this page to go to the next page in\nthe guide.",
            "title": "Introduction"
        },
        {
            "location": "/user-guide/rug/",
            "text": "Rug is the backbone of Atomist\u2019s features.  Atomist is about\nautomating away all the distractions from writing and operating great\nsoftware.  Rug provides the tools and infrastructure to make complete\nautomation a reality.  The model that underpins Rug helps you automate\ncommon tasks and react to changes in your development ecosystem.\n\n\nThe Rug ecosystem includes a programming model, runtime, test runner,\nand package manager.  The Rug programming model is expressed\nas \nTypeScript module\n interfaces and classes.  The Rug runtime\nruns as a service, accessible from any Slack that has invited the\nAtomist Bot (try it in \nAtomist Community Slack\n).  There\u2019s\nalso the \nRug CLI\n for local use, essential for Rug development.\n\n\nRug is a medium for code that modifies code.  Rug helps developers\nautomate development.  When a coding task is common, tedious,\nnit picky, or hard to remember how to do correctly, there is value in\nencoding how it\u2019s done, instead of performing the typing every time.\nNot only does the automation reduce mistakes, it serves as\ndocumentation for the process.\n\n\nAutomating your development tasks\n\u00b6\n\n\nIt is said that good developers are lazy and like to automate their\nwork.  However, the tools to drive that automation have been somewhat\nsparse and crude when we consider the sheer complexity of projects\nnowadays.\n\n\nTriggering an automated response\n\u00b6\n\n\nIn some cases, a response to a system event should be automated so the\nteam can focus on the things that require human attention.\n\n\nIn Rug, this is achieved through \nevent handlers\n.\n\n\nTriggering a human decision\n\u00b6\n\n\nAutomation is fantastic but humans are the sole judges.  Atomist gives\nyou the power to implement new skills that can be triggered by a team\nmember at when needed.\n\n\nIn Rug, this is achieved through \ncommand handlers\n.\n\n\nCreating new projects\n\u00b6\n\n\nIn a world of rapidly evolving software, creating new projects has\nbecome a task performed much more often than in the past. Meanwhile,\nthe complexity of projects has grown dramatically with configuration\nrequired for logging, CI, dependency management\u2026\n\n\nIt appears clear that automating the generation of projects is a prime\nfor any team willing to move fast but with repeatable quality.\n\n\nIn Rug, this is achieved through \ngenerators\n.\n\n\nEditing projects\n\u00b6\n\n\nAutomating the creation of projects is a great step forward but it\ncannot stop there. There are tasks that are repeated on a daily basis\nand doing them manually can be error prone, not to mention rather\nboring. Let\u2019s not forget that code quickly becomes legacy that nobody\nknows really about any longer.\n\n\nAutomating those changes is an asset for any developer who wishes to\nfocus on delivering great software without wasting time in mundane\ntasks.\n\n\nIn Rug, this is achieved through \neditors\n.\n\n\n\n\n\nExamples\n\u00b6\n\n\nWhat does using Rug in your team look like in practice?  Here are just\na few examples.\n\n\n\n\nHelping technical leads to guide development teams in best\n    practices on various technologies from initial project creation\n    through to the full lifecycle of a project\n\n\nSafely applying and evaluating new technologies to existing\n    projects\n\n\nHelping open source project owners to guide their users on how to\n    start out with, and continuously update and evolve, the software\n    based on their work.\n\n\nHelping to apply best-practice tools and techniques from the\n    microservices toolbox\n\n\n\n\nIn recent years, the DevOps trend has shown us that concerns about\nsoftware does not stop once it has been delivered.  Software exists\nthanks to those who designed and developed it but thrives thanks to\nthose who operate it.  At Atomist, we believe those two sides live in\nthe same world and more must be done to unite them.  Atomist brings\neverything together through \nevent-driven development\n.\n\n\nA common setup today is as follows:\n\n\n\n\nA project\u2019s source code lives in GitHub\n\n\nA project is automatically built and tested in a CI service\n\n\nA project is usually automatically delivered in a forge somewhere\n\n\nA project may even be deployed automatically in an environment\n\n\nA project is then operated, monitored, and cared for in that\n    environment for users to enjoy\n\n\nIssues are created\n\n\n\n\nDuring all those phases, a massive amount of events were triggered: a\ncommit was pushed, a build succeeded or failed, the project was\ndeployed, the service failed in production\u2026\n\n\nAtomist believes that all these events bring all the team members as\none.  However, not all events may not be able relevant to a team at a\ngiven time.  Moreover, it seems appropriate to think that we should\nalso automate the response to some of those events.  This is why the\nRug programming model has a holistic view of development and\noperation, allowing automation or user intervention at every step.",
            "title": "Introduction"
        },
        {
            "location": "/user-guide/rug/#automating-your-development-tasks",
            "text": "It is said that good developers are lazy and like to automate their\nwork.  However, the tools to drive that automation have been somewhat\nsparse and crude when we consider the sheer complexity of projects\nnowadays.",
            "title": "Automating your development tasks"
        },
        {
            "location": "/user-guide/rug/#triggering-an-automated-response",
            "text": "In some cases, a response to a system event should be automated so the\nteam can focus on the things that require human attention.  In Rug, this is achieved through  event handlers .",
            "title": "Triggering an automated response"
        },
        {
            "location": "/user-guide/rug/#triggering-a-human-decision",
            "text": "Automation is fantastic but humans are the sole judges.  Atomist gives\nyou the power to implement new skills that can be triggered by a team\nmember at when needed.  In Rug, this is achieved through  command handlers .",
            "title": "Triggering a human decision"
        },
        {
            "location": "/user-guide/rug/#creating-new-projects",
            "text": "In a world of rapidly evolving software, creating new projects has\nbecome a task performed much more often than in the past. Meanwhile,\nthe complexity of projects has grown dramatically with configuration\nrequired for logging, CI, dependency management\u2026  It appears clear that automating the generation of projects is a prime\nfor any team willing to move fast but with repeatable quality.  In Rug, this is achieved through  generators .",
            "title": "Creating new projects"
        },
        {
            "location": "/user-guide/rug/#editing-projects",
            "text": "Automating the creation of projects is a great step forward but it\ncannot stop there. There are tasks that are repeated on a daily basis\nand doing them manually can be error prone, not to mention rather\nboring. Let\u2019s not forget that code quickly becomes legacy that nobody\nknows really about any longer.  Automating those changes is an asset for any developer who wishes to\nfocus on delivering great software without wasting time in mundane\ntasks.  In Rug, this is achieved through  editors .",
            "title": "Editing projects"
        },
        {
            "location": "/user-guide/rug/#examples",
            "text": "What does using Rug in your team look like in practice?  Here are just\na few examples.   Helping technical leads to guide development teams in best\n    practices on various technologies from initial project creation\n    through to the full lifecycle of a project  Safely applying and evaluating new technologies to existing\n    projects  Helping open source project owners to guide their users on how to\n    start out with, and continuously update and evolve, the software\n    based on their work.  Helping to apply best-practice tools and techniques from the\n    microservices toolbox   In recent years, the DevOps trend has shown us that concerns about\nsoftware does not stop once it has been delivered.  Software exists\nthanks to those who designed and developed it but thrives thanks to\nthose who operate it.  At Atomist, we believe those two sides live in\nthe same world and more must be done to unite them.  Atomist brings\neverything together through  event-driven development .  A common setup today is as follows:   A project\u2019s source code lives in GitHub  A project is automatically built and tested in a CI service  A project is usually automatically delivered in a forge somewhere  A project may even be deployed automatically in an environment  A project is then operated, monitored, and cared for in that\n    environment for users to enjoy  Issues are created   During all those phases, a massive amount of events were triggered: a\ncommit was pushed, a build succeeded or failed, the project was\ndeployed, the service failed in production\u2026  Atomist believes that all these events bring all the team members as\none.  However, not all events may not be able relevant to a team at a\ngiven time.  Moreover, it seems appropriate to think that we should\nalso automate the response to some of those events.  This is why the\nRug programming model has a holistic view of development and\noperation, allowing automation or user intervention at every step.",
            "title": "Examples"
        },
        {
            "location": "/user-guide/rug/event-handlers/",
            "text": "Events are everywhere in software development and operations processes.\nYour source code repositories generate events. Your CI systems generate events.\nYour runtime platforms generate events. Your services generate events. Your issue\ntracking systems generate events. Everything seems to generate events.\n\n\nAtomist believes that bringing all these events together so they can be\nconnected and acted upon provides tremendous value for shipping better code\nfaster. The mechanism for realizing this promise is to automate event responses\nusing Rug event handlers.\n\n\nEvent handlers define automated responses to events. Each event handler is a\nprogram in a compiles-to-JavaScript, Turing-complete language. Based on the\ncharacteristics of the event that occurred, the handler decides whether to act and\nwhich actions to take.\n\n\n\n\nWhy not try\u2026\n\n\nA new issue was created? Post that in the repository\u2019s chat channel and also add\nbuttons to the message that let people apply labels or claim the issue without\nleaving chat.\n\n\nA developer submits a pull request in a library? Find out whether it will\nimpact a service that uses the library: create a branch in the service, modify\nthe code to update the dependency.\n\n\nThe service build completes successfully? Update the library\u2019s pull request\n(PR), and tell the developer all the news.\n\n\nA person in chat asks Atomist \u201cwhat did I do today?\u201d? Respond by\nlisting the issues they updated, the PRs they reviewed, and the commits they\npushed.\n\n\n\n\nAnatomy of an Event Handler\n\u00b6\n\n\nRug event handlers are where you define how Atomist responds to the events that\nmatter in your system.\n\n\nDepending on their goal, Event Handler implementations are stored either along\nside the project they target or in different projects altogether.\n\n\nBelow is the basic structure of any Rug project, except that our handlers live in\nthe \n.atomist/handlers\n directory:\n\n\n~/workspace/team-handlers\n\n\n    \u251c\u2500\u2500 .atomist\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 handlers\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 command\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 MergePR.ts\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 event\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 GitHubCommit.ts\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests\n\n\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json\n\n\n    \u251c\u2500\u2500 CHANGELOG.md\n\n\n    \u251c\u2500\u2500 .gitignore\n\n\n    \u251c\u2500\u2500 LICENSE\n\n\n    \u2514\u2500\u2500 README.md\n\n\n\n\n\nThe remaining files and directors of this Rug follows the usual\n\nRug project\n structure.\n\n\nExample Event Handler\n\u00b6\n\n\nThe following event handler responds to GitHub issue \nclosed\n events. When this\nevent occurs, the Atomist Bot sends a message to the repository\u2019s Slack channel\ninforming people in the channel about the closing \nevent\n, whilst also providing\na button, that when clicked, will reopen it.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nimport\n \n{\n \nEventHandler\n,\n \nTags\n \n}\n \nfrom\n \n\"@atomist/rug/operations/Decorators\"\n;\n\n\nimport\n \n{\n \nHandleEvent\n,\n \nLifecycleMessage\n,\n \nPlan\n \n}\n \nfrom\n \n\"@atomist/rug/operations/Handlers\"\n;\n\n\nimport\n \n{\n \nGraphNode\n,\n \nMatch\n,\n \nPathExpression\n \n}\n \nfrom\n \n\"@atomist/rug/tree/PathExpression\"\n;\n\n\n\nimport\n \n{\n \nComment\n \n}\n \nfrom\n \n\"@atomist/cortex/Comment\"\n;\n\n\nimport\n \n{\n \nIssue\n \n}\n \nfrom\n \n\"@atomist/cortex/Issue\"\n;\n\n\n\n@EventHandler\n(\n\"ClosedGitHubIssues\"\n,\n \n\"Handles closed issue events\"\n,\n\n    \nnew\n \nPathExpression\n<\nIssue\n,\n \nIssue\n>\n(\n\n        \n`/Issue()[@state='closed']\n\n\n            [/resolvingCommits::Commit()/author::GitHubId()\n\n\n                [/person::Person()/chatId::ChatId()]?]?\n\n\n            [/openedBy::GitHubId()\n\n\n                [/person::Person()/chatId::ChatId()]?]\n\n\n            [/closedBy::GitHubId()\n\n\n                [/person::Person()/chatId::ChatId()]?]?\n\n\n            [/repo::Repo()/channels::ChatChannel()]\n\n\n            [/labels::Label()]?`\n))\n\n\n@Tags\n(\n\"github\"\n,\n \n\"issue\"\n)\n\n\nclass\n \nClosedIssue\n \nimplements\n \nHandleEvent\n<\nIssue\n,\n \nIssue\n>\n \n{\n\n    \nhandle\n(\nevent\n: \nMatch\n<\nIssue\n,\n \nIssue\n>\n)\n:\n \nPlan\n \n{\n\n        \nconst\n \nissue\n \n=\n \nevent\n.\nroot\n();\n\n\n        \nconst\n \nlifecycleId\n \n=\n \n\"issue/\"\n \n+\n \nissue\n.\nrepo\n.\nowner\n \n+\n \n\"/\"\n \n+\n \nissue\n.\nrepo\n.\nname\n \n+\n \n\"/\"\n \n+\n \nissue\n.\nnumber\n;\n\n        \nconst\n \nmessage\n \n=\n \nnew\n \nLifecycleMessage\n(\nissue\n,\n \nlifecycleId\n);\n\n\n        \nmessage\n.\naddAction\n({\n\n            \nlabel\n:\n \n\"Reopen\"\n,\n\n            \ninstruction\n:\n \n{\n\n                \nkind\n:\n \n\"command\"\n,\n\n                \nname\n:\n \n\"ReopenGitHubIssue\"\n,\n\n                \nparameters\n:\n \n{\n\n                    \nissue\n: \nissue.number\n,\n\n                    \nowner\n: \nissue.repo.owner\n,\n\n                    \nrepo\n: \nissue.repo.name\n,\n\n                \n},\n\n            \n},\n\n        \n});\n\n\n        \nreturn\n \nPlan\n.\nofMessage\n(\nmessage\n);\n\n    \n}\n\n\n}\n\n\nexport\n \nconst\n \nclosedIssue\n \n=\n \nnew\n \nClosedIssue\n();\n\n\n\n\n\n\n\nThis event handler follows the same programming model as other Rugs, so it \nshould look familiar. It gets triggered for each GitHub repository \nCommit\n event\nin the team and responds by sending a \nLifecycle Message\n to the Atomist\nBot.\n\n\nDeclaration\n\u00b6\n\n\nDeclaring an event handler is done using the \n@EventHandler\n class\ndecorator which requires a name and a description. Additionally, it requires a \n\nPath Expression\n, which registers the types of events for which the handler\nshould be triggered.\n\n\nImplementation\n\u00b6\n\n\nRug event handlers must implemente the \nHandleEvent\n<\nR\n,\nM\n>\n interface, \nwhere the \nR\n and \nM\n type parameters refer to the expected root node and match\ntypes resulting from the execution of a \nPath Expression\n respectively.\n\n\nDiscovery\n\u00b6\n\n\nAll Rugs should be annotated with one or more \n@Tags\n \n\ndecorators\n to optimize their discoverability. For \nexample if you were to create an Rug that alters a README file\nthen the following \n@Tags\n would be applicable:\n\n\n@Tags\n(\n\"readme\"\n,\n \n\"documentation\"\n)\n\n\n\n\n\nTag values should consist of only lower case letters, numbers, and\ndashes (\n-\n).\n\n\nIf possible, try to include at least one of the tags on your Rug maps to an image\nfor a nicer rendering.  The following tags currently have images:\n\ndocker\n,\ngithub\n, \ntravis-ci\n, \napache\n, \ngit\n, \nspring-boot\n,\n\nspring\n, \nclojure\n, \ngo\n, \njava\n, \npython\n, \nscala\n, and\n\ndocumentation\n.\n\n\nEventPlans\n\u00b6\n\n\nAn \nEventPlan\n describes the actions to be taken by the Rug runtime\non behalf of the handler. EventPlans are composed of \nMessages\n and/or \n\nrespondables\n. Respondables instruct the rug runtime to automatically\nperform ordinary Rug operations, whereas messages are sent to chat by the Atomist\nBot.\n\n\nMessages\n\u00b6\n\n\nA \nMessage\n represents presentable content and/or deferable actions displayed\nto the user in response to returning an \nEventPlan\n from an event\nhandler. Every message will end up being sent to a chat channel or user by the\nAtomist bot. However, each of the two available message types achieve this in \ndifferent ways.\n\n\nDirected Messages\n\u00b6\n\n\nA Directed Message is sent directly to on or more users or channels. No\nautomatic routing is performed by the Atomist Bot. It\u2019s possible to\nadd Directed Messages to a Plan returned by any handler type.\n\n\nThe simplest use of a Response Message just echos back some plain text to\nthe user that invoked the command:\n\n\n    \nhandle\n(\ncommand\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nconst\n \nbob\n \n=\n \nnew\n \nUserAddress\n(\n\"@bob\"\n);\n\n        \nreturn\n \nCommandPlan\n.\nofMessage\n(\nnew\n \nDirectedMessage\n(\n\"Hello world!\"\n,\n \nbob\n));\n\n    \n}\n\n\n\n\n\nIt\u2019s possible to add more channels or usernames:\n\n\nhandle\n(\nresponse\n: \nResponse\n<\nany\n>\n)\n:\n \nCommandPlan\n \n{\n\n    \nconst\n \nbob\n \n=\n \nnew\n \nUserAddress\n(\n\"@bob\"\n);\n\n    \nlet\n \nmsg\n  \n=\n \nnew\n \nDirectedMessage\n(\n\"Hello everyone!\"\n,\n \nbob\n);\n\n    \nmsg\n.\naddAddress\n(\nnew\n \nChannelAddress\n(\n\"#general\"\n));\n\n    \nreturn\n \nCommandPlan\n.\nofMessage\n(\nmsg\n);\n\n\n}\n\n\n\n\n\nBy default, the body of the message is assumed to be \n\"text/plain\n, and will be\ndisplayed verbatim. The message can also be JSON formatted according to\n\nSlack\u2019s message standards\n:\n\n\n    \nhandle\n(\ncommand\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nconst\n \nuser\n \n=\n \nnew\n \nUserAddress\n(\n\"@bob\"\n);\n\n        \nconst\n \njson\n \n=\n \n{\n\n            \n\"text\"\n:\n \n\"I am a test message https://www.atomist.com\"\n,\n\n            \n\"attachments\"\n:\n \n[{\n\n               \n\"text\"\n:\n \n\"And here\u2019s an attachment!\"\n\n             \n}]\n\n        \n}\n\n        \nconst\n \nmsg\n \n=\n \nnew\n \nDirectedMessage\n(\nJSON\n.\nstringify\n(\njson\n),\n \nuser\n,\n \nMessageMimeTypes\n.\nSLACK_JSON\n);\n\n        \nreturn\n \nCommandPlan\n.\nofMessage\n(\nmsg\n);\n\n    \n}\n\n\n\n\n\nLifecycle Messages\n\u00b6\n\n\nAs implied by the name, a \nLifecycleMessage\n refers to some\npre-defined system lifecycle, such as the flow of a commit from Git,\nthrough CI to deployment, monitoring and the like.\n\n\nLifecycle messages are automatically routed to appropriate chat channel by\nthe Atomist Bot. Typically, this is the channel associated with the GitHub\nrepository associated with the activity initiating the lifecycle message.\n\n\nMessage styling is also currently performed by the Atomist Bot, though we are\nworking to allow customization in the handlers themselves.\n\n\nThe Atomist Bot needs two pieces of information in order to correctly route and\nrender a lifecycle message, a \nGraphNode\n and\na \nlifecycle-id\n. The GraphNode contains all the data required to render actionable\nmessages in chat, and the lifecycle-id ties associates related messages to\none-another. In a Slack context, this means a Commit message could have its\nassociated CI build status updated as the build progresses from say \nstarted\n\nthrough \nsucceeded\n or \nfailed\n.\n\n\nSo the main responsibility of lifecycle messages is to create associations between\nrelated messages using the lifecycle-id.\n\n\nMessages would not be actionable without some way for the user to initiate related\nacitivites. Lifecyce messages achieve this by allowing \nactions\n in the form of a\n\nPresentable\n to be added to the message before dispatch:\n\n\n \nmessage\n.\naddAction\n({\n\n            \nlabel\n:\n \n\"Reopen\"\n,\n\n            \ninstruction\n:\n \n{\n\n                \nkind\n:\n \n\"command\"\n,\n\n                \nname\n:\n \n\"ReopenGitHubIssue\"\n,\n\n                \nparameters\n:\n \n{\n\n                    \nissue\n: \nissue.number\n,\n\n                    \nowner\n: \nissue.repo.owner\n,\n\n                    \nrepo\n: \nissue.repo.name\n,\n\n                \n},\n\n            \n},\n\n        \n});\n\n\n\n\n\nHere we are saying: render a button with label \nReopen\n, which when clicked, will\ndispatch a \nCommand Handler\n (\n\"command\"\n)\ncalled \nReopenGithubIssue\n, which will execute a \nRug Function\n\nwhich attempt to re-open the issue.\n\n\nThe term \naction\n here refers to the actions associated with \nSlack buttons\n.\nSo by adding actions to a message, we are dispatching optional deferred Rug\nexecutions. In this instance a Command Handler bound to a specific GitHub issue,\nbut it could just as easily have been an \neditor\n or \ngenerator\n.\n\n\nRespondables\n\u00b6\n\n\nAn \nEventRespondable\n is really just a container for an instruction and\nsome optional \nonError\n and \nonSuccess\n capabilities. The \nonError\n and \nonSuccess\n\nproperties of an \nEventRespondable\n can be \nmessages\n, \n\nEventPlans\n or \nresponse handlers\n.\n\n\nconst\n \nplan\n \n=\n \nnew\n \nEventPlan\n();\n\n\nplan\n.\nadd\n(\n\n    \n{\n\n        \ninstruction\n:\n \n{\n\n            \nkind\n:\n \n\"edit\"\n,\n\n            \nproject\n:\n \n\"rugs\"\n,\n\n            \nname\n:\n \n\"UpdateReadme\"\n,\n\n            \nparameters\n:\n \n{\n\n                \nnewContent\n:\n \n\"Rugs really tie the room together\"\n\n            \n}\n\n        \n},\n\n        \nonSuccess\n: \nnew\n \nDirectedMessage\n(\n\"woot\"\n,\n \nnew\n \nChannelAddress\n(\n\"#random\"\n)),\n\n        \nonError\n:\n \n{\n\n            \nkind\n:\n \n\"respond\"\n,\n\n            \nname\n:\n \n\"HandleReadmeUpdateErrors\"\n\n        \n}\n\n    \n}\n\n\n)\n\n\n\n\n\nThe example above shows how to send \nwoot\n to the \n#random\n channel using a\n\nDirected Message\n if the \nedit\n Instruction completes successfully,\nand invoke the \nHandleReadmeUpdateErros\n \nResponse Handler\n\nif it fails.\n\n\nInstructions\n\u00b6\n\n\nInstructions in an \nEventRespondable\n have the following properties:\n\n\n\n\nkind\n:\n \n\"generate\"\n \n|\n \n\"edit\"\n \n|\n \n\"execute\"\n: the kind of instruction \n\n\nname\n: \nstring\n: the name of the operation to apply\n\n\nparameters\n:\n \n{}\n: key/value pairs passed to the operation\n\n\nproject?\n: \nstring\n: Project name (only for generators & editors)\n\n\n\n\nInstructions can be used to have the rug runtime run Rugs, such as invoking\na generator (\n\"generate\"\n), an editor (\n\"edit\"\n), or\na \nRug Funtion\n (\n\"execute\"\n).\n\n\nRug Functions\n\u00b6\n\n\nRug Functions, as indicated by their name, are functions that can be invoked\nfrom within Event or Command Handlers. They can be scheduled for invocation by\nadding an instruction of kind \nexecute\n to a plan:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nplan\n.\nadd\n(\n\n    \n{\n\n        \ninstruction\n:\n \n{\n\n            \nkind\n:\n \n\"execute\"\n,\n\n            \nname\n:\n \n\"http\"\n,\n\n            \nparameters\n:\n \n{\n\n                \nurl\n:\n \n\"https://api.github.com/repos/atomist/rug\"\n,\n\n                \nmethod\n:\n \n\"post\"\n,\n\n                \nconfig\n:\n \n{\n\n                    \nheaders\n:\n \n{\n\n                        \n\"Content-Type\"\n:\n \n\"application/json\"\n,\n\n                        \n\"Authorization\"\n:\n \n`token #{github://user_token?scopes=repo}`\n,\n\n                    \n},\n\n                    \nbody\n: \nJSON.stringify\n(\ncreateRepoRequest\n)\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \nonSuccess\n: \nnew\n \nDirectMessage\n(\n\"Woot!\"\n,\n \nnew\n \nChannelAddress\n(\n\"#random\"\n)),\n\n        \nonError\n: \nnew\n \nDirectMessage\n(\n\"Un oh\"\n,\n \nnew\n \nChannelAddress\n(\n\"#random\"\n))\n\n    \n}\n\n\n)\n\n\n\n\n\n\n\nThe plan above instructs the Rug Runtime to invoke the \nhttp\n Rug Function,\npassing all the \nparameters\n to it, and sending appropriate messages to the\n\n#random\n channel \nonSuccess\n or \nonError\n.\n\n\nTo use a Rug Function from an Event or Command Handler, its archive\u2019s\ncoordinates must be present in the \n.atomist.extensions\n section of\nthe Rug project\u2019s \npackage.json\n.\n\n\n\n\nSecurity\n\n\nAll Rug Function archives must be signed by Atomist and be explicitly\nwhitelisted in the Atomist service. Otherwise, the execution of the invoking\nhandler will be aborted.\n\n\n\n\nSecrets\n can also be passed to Rug Functions, but currently this is only supported\nfor Command Handlers.\n\n\nThe special \n#{<secret path>}\n notation used above is a way of injecting the value\nof a secret (in this case, a GitHub token with \nrepo\n scope) in to the parameters\nto a function via string filtering. Rug Functions can also be \nannotated\n\nso that if the secrets required are known in advance, we don\u2019t need to use paramter\nfiltering.\n\n\nThe following Rug Function archives available:\n\n\n\n\nrug-function-http\n - perform arbitrary HTTP requests\n\n\nrug-functions-travis\n - encrypt secrets, start/stop builds\n\n\nrug-functions-aws\n - perform s3 operations and so on\n\n\n\n\n\n\nCreating your own Rug functions\n\n\nRight now there is no support for user-created Rug functions. Please get in\ntouch by joining our \nSlack team\n if you need one\nthat doesn\u2019t already exist.\n\n\n\n\nSecrets\n\u00b6\n\n\nSecrets are pieces of sensitive information stored securely by Atomist. Secrets\nare used by \nRug Functions\n to provide access\nto secured systems, such as the GitHub API.\n\n\nHandlers that invoke Rug Functions that require secrets must use the\n\n@Secrets\n decorator to declare to the Rug runtime that those\nsecrets will be required during the execution of the handler\u2019s CommandPlan:\n\n\n...\n\n\n@Secrets\n(\n\"github://user_token?scopes=repo,read:org\"\n)\n\n\nclass\n \nCloseIssueCommand\n \nimplements\n \nHandleCommand\n \n{\n\n    \n//...\n\n\n}\n\n\n\n\n\nThe \n@Secrets\n decorator takes a comma separate list of secret\npaths. The decorator provides enough context to the Atomist Bot such that it\ncan initiate the secure collection of the require secret data, such as a GitHub\ntoken collected via OAuth flow.\n\n\n\n\nConfidentiality\n\n\nAll sensitive data stored by Atomist are encrypted at rest in\n\nVault\n.\n\n\n\n\nThere are currently two types of secrets:\n\n\n\n\nGitHub tokens: automatically collected by the Atomist Bot\n\n\n\"github://user_token?scopes=repo\"\n - \nrepo\n scoped user token\n\n\n\"github://team_token?scopes=repo\"\n - \nrepo\n scoped\nteam token Both user and team GitHub tokens require the scopes\nneeded by the \ntoken\n to be provided as a comma-separated list.\n\n\n\n\n\n\nGeneric Secrets: manual collection\n\n\n\"secret://user?path=/some/secret\"\n - generic user secret\n\n\n\"secret://team?path=/some/secret\"\n - generic team secret\n\n\n\n\n\n\n\n\n\n\nGeneric Secrets\n\n\nThese are currently only available for very specific and mostly internal use\ncases as we currently have no secure public mechanism for collecting and storing\nthem, though this is something we are hoping to support in the near future. They\nare mentioned here to avoid any confusion when seen in publically visible Handlers.\n\n\n\n\n\n\nMissing\n\n\nAlthough it\u2019s possible to invoke Rug Functions from Event Handlers, there is\ncurrently no mechanism to populate Secrets (tokens, passwords etc.) as there\nis for Command Handlers. We are currently working on support for this.\n\n\n\n\nResponse Handlers\n\u00b6\n\n\nA \nRespond\n object (declared using \n{\nkind\n:\n \n\"respond\"\n}\n)\nindicates the desire to handle the response to an Instruction using a\n\nResponseHandler\n object.\n\n\nimport\n \n{\n\n    \nParameter\n,\n \nParseJson\n,\n \nResponseHandler\n,\n \nTags\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Decorators\"\n;\n\n\n\nimport\n \n{\n\n    \nChannelAddress\n,\n \nDirectedMessage\n,\n \nEventPlan\n,\n \nHandlerContext\n,\n\n    \nHandleResponse\n,\n \nResponse\n,\n \nResponseMessage\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Handlers\"\n;\n\n\n\n@ResponseHandler\n(\n\"GenericSuccessHandler\"\n,\n \n\"displays a success message in chat\"\n)\n\n\n@Tags\n(\n\"success\"\n)\n\n\nclass\n \nGenericSuccessHandler\n \nimplements\n \nHandleResponse\n<\nany\n>\n \n{\n\n\n    \n@Parameter\n({\n \ndescription\n:\n \n\"Success msg\"\n,\n \npattern\n:\n \n\"@any\"\n \n})\n\n    \npublic\n \nmsg\n: \nstring\n;\n\n\n    \npublic\n \nhandle\n(\n \n@ParseJson\n \nresponse\n: \nResponse\n<\nany\n>\n)\n:\n \nEventPlan\n \n{\n\n        \nconst\n \nrand\n \n=\n \nnew\n \nChannelAddress\n(\n\"#random\"\n);\n\n        \nconst\n \nresult\n \n=\n \n`\n${\nthis\n.\nmsg\n}\n: \n${\nresponse\n.\nbody\n.\nstatus\n}\n`\n;\n\n        \nreturn\n \nnew\n \nEventPlan\n().\nadd\n(\nnew\n \nDirectedMessage\n(\nresult\n,\n \nrand\n));\n\n    \n}\n\n\n}\n\n\n\n\n\nResponse handlers are declared with the \nResponseHandler\n decorator\nand the class must implement the\n\nhandle\n(\nresponse\n: \nResponse\n<\nT\n>\n)\n:\n \nEventPlan\n \n|\n \nCommandPlan\n method of the\n\nHandleResponse\n<\nT\n>\n interface. When the handler receives a JSON\npayload, you can benefit from automatic JSON deserialization into an object by\ndecorating the response parameter with the \n@ParseJson\n decorator,\nfor example \nhandle\n(\n@ParseJson\n \nresponse\n: \nResponse\n<\nT\n>\n)\n:\n \nCommandPlan\n.\n\n\nResponse Handlers must also return a plan, just like any handler. However, they\nmust return the appropriate type of plan for the execution chain in which they\nrespond. So for an \nEvent Handler\n they must\nreturn an \nEventPlan\n, and for a \nCommand Handler\n\nthey must return a \nCommandPlan\n.\n\n\n\n\nIt\u2019s all asynchronous\n\n\nIt is important to appreciate that because handlers return plans,\nthe actions declared in that plan are executed asynchronously. In other\nwords, plans are just data the Rug runtime knows how to interpret but your\nhandler cannot invoke those Rugs directly. So it\u2019s not safe to make\nassumptions about when instructions in a plan will be run, although\nit is fair to say that the Atomist platform will do its best to apply them\nas soon as possible.",
            "title": "Event Handlers"
        },
        {
            "location": "/user-guide/rug/event-handlers/#anatomy-of-an-event-handler",
            "text": "Rug event handlers are where you define how Atomist responds to the events that\nmatter in your system.  Depending on their goal, Event Handler implementations are stored either along\nside the project they target or in different projects altogether.  Below is the basic structure of any Rug project, except that our handlers live in\nthe  .atomist/handlers  directory:  ~/workspace/team-handlers      \u251c\u2500\u2500 .atomist      \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore      \u2502\u00a0\u00a0 \u251c\u2500\u2500 handlers      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 command      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 MergePR.ts      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 event      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 GitHubCommit.ts      \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json      \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests      \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json      \u251c\u2500\u2500 CHANGELOG.md      \u251c\u2500\u2500 .gitignore      \u251c\u2500\u2500 LICENSE      \u2514\u2500\u2500 README.md   The remaining files and directors of this Rug follows the usual Rug project  structure.",
            "title": "Anatomy of an Event Handler"
        },
        {
            "location": "/user-guide/rug/event-handlers/#example-event-handler",
            "text": "The following event handler responds to GitHub issue  closed  events. When this\nevent occurs, the Atomist Bot sends a message to the repository\u2019s Slack channel\ninforming people in the channel about the closing  event , whilst also providing\na button, that when clicked, will reopen it.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 import   {   EventHandler ,   Tags   }   from   \"@atomist/rug/operations/Decorators\" ;  import   {   HandleEvent ,   LifecycleMessage ,   Plan   }   from   \"@atomist/rug/operations/Handlers\" ;  import   {   GraphNode ,   Match ,   PathExpression   }   from   \"@atomist/rug/tree/PathExpression\" ;  import   {   Comment   }   from   \"@atomist/cortex/Comment\" ;  import   {   Issue   }   from   \"@atomist/cortex/Issue\" ;  @EventHandler ( \"ClosedGitHubIssues\" ,   \"Handles closed issue events\" , \n     new   PathExpression < Issue ,   Issue > ( \n         `/Issue()[@state='closed']              [/resolvingCommits::Commit()/author::GitHubId()                  [/person::Person()/chatId::ChatId()]?]?              [/openedBy::GitHubId()                  [/person::Person()/chatId::ChatId()]?]              [/closedBy::GitHubId()                  [/person::Person()/chatId::ChatId()]?]?              [/repo::Repo()/channels::ChatChannel()]              [/labels::Label()]?` ))  @Tags ( \"github\" ,   \"issue\" )  class   ClosedIssue   implements   HandleEvent < Issue ,   Issue >   { \n     handle ( event :  Match < Issue ,   Issue > ) :   Plan   { \n         const   issue   =   event . root (); \n\n         const   lifecycleId   =   \"issue/\"   +   issue . repo . owner   +   \"/\"   +   issue . repo . name   +   \"/\"   +   issue . number ; \n         const   message   =   new   LifecycleMessage ( issue ,   lifecycleId ); \n\n         message . addAction ({ \n             label :   \"Reopen\" , \n             instruction :   { \n                 kind :   \"command\" , \n                 name :   \"ReopenGitHubIssue\" , \n                 parameters :   { \n                     issue :  issue.number , \n                     owner :  issue.repo.owner , \n                     repo :  issue.repo.name , \n                 }, \n             }, \n         }); \n\n         return   Plan . ofMessage ( message ); \n     }  }  export   const   closedIssue   =   new   ClosedIssue ();    This event handler follows the same programming model as other Rugs, so it \nshould look familiar. It gets triggered for each GitHub repository  Commit  event\nin the team and responds by sending a  Lifecycle Message  to the Atomist\nBot.",
            "title": "Example Event Handler"
        },
        {
            "location": "/user-guide/rug/event-handlers/#declaration",
            "text": "Declaring an event handler is done using the  @EventHandler  class\ndecorator which requires a name and a description. Additionally, it requires a  Path Expression , which registers the types of events for which the handler\nshould be triggered.",
            "title": "Declaration"
        },
        {
            "location": "/user-guide/rug/event-handlers/#implementation",
            "text": "Rug event handlers must implemente the  HandleEvent < R , M >  interface, \nwhere the  R  and  M  type parameters refer to the expected root node and match\ntypes resulting from the execution of a  Path Expression  respectively.",
            "title": "Implementation"
        },
        {
            "location": "/user-guide/rug/event-handlers/#discovery",
            "text": "All Rugs should be annotated with one or more  @Tags   decorators  to optimize their discoverability. For \nexample if you were to create an Rug that alters a README file\nthen the following  @Tags  would be applicable:  @Tags ( \"readme\" ,   \"documentation\" )   Tag values should consist of only lower case letters, numbers, and\ndashes ( - ).  If possible, try to include at least one of the tags on your Rug maps to an image\nfor a nicer rendering.  The following tags currently have images: docker , github ,  travis-ci ,  apache ,  git ,  spring-boot , spring ,  clojure ,  go ,  java ,  python ,  scala , and documentation .",
            "title": "Discovery"
        },
        {
            "location": "/user-guide/rug/event-handlers/#eventplans",
            "text": "An  EventPlan  describes the actions to be taken by the Rug runtime\non behalf of the handler. EventPlans are composed of  Messages  and/or  respondables . Respondables instruct the rug runtime to automatically\nperform ordinary Rug operations, whereas messages are sent to chat by the Atomist\nBot.",
            "title": "EventPlans"
        },
        {
            "location": "/user-guide/rug/event-handlers/#messages",
            "text": "A  Message  represents presentable content and/or deferable actions displayed\nto the user in response to returning an  EventPlan  from an event\nhandler. Every message will end up being sent to a chat channel or user by the\nAtomist bot. However, each of the two available message types achieve this in \ndifferent ways.",
            "title": "Messages"
        },
        {
            "location": "/user-guide/rug/event-handlers/#directed-messages",
            "text": "A Directed Message is sent directly to on or more users or channels. No\nautomatic routing is performed by the Atomist Bot. It\u2019s possible to\nadd Directed Messages to a Plan returned by any handler type.  The simplest use of a Response Message just echos back some plain text to\nthe user that invoked the command:       handle ( command :  HandlerContext ) :   CommandPlan   { \n         const   bob   =   new   UserAddress ( \"@bob\" ); \n         return   CommandPlan . ofMessage ( new   DirectedMessage ( \"Hello world!\" ,   bob )); \n     }   It\u2019s possible to add more channels or usernames:  handle ( response :  Response < any > ) :   CommandPlan   { \n     const   bob   =   new   UserAddress ( \"@bob\" ); \n     let   msg    =   new   DirectedMessage ( \"Hello everyone!\" ,   bob ); \n     msg . addAddress ( new   ChannelAddress ( \"#general\" )); \n     return   CommandPlan . ofMessage ( msg );  }   By default, the body of the message is assumed to be  \"text/plain , and will be\ndisplayed verbatim. The message can also be JSON formatted according to Slack\u2019s message standards :       handle ( command :  HandlerContext ) :   CommandPlan   { \n         const   user   =   new   UserAddress ( \"@bob\" ); \n         const   json   =   { \n             \"text\" :   \"I am a test message https://www.atomist.com\" , \n             \"attachments\" :   [{ \n                \"text\" :   \"And here\u2019s an attachment!\" \n              }] \n         } \n         const   msg   =   new   DirectedMessage ( JSON . stringify ( json ),   user ,   MessageMimeTypes . SLACK_JSON ); \n         return   CommandPlan . ofMessage ( msg ); \n     }",
            "title": "Directed Messages"
        },
        {
            "location": "/user-guide/rug/event-handlers/#lifecycle-messages",
            "text": "As implied by the name, a  LifecycleMessage  refers to some\npre-defined system lifecycle, such as the flow of a commit from Git,\nthrough CI to deployment, monitoring and the like.  Lifecycle messages are automatically routed to appropriate chat channel by\nthe Atomist Bot. Typically, this is the channel associated with the GitHub\nrepository associated with the activity initiating the lifecycle message.  Message styling is also currently performed by the Atomist Bot, though we are\nworking to allow customization in the handlers themselves.  The Atomist Bot needs two pieces of information in order to correctly route and\nrender a lifecycle message, a  GraphNode  and\na  lifecycle-id . The GraphNode contains all the data required to render actionable\nmessages in chat, and the lifecycle-id ties associates related messages to\none-another. In a Slack context, this means a Commit message could have its\nassociated CI build status updated as the build progresses from say  started \nthrough  succeeded  or  failed .  So the main responsibility of lifecycle messages is to create associations between\nrelated messages using the lifecycle-id.  Messages would not be actionable without some way for the user to initiate related\nacitivites. Lifecyce messages achieve this by allowing  actions  in the form of a Presentable  to be added to the message before dispatch:    message . addAction ({ \n             label :   \"Reopen\" , \n             instruction :   { \n                 kind :   \"command\" , \n                 name :   \"ReopenGitHubIssue\" , \n                 parameters :   { \n                     issue :  issue.number , \n                     owner :  issue.repo.owner , \n                     repo :  issue.repo.name , \n                 }, \n             }, \n         });   Here we are saying: render a button with label  Reopen , which when clicked, will\ndispatch a  Command Handler  ( \"command\" )\ncalled  ReopenGithubIssue , which will execute a  Rug Function \nwhich attempt to re-open the issue.  The term  action  here refers to the actions associated with  Slack buttons .\nSo by adding actions to a message, we are dispatching optional deferred Rug\nexecutions. In this instance a Command Handler bound to a specific GitHub issue,\nbut it could just as easily have been an  editor  or  generator .",
            "title": "Lifecycle Messages"
        },
        {
            "location": "/user-guide/rug/event-handlers/#respondables",
            "text": "An  EventRespondable  is really just a container for an instruction and\nsome optional  onError  and  onSuccess  capabilities. The  onError  and  onSuccess \nproperties of an  EventRespondable  can be  messages ,  EventPlans  or  response handlers .  const   plan   =   new   EventPlan ();  plan . add ( \n     { \n         instruction :   { \n             kind :   \"edit\" , \n             project :   \"rugs\" , \n             name :   \"UpdateReadme\" , \n             parameters :   { \n                 newContent :   \"Rugs really tie the room together\" \n             } \n         }, \n         onSuccess :  new   DirectedMessage ( \"woot\" ,   new   ChannelAddress ( \"#random\" )), \n         onError :   { \n             kind :   \"respond\" , \n             name :   \"HandleReadmeUpdateErrors\" \n         } \n     }  )   The example above shows how to send  woot  to the  #random  channel using a Directed Message  if the  edit  Instruction completes successfully,\nand invoke the  HandleReadmeUpdateErros   Response Handler \nif it fails.",
            "title": "Respondables"
        },
        {
            "location": "/user-guide/rug/event-handlers/#instructions",
            "text": "Instructions in an  EventRespondable  have the following properties:   kind :   \"generate\"   |   \"edit\"   |   \"execute\" : the kind of instruction   name :  string : the name of the operation to apply  parameters :   {} : key/value pairs passed to the operation  project? :  string : Project name (only for generators & editors)   Instructions can be used to have the rug runtime run Rugs, such as invoking\na generator ( \"generate\" ), an editor ( \"edit\" ), or\na  Rug Funtion  ( \"execute\" ).",
            "title": "Instructions"
        },
        {
            "location": "/user-guide/rug/event-handlers/#rug-functions",
            "text": "Rug Functions, as indicated by their name, are functions that can be invoked\nfrom within Event or Command Handlers. They can be scheduled for invocation by\nadding an instruction of kind  execute  to a plan:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 plan . add ( \n     { \n         instruction :   { \n             kind :   \"execute\" , \n             name :   \"http\" , \n             parameters :   { \n                 url :   \"https://api.github.com/repos/atomist/rug\" , \n                 method :   \"post\" , \n                 config :   { \n                     headers :   { \n                         \"Content-Type\" :   \"application/json\" , \n                         \"Authorization\" :   `token #{github://user_token?scopes=repo}` , \n                     }, \n                     body :  JSON.stringify ( createRepoRequest ) \n                 } \n             } \n         }, \n         onSuccess :  new   DirectMessage ( \"Woot!\" ,   new   ChannelAddress ( \"#random\" )), \n         onError :  new   DirectMessage ( \"Un oh\" ,   new   ChannelAddress ( \"#random\" )) \n     }  )    The plan above instructs the Rug Runtime to invoke the  http  Rug Function,\npassing all the  parameters  to it, and sending appropriate messages to the #random  channel  onSuccess  or  onError .  To use a Rug Function from an Event or Command Handler, its archive\u2019s\ncoordinates must be present in the  .atomist.extensions  section of\nthe Rug project\u2019s  package.json .   Security  All Rug Function archives must be signed by Atomist and be explicitly\nwhitelisted in the Atomist service. Otherwise, the execution of the invoking\nhandler will be aborted.   Secrets  can also be passed to Rug Functions, but currently this is only supported\nfor Command Handlers.  The special  #{<secret path>}  notation used above is a way of injecting the value\nof a secret (in this case, a GitHub token with  repo  scope) in to the parameters\nto a function via string filtering. Rug Functions can also be  annotated \nso that if the secrets required are known in advance, we don\u2019t need to use paramter\nfiltering.  The following Rug Function archives available:   rug-function-http  - perform arbitrary HTTP requests  rug-functions-travis  - encrypt secrets, start/stop builds  rug-functions-aws  - perform s3 operations and so on    Creating your own Rug functions  Right now there is no support for user-created Rug functions. Please get in\ntouch by joining our  Slack team  if you need one\nthat doesn\u2019t already exist.",
            "title": "Rug Functions"
        },
        {
            "location": "/user-guide/rug/event-handlers/#secrets",
            "text": "Secrets are pieces of sensitive information stored securely by Atomist. Secrets\nare used by  Rug Functions  to provide access\nto secured systems, such as the GitHub API.  Handlers that invoke Rug Functions that require secrets must use the @Secrets  decorator to declare to the Rug runtime that those\nsecrets will be required during the execution of the handler\u2019s CommandPlan:  ...  @Secrets ( \"github://user_token?scopes=repo,read:org\" )  class   CloseIssueCommand   implements   HandleCommand   { \n     //...  }   The  @Secrets  decorator takes a comma separate list of secret\npaths. The decorator provides enough context to the Atomist Bot such that it\ncan initiate the secure collection of the require secret data, such as a GitHub\ntoken collected via OAuth flow.   Confidentiality  All sensitive data stored by Atomist are encrypted at rest in Vault .   There are currently two types of secrets:   GitHub tokens: automatically collected by the Atomist Bot  \"github://user_token?scopes=repo\"  -  repo  scoped user token  \"github://team_token?scopes=repo\"  -  repo  scoped\nteam token Both user and team GitHub tokens require the scopes\nneeded by the  token  to be provided as a comma-separated list.    Generic Secrets: manual collection  \"secret://user?path=/some/secret\"  - generic user secret  \"secret://team?path=/some/secret\"  - generic team secret      Generic Secrets  These are currently only available for very specific and mostly internal use\ncases as we currently have no secure public mechanism for collecting and storing\nthem, though this is something we are hoping to support in the near future. They\nare mentioned here to avoid any confusion when seen in publically visible Handlers.    Missing  Although it\u2019s possible to invoke Rug Functions from Event Handlers, there is\ncurrently no mechanism to populate Secrets (tokens, passwords etc.) as there\nis for Command Handlers. We are currently working on support for this.",
            "title": "Secrets"
        },
        {
            "location": "/user-guide/rug/event-handlers/#response-handlers",
            "text": "A  Respond  object (declared using  { kind :   \"respond\" } )\nindicates the desire to handle the response to an Instruction using a ResponseHandler  object.  import   { \n     Parameter ,   ParseJson ,   ResponseHandler ,   Tags ,  }   from   \"@atomist/rug/operations/Decorators\" ;  import   { \n     ChannelAddress ,   DirectedMessage ,   EventPlan ,   HandlerContext , \n     HandleResponse ,   Response ,   ResponseMessage ,  }   from   \"@atomist/rug/operations/Handlers\" ;  @ResponseHandler ( \"GenericSuccessHandler\" ,   \"displays a success message in chat\" )  @Tags ( \"success\" )  class   GenericSuccessHandler   implements   HandleResponse < any >   { \n\n     @Parameter ({   description :   \"Success msg\" ,   pattern :   \"@any\"   }) \n     public   msg :  string ; \n\n     public   handle (   @ParseJson   response :  Response < any > ) :   EventPlan   { \n         const   rand   =   new   ChannelAddress ( \"#random\" ); \n         const   result   =   ` ${ this . msg } :  ${ response . body . status } ` ; \n         return   new   EventPlan (). add ( new   DirectedMessage ( result ,   rand )); \n     }  }   Response handlers are declared with the  ResponseHandler  decorator\nand the class must implement the handle ( response :  Response < T > ) :   EventPlan   |   CommandPlan  method of the HandleResponse < T >  interface. When the handler receives a JSON\npayload, you can benefit from automatic JSON deserialization into an object by\ndecorating the response parameter with the  @ParseJson  decorator,\nfor example  handle ( @ParseJson   response :  Response < T > ) :   CommandPlan .  Response Handlers must also return a plan, just like any handler. However, they\nmust return the appropriate type of plan for the execution chain in which they\nrespond. So for an  Event Handler  they must\nreturn an  EventPlan , and for a  Command Handler \nthey must return a  CommandPlan .   It\u2019s all asynchronous  It is important to appreciate that because handlers return plans,\nthe actions declared in that plan are executed asynchronously. In other\nwords, plans are just data the Rug runtime knows how to interpret but your\nhandler cannot invoke those Rugs directly. So it\u2019s not safe to make\nassumptions about when instructions in a plan will be run, although\nit is fair to say that the Atomist platform will do its best to apply them\nas soon as possible.",
            "title": "Response Handlers"
        },
        {
            "location": "/user-guide/rug/command-handlers/",
            "text": "Lowering the barrier for communication and information flow makes\nteams more productive. Open Source projects have long relied on chat\nto help them operate and coordinate contributors and project lifecycle.\nModern chat solutions such as Slack, which can integrate deeply in your ecosystem,\nhave improved on those foundations and have proven to be fantastic hubs for teams\nto drive automation with simple chat commands.\n\n\nCommon scenarios, for instance cutting a new release, or rolling back a broken\ndeployment. Additionally, like other Rugs,  command handlers can also dive into\nthe code of project as a result of a bot interaction. In other words, not only\ncan you use Rug commands to list open issues on a project but the team can also\nquery the project\u2019s code or even run other Rugs against the project, all of this\nfrom the project\u2019s chat channel.\n\n\nAnatomy of a Command Handler\n\u00b6\n\n\nRug commands handlers are the interface to add new skills to the \nAtomist bot\n.\nThese handlers are appropriate when you want to either query your project\nor perform an action where your team communicates about the project.\n\n\nChat commands are declared in Rug command handlers. Command handlers handle\ncommands coming from users via the Atomist bot.\n\n\nDepending on their goal, Rug command handler implementations are stored either alongside\nthe project they target or in different projects altogether.\n\n\nBelow is the basic structure of any Rug project, except that our handlers live in\nthe \n.atomist/handlers\n directory:\n\n\n~/workspace/team-handlers\n\n\n    \u251c\u2500\u2500 .atomist\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 handlers\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 command\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 MergePR.ts\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 event\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 GitHubCommit.ts\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests\n\n\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json\n\n\n    \u251c\u2500\u2500 CHANGELOG.md\n\n\n    \u251c\u2500\u2500 .gitignore\n\n\n    \u251c\u2500\u2500 LICENSE\n\n\n    \u2514\u2500\u2500 README.md\n\n\n\n\n\nThe remaining files and directors of this Rug follows the usual\n\nRug project\n structure.\n\n\nExample Command Handler\n\u00b6\n\n\nSuppose we want to open a new GitHub issue:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\nimport\n \n{\n \nIssue\n \n}\n \nfrom\n \n\"@atomist/cortex/Issue\"\n;\n\n\nimport\n \n{\n\n    \nCommandHandler\n,\n \nIntent\n,\n \nMappedParameter\n,\n \nParameter\n,\n \nSecrets\n,\n \nTags\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Decorators\"\n;\n\n\nimport\n \n{\n\n    \nCommandPlan\n,\n \nCommandRespondable\n,\n \nExecute\n,\n \nHandleCommand\n,\n \nHandlerContext\n,\n\n    \nMappedParameters\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Handlers\"\n;\n\n\nimport\n \n{\n \nhandleErrors\n \n}\n \nfrom\n \n\"@atomist/rugs/operations/CommonHandlers\"\n;\n\n\n\n@CommandHandler\n(\n\"CreateGitHubIssue\"\n,\n \n\"Create an issue on GitHub\"\n)\n\n\n@Tags\n(\n\"github\"\n,\n \n\"issues\"\n)\n\n\n@Secrets\n(\n\"github://user_token?scopes=repo\"\n)\n\n\n@Intent\n(\n\"create issue\"\n)\n\n\nclass\n \nCreateIssueCommand\n \nimplements\n \nHandleCommand\n \n{\n\n\n    \n@Parameter\n({\n \ndescription\n:\n \n\"The issue title\"\n,\n \npattern\n:\n \n\"^.*$\"\n \n})\n\n    \npublic\n \ntitle\n: \nstring\n;\n\n\n    \n@Parameter\n({\n \ndescription\n:\n \n\"The issue body\"\n,\n \npattern\n:\n \n\"^.*(?m)$\"\n \n})\n\n    \npublic\n \nbody\n: \nstring\n;\n\n\n    \n@MappedParameter\n(\nMappedParameters\n.\nGITHUB_REPOSITORY\n)\n\n    \npublic\n \nrepo\n: \nstring\n;\n\n\n    \n@MappedParameter\n(\nMappedParameters\n.\nGITHUB_REPO_OWNER\n)\n\n    \npublic\n \nowner\n: \nstring\n;\n\n\n    \n@MappedParameter\n(\n\"atomist://correlation_id\"\n)\n\n    \npublic\n \ncorrid\n: \nstring\n;\n\n\n    \npublic\n \nhandle\n(\nctx\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nconst\n \nplan\n \n=\n \nnew\n \nCommandPlan\n();\n\n        \nconst\n \nexecute\n: \nCommandRespondable\n<\nExecute\n>\n \n=\n \n{\n\n            \ninstruction\n:\n \n{\n\n                \nkind\n:\n \n\"execute\"\n,\n\n                \nname\n:\n \n\"create-github-issue\"\n,\n\n                \nparameters\n: \nthis\n,\n\n            \n},\n\n        \n};\n\n        \nplan\n.\nadd\n(\nhandleErrors\n(\nexecute\n,\n \nthis\n));\n\n        \nreturn\n \nplan\n;\n\n    \n}\n\n\n}\n\n\n\nexport\n \nconst\n \ncreate\n \n=\n \nnew\n \nCreateIssueCommand\n();\n\n\n\n\n\n\n\nThis command handler follows the same programming model as other Rugs, so it\nshould look familiar.\n\n\nDeclaration\n\u00b6\n\n\nThe first lines group the Rug typing imports which, provide interfaces and\ndecorators to implement and declare your handlers. The  \nCreateIssueCommand\n\nclass expresses how the command is invoked, as well as how to handle the error\nscenario. \nGenericErrorHandler\n is a  \nResponse Handlers\n\nto handle the failure case of the \ncreate-github-issue\n \nexecute\n \ninstruction\n.\n\n\nWe declare our handler through \ndecorators\n. The first argument\nof the \n@CommandHandler\n decorator is the name of the command,\nthe second is its description. These make the handlers visible and discoverable.\n\n\nIntent\n\u00b6\n\n\nA Rug command handler can have associated intent that users can send when talking\nwith the Atomist bot. The intent is described using the \n@Intent\n\ndecorator (line 20). Whenever a user sends the \n@atomist create issue\n message\nto the Atomist bot, the Rug runtime runs the \nCreateGitHubIssue\n\ncommand handler. Declaring Intent is the way we declare the commands that are\nmade availble to users in chat.\n\n\n\n\nCommand Handlers invoking Command Handlers\n\n\nMost of the time, it makes sense to add the \n@Intent\n decorator.\nHowever, it\u2019s also possible to invoke Command Handlers from Command Handlers\nby adding them to the Plan (more on this later), so for these handlers, it\nmight not make sense to expose them directly to chat users as commands.\n\n\n\n\nDiscovery\n\u00b6\n\n\nAll Rugs should be annotated with one or more \n@Tags\n \n\ndecorators\n to optimize their discoverability. For \nexample if you were to create an Rug that alters a README file\nthen the following \n@Tags\n would be applicable:\n\n\n@Tags\n(\n\"readme\"\n,\n \n\"documentation\"\n)\n\n\n\n\n\nTag values should consist of only lower case letters, numbers, and\ndashes (\n-\n).\n\n\nIf possible, try to include at least one of the tags on your Rug maps to an image\nfor a nicer rendering.  The following tags currently have images:\n\ndocker\n,\ngithub\n, \ntravis-ci\n, \napache\n, \ngit\n, \nspring-boot\n,\n\nspring\n, \nclojure\n, \ngo\n, \njava\n, \npython\n, \nscala\n, and\n\ndocumentation\n.\n\n\nImplementation\n\u00b6\n\n\nYou define the class which implements your command handler (line 21). The class is\nexported so that it can referenced from unit tests. A command handler implements\nthe \nHandleCommand\n interface. This interface requires the\n\nhandle\n(\ncommand\n: \nHandlerContext\n)\n:\n \nCommandPlan\n method to be\nimplemented. It is a convention for the command handler and the class that defines\nit to have the same name.\n\n\nThe \nhandle\n method takes a single argument, a\n\nHandlerContext\n instance. This gives you access to a\n\npath expression engine\n to query your organization\u2019s projects. The method\nmust return a \nCommandPlan\n.\n\n\nParameters\n\u00b6\n\n\nRug command handlers can take parameters like other Rugs. Parameters are declared using the \n@Parameter\n decorator. \nThe decorated variable names the parameter. If you assign a value to that\nvariable, it becomes the parameter\u2019s default value. The \n@Parameter\n\ndecorator adds additional metadata via a single argument: a JavaScript object\nwhose properties are documented in the \nconventions\n. Though the only\nmandatory property is \npattern\n. It is highly recommended to also\nset \ndescription\n, \ndisplayName\n and \n\nvalidInput\n in order to help other users when invoking Rugs via\nthe Atomist bot.\n\n\nMapped Parameters\n\u00b6\n\n\nRug command handlers can define what are called Mapped Parameters to receive\nrelevant contextual information when invoked via the Atomist bot. Mapped Parameters, declared using the \n@MappedParameter\n decorator, \nbehave much like ordinary Parameters declared by the  \n@Parameter\n \ndecorator, but are defined and provided by an external system, in most cases,\nthe Atomist Bot itself.\n\n\nFor example, the \n\"atomist://github/repository/owner\"\n Mapped Parameter will be\npopulated with the name of owner (user or organization) of the GitHub repository\nassociated with a particular chat channel.\n\n\nA TypeScript helper class called \nMappedParameters\n exists to \naid discovery and use of Mapped Parameters. It lives in an NPM module at\n\n@atomist/rug/operations/Handlers.ts\n:\n\n\nabstract\n \nclass\n \nMappedParameters\n \n{\n\n  \nstatic\n \nreadonly\n \nGITHUB_REPO_OWNER\n: \nstring\n \n=\n \n\"atomist://github/repository/owner\"\n\n  \nstatic\n \nreadonly\n \nGITHUB_REPOSITORY\n: \nstring\n \n=\n \n\"atomist://github/repository\"\n\n  \nstatic\n \nreadonly\n \nSLACK_CHANNEL\n: \nstring\n \n=\n \n\"atomist://slack/channel\"\n\n  \nstatic\n \nreadonly\n \nSLACK_TEAM\n: \nstring\n \n=\n \n\"atomist://slack/team\"\n\n  \nstatic\n \nreadonly\n \nSLACK_USER\n: \nstring\n \n=\n \n\"atomist://slack/user\"\n\n  \nstatic\n \nreadonly\n \nGITHUB_WEBHOOK_URL\n: \nstring\n \n=\n \n\"atomist://github_webhook_url\"\n\n\n}\n\n\n\n\n\nCommandPlans\n\u00b6\n\n\nA \nCommandPlan\n describes the actions to be taken by the Rug runtime\non behalf of the handler. CommandPlans are composed of \nMessages\n and/or\n\nrespondables\n. Respondables instruct the rug runtime to immediately\nperform ordinary rug operations, whereas messages are sent to the Atomist Bot for\ndisplay to the user.\n\n\nMessages\n\u00b6\n\n\nA \nMessage\n represents presentable content to be rendered in chat by the Atomist\nBot to a chat channel or user. However, each of the two available message types\nachieve this in different ways.\n\n\nDirected Messages\n\u00b6\n\n\nA Directed Message is sent directly to on or more users or channels. No\nautomatic routing is performed by the Atomist Bot. It\u2019s possible to\nadd Directed Messages to a Plan returned by any handler type.\n\n\nThe simplest use of a Response Message just echos back some plain text to\nthe user that invoked the command:\n\n\n    \nhandle\n(\ncommand\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nconst\n \nbob\n \n=\n \nnew\n \nUserAddress\n(\n\"@bob\"\n);\n\n        \nreturn\n \nCommandPlan\n.\nofMessage\n(\nnew\n \nDirectedMessage\n(\n\"Hello world!\"\n,\n \nbob\n));\n\n    \n}\n\n\n\n\n\nIt\u2019s possible to add more channels or usernames:\n\n\nhandle\n(\nresponse\n: \nResponse\n<\nany\n>\n)\n:\n \nCommandPlan\n \n{\n\n    \nconst\n \nbob\n \n=\n \nnew\n \nUserAddress\n(\n\"@bob\"\n);\n\n    \nlet\n \nmsg\n  \n=\n \nnew\n \nDirectedMessage\n(\n\"Hello everyone!\"\n,\n \nbob\n);\n\n    \nmsg\n.\naddAddress\n(\nnew\n \nChannelAddress\n(\n\"#general\"\n));\n\n    \nreturn\n \nCommandPlan\n.\nofMessage\n(\nmsg\n);\n\n\n}\n\n\n\n\n\nBy default, the body of the message is assumed to be \n\"text/plain\n, and will be\ndisplayed verbatim. The message can also be JSON formatted according to\n\nSlack\u2019s message standards\n:\n\n\n    \nhandle\n(\ncommand\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nconst\n \nuser\n \n=\n \nnew\n \nUserAddress\n(\n\"@bob\"\n);\n\n        \nconst\n \njson\n \n=\n \n{\n\n            \n\"text\"\n:\n \n\"I am a test message https://www.atomist.com\"\n,\n\n            \n\"attachments\"\n:\n \n[{\n\n               \n\"text\"\n:\n \n\"And here\u2019s an attachment!\"\n\n             \n}]\n\n        \n}\n\n        \nconst\n \nmsg\n \n=\n \nnew\n \nDirectedMessage\n(\nJSON\n.\nstringify\n(\njson\n),\n \nuser\n,\n \nMessageMimeTypes\n.\nSLACK_JSON\n);\n\n        \nreturn\n \nCommandPlan\n.\nofMessage\n(\nmsg\n);\n\n    \n}\n\n\n\n\n\nResponse Messages\n\u00b6\n\n\nA Response Message is much like a \nDirectedMesssage\n, except that\nthe destination for the message is optional because the Atomist Bot chooses the\nchannel or user to respond to based on where the command was invoked in the chat\nsystem. As such, it really only makes sense to return Response Messages in Plans\nreturned from Command Handlers.\n\n\nThe most simple use of a Response Message just echos back some plain text to\nthe user that invoked the command:\n\n\n    \nhandle\n(\ncommand\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nreturn\n \nCommandPlan\n.\nofMessage\n(\nnew\n \nResponseMessage\n(\n\"Hello world!\"\n))\n\n    \n}\n\n\n\n\n\nIn addition to the default recipient, we can add one or more\n\nMessageAddress\nto the message to send the same message to other\nchat users or channels.\n\n\nhandle\n(\nresponse\n: \nResponse\n<\nany\n>\n)\n:\n \nCommandPlan\n \n{\n\n    \nlet\n \nmessage\n  \n=\n \nnew\n \nResponseMessage\n(\n\"Hello other world!\"\n);\n\n    \nmessage\n.\naddAddress\n(\nnew\n \nUserAddress\n(\n\"@bob\"\n))\n\n    \nreturn\n \nCommandPlan\n.\nofMessage\n(\nmessage\n);\n\n\n}\n\n\n\n\n\nBy default, the body of the message is assumed to be \ntext/plain\n, and will be\ndisplayed verbatim. The message can also be JSON formatted\naccording to \nSlack\u2019s message standards\n:\n\n\n    \nhandle\n(\ncommand\n: \nHandlerContext\n)\n:\n \nCommandPlan\n \n{\n\n        \nconst\n \njson\n \n=\n \n{\n\n            \n\"text\"\n:\n \n\"I am a test message https://www.atomist.com\"\n,\n\n            \n\"attachments\"\n:\n \n[{\n\n               \n\"text\"\n:\n \n\"And here\u2019s an attachment!\"\n\n             \n}]\n\n        \n}\n\n        \nconst\n \nmsgg\n \n=\n \nnew\n \nResponseMessage\n(\nJSON\n.\nstringify\n(\njson\n)\n \n,\n \nMessageMimeTypes\n.\nSLACK_JSON\n)\n\n        \nreturn\n \nCommandPlan\n.\nofMessage\n(\nmessage\n)\n\n    \n}\n\n\n\n\n\nRespondables\n\u00b6\n\n\nAn \nCommandRespondable\n is really just a container for an instruction and\nsome optional \nonError\n and \nonSuccess\n capabilities. The \nonError\n and \nonSuccess\n\nproperties of an \nCommandRespondable\n can be \nmessages\n,\n\nCommandPlans\n or \nresponse handlers\n.\n\n\nconst\n \nplan\n \n=\n \nnew\n \nCommandPlan\n();\n\n\nplan\n.\nadd\n(\n\n    \n{\n\n        \ninstruction\n:\n \n{\n\n            \nkind\n:\n \n\"execute\"\n,\n\n            \nname\n:\n \n\"create-github-issue\"\n,\n\n            \nparameters\n: \nthis\n\n        \n},\n\n        \nonError\n:\n \n{\n\n            \nkind\n:\n \n\"respond\"\n,\n\n            \nname\n:\n \n\"GenericErrorHandler\"\n,\n\n            \nparameters\n: \nthis\n\n        \n},\n\n        \nonSuccess\n: \nnew\n \nResponseMesssage\n(\n\"Successfully created issue\"\n)\n\n    \n}\n\n\n)\n\n\nplan\n.\nadd\n(\nhandleErrors\n(\nexec\n,\n \nthis\n))\n\n\nreturn\n \nplan\n;\n\n\n\n\n\nThe example above shows how send a message back to the user or channel that invoked\nthe command \nonSuccess\n or to invoke the \nGenericErrorHandler\n \nResponse Handler\n\nif creation fails.\n\n\nInstructions\n\u00b6\n\n\nInstructions in an \nCommandRespondable\n have the following properties:\n\n\n\n\nkind\n:\n \n\"generate\"\n \n|\n \n\"edit\"\n \n|\n \n\"execute\"\n \n|\n \n\"command\"\n: the kind of instruction\n\n\nname\n: \nstring\n: the name of the operation to apply\n\n\nparameters\n:\n \n{}\n: key/value pairs passed to the operation\n\n\nproject?\n: \nstring\n: Project name (only for generators & editors)\n\n\n\n\nInstructions can be used to have the rug runtime run Rugs, such as invoking\na Generator (\n\"generate\"\n), an Editor (\n\"edit\"\n),\na \nRug Funtion\n (\n\"execute\"\n) or even another Command\nHandler.\n\n\nRug Functions\n\u00b6\n\n\nRug Functions, as indicated by their name, are functions that can be invoked\nfrom within Event or Command Handlers. They can be scheduled for invocation by\nadding an instruction of kind \nexecute\n to a plan:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nplan\n.\nadd\n(\n\n    \n{\n\n        \ninstruction\n:\n \n{\n\n            \nkind\n:\n \n\"execute\"\n,\n\n            \nname\n:\n \n\"http\"\n,\n\n            \nparameters\n:\n \n{\n\n                \nurl\n:\n \n\"https://api.github.com/repos/atomist/rug\"\n,\n\n                \nmethod\n:\n \n\"post\"\n,\n\n                \nconfig\n:\n \n{\n\n                    \nheaders\n:\n \n{\n\n                        \n\"Content-Type\"\n:\n \n\"application/json\"\n,\n\n                        \n\"Authorization\"\n:\n \n`token #{github://user_token?scopes=repo}`\n,\n\n                    \n},\n\n                    \nbody\n: \nJSON.stringify\n(\ncreateRepoRequest\n)\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \nonSuccess\n: \nnew\n \nDirectMessage\n(\n\"Woot!\"\n,\n \nnew\n \nChannelAddress\n(\n\"#random\"\n)),\n\n        \nonError\n: \nnew\n \nDirectMessage\n(\n\"Un oh\"\n,\n \nnew\n \nChannelAddress\n(\n\"#random\"\n))\n\n    \n}\n\n\n)\n\n\n\n\n\n\n\nThe plan above instructs the Rug Runtime to invoke the \nhttp\n Rug Function,\npassing all the \nparameters\n to it, and sending appropriate messages to the\n\n#random\n channel \nonSuccess\n or \nonError\n.\n\n\nTo use a Rug Function from an Event or Command Handler, its archive\u2019s\ncoordinates must be present in the \n.atomist.extensions\n section of\nthe Rug project\u2019s \npackage.json\n.\n\n\n\n\nSecurity\n\n\nAll Rug Function archives must be signed by Atomist and be explicitly\nwhitelisted in the Atomist service. Otherwise, the execution of the invoking\nhandler will be aborted.\n\n\n\n\nSecrets\n can also be passed to Rug Functions, but currently this is only supported\nfor Command Handlers.\n\n\nThe special \n#{<secret path>}\n notation used above is a way of injecting the value\nof a secret (in this case, a GitHub token with \nrepo\n scope) in to the parameters\nto a function via string filtering. Rug Functions can also be \nannotated\n\nso that if the secrets required are known in advance, we don\u2019t need to use paramter\nfiltering.\n\n\nThe following Rug Function archives available:\n\n\n\n\nrug-function-http\n - perform arbitrary HTTP requests\n\n\nrug-functions-travis\n - encrypt secrets, start/stop builds\n\n\nrug-functions-aws\n - perform s3 operations and so on\n\n\n\n\n\n\nCreating your own Rug functions\n\n\nRight now there is no support for user-created Rug functions. Please get in\ntouch by joining our \nSlack team\n if you need one\nthat doesn\u2019t already exist.\n\n\n\n\nSecrets\n\u00b6\n\n\nSecrets are pieces of sensitive information stored securely by Atomist. Secrets\nare used by \nRug Functions\n to provide access\nto secured systems, such as the GitHub API.\n\n\nHandlers that invoke Rug Functions that require secrets must use the\n\n@Secrets\n decorator to declare to the Rug runtime that those\nsecrets will be required during the execution of the handler\u2019s CommandPlan:\n\n\n...\n\n\n@Secrets\n(\n\"github://user_token?scopes=repo,read:org\"\n)\n\n\nclass\n \nCloseIssueCommand\n \nimplements\n \nHandleCommand\n \n{\n\n    \n//...\n\n\n}\n\n\n\n\n\nThe \n@Secrets\n decorator takes a comma separate list of secret\npaths. The decorator provides enough context to the Atomist Bot such that it\ncan initiate the secure collection of the require secret data, such as a GitHub\ntoken collected via OAuth flow.\n\n\n\n\nConfidentiality\n\n\nAll sensitive data stored by Atomist are encrypted at rest in\n\nVault\n.\n\n\n\n\nThere are currently two types of secrets:\n\n\n\n\nGitHub tokens: automatically collected by the Atomist Bot\n\n\n\"github://user_token?scopes=repo\"\n - \nrepo\n scoped user token\n\n\n\"github://team_token?scopes=repo\"\n - \nrepo\n scoped\nteam token Both user and team GitHub tokens require the scopes\nneeded by the \ntoken\n to be provided as a comma-separated list.\n\n\n\n\n\n\nGeneric Secrets: manual collection\n\n\n\"secret://user?path=/some/secret\"\n - generic user secret\n\n\n\"secret://team?path=/some/secret\"\n - generic team secret\n\n\n\n\n\n\n\n\n\n\nGeneric Secrets\n\n\nThese are currently only available for very specific and mostly internal use\ncases as we currently have no secure public mechanism for collecting and storing\nthem, though this is something we are hoping to support in the near future. They\nare mentioned here to avoid any confusion when seen in publically visible Handlers.\n\n\n\n\nResponse Handlers\n\u00b6\n\n\nA \nRespond\n object (declared using \n{\nkind\n:\n \n\"respond\"\n}\n)\nindicates the desire to handle the response to an Instruction using a\n\nResponseHandler\n object.\n\n\nimport\n \n{\n\n    \nParameter\n,\n \nParseJson\n,\n \nResponseHandler\n,\n \nTags\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Decorators\"\n;\n\n\n\nimport\n \n{\n\n    \nChannelAddress\n,\n \nDirectedMessage\n,\n \nEventPlan\n,\n \nHandlerContext\n,\n\n    \nHandleResponse\n,\n \nResponse\n,\n \nResponseMessage\n,\n\n\n}\n \nfrom\n \n\"@atomist/rug/operations/Handlers\"\n;\n\n\n\n@ResponseHandler\n(\n\"GenericSuccessHandler\"\n,\n \n\"displays a success message in chat\"\n)\n\n\n@Tags\n(\n\"success\"\n)\n\n\nclass\n \nGenericSuccessHandler\n \nimplements\n \nHandleResponse\n<\nany\n>\n \n{\n\n\n    \n@Parameter\n({\n \ndescription\n:\n \n\"Success msg\"\n,\n \npattern\n:\n \n\"@any\"\n \n})\n\n    \npublic\n \nmsg\n: \nstring\n;\n\n\n    \npublic\n \nhandle\n(\n \n@ParseJson\n \nresponse\n: \nResponse\n<\nany\n>\n)\n:\n \nEventPlan\n \n{\n\n        \nconst\n \nrand\n \n=\n \nnew\n \nChannelAddress\n(\n\"#random\"\n);\n\n        \nconst\n \nresult\n \n=\n \n`\n${\nthis\n.\nmsg\n}\n: \n${\nresponse\n.\nbody\n.\nstatus\n}\n`\n;\n\n        \nreturn\n \nnew\n \nEventPlan\n().\nadd\n(\nnew\n \nDirectedMessage\n(\nresult\n,\n \nrand\n));\n\n    \n}\n\n\n}\n\n\n\n\n\nResponse handlers are declared with the \nResponseHandler\n decorator\nand the class must implement the\n\nhandle\n(\nresponse\n: \nResponse\n<\nT\n>\n)\n:\n \nEventPlan\n \n|\n \nCommandPlan\n method of the\n\nHandleResponse\n<\nT\n>\n interface. When the handler receives a JSON\npayload, you can benefit from automatic JSON deserialization into an object by\ndecorating the response parameter with the \n@ParseJson\n decorator,\nfor example \nhandle\n(\n@ParseJson\n \nresponse\n: \nResponse\n<\nT\n>\n)\n:\n \nCommandPlan\n.\n\n\nResponse Handlers must also return a plan, just like any handler. However, they\nmust return the appropriate type of plan for the execution chain in which they\nrespond. So for an \nEvent Handler\n they must\nreturn an \nEventPlan\n, and for a \nCommand Handler\n\nthey must return a \nCommandPlan\n.\n\n\n\n\nIt\u2019s all asynchronous\n\n\nIt is important to appreciate that because handlers return plans,\nthe actions declared in that plan are executed asynchronously. In other\nwords, plans are just data the Rug runtime knows how to interpret but your\nhandler cannot invoke those Rugs directly. So it\u2019s not safe to make\nassumptions about when instructions in a plan will be run, although\nit is fair to say that the Atomist platform will do its best to apply them\nas soon as possible.",
            "title": "Command Handlers"
        },
        {
            "location": "/user-guide/rug/command-handlers/#anatomy-of-a-command-handler",
            "text": "Rug commands handlers are the interface to add new skills to the  Atomist bot .\nThese handlers are appropriate when you want to either query your project\nor perform an action where your team communicates about the project.  Chat commands are declared in Rug command handlers. Command handlers handle\ncommands coming from users via the Atomist bot.  Depending on their goal, Rug command handler implementations are stored either alongside\nthe project they target or in different projects altogether.  Below is the basic structure of any Rug project, except that our handlers live in\nthe  .atomist/handlers  directory:  ~/workspace/team-handlers      \u251c\u2500\u2500 .atomist      \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore      \u2502\u00a0\u00a0 \u251c\u2500\u2500 handlers      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 command      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 MergePR.ts      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 event      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 GitHubCommit.ts      \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json      \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests      \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json      \u251c\u2500\u2500 CHANGELOG.md      \u251c\u2500\u2500 .gitignore      \u251c\u2500\u2500 LICENSE      \u2514\u2500\u2500 README.md   The remaining files and directors of this Rug follows the usual Rug project  structure.",
            "title": "Anatomy of a Command Handler"
        },
        {
            "location": "/user-guide/rug/command-handlers/#example-command-handler",
            "text": "Suppose we want to open a new GitHub issue:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46 import   {   Issue   }   from   \"@atomist/cortex/Issue\" ;  import   { \n     CommandHandler ,   Intent ,   MappedParameter ,   Parameter ,   Secrets ,   Tags ,  }   from   \"@atomist/rug/operations/Decorators\" ;  import   { \n     CommandPlan ,   CommandRespondable ,   Execute ,   HandleCommand ,   HandlerContext , \n     MappedParameters ,  }   from   \"@atomist/rug/operations/Handlers\" ;  import   {   handleErrors   }   from   \"@atomist/rugs/operations/CommonHandlers\" ;  @CommandHandler ( \"CreateGitHubIssue\" ,   \"Create an issue on GitHub\" )  @Tags ( \"github\" ,   \"issues\" )  @Secrets ( \"github://user_token?scopes=repo\" )  @Intent ( \"create issue\" )  class   CreateIssueCommand   implements   HandleCommand   { \n\n     @Parameter ({   description :   \"The issue title\" ,   pattern :   \"^.*$\"   }) \n     public   title :  string ; \n\n     @Parameter ({   description :   \"The issue body\" ,   pattern :   \"^.*(?m)$\"   }) \n     public   body :  string ; \n\n     @MappedParameter ( MappedParameters . GITHUB_REPOSITORY ) \n     public   repo :  string ; \n\n     @MappedParameter ( MappedParameters . GITHUB_REPO_OWNER ) \n     public   owner :  string ; \n\n     @MappedParameter ( \"atomist://correlation_id\" ) \n     public   corrid :  string ; \n\n     public   handle ( ctx :  HandlerContext ) :   CommandPlan   { \n         const   plan   =   new   CommandPlan (); \n         const   execute :  CommandRespondable < Execute >   =   { \n             instruction :   { \n                 kind :   \"execute\" , \n                 name :   \"create-github-issue\" , \n                 parameters :  this , \n             }, \n         }; \n         plan . add ( handleErrors ( execute ,   this )); \n         return   plan ; \n     }  }  export   const   create   =   new   CreateIssueCommand ();    This command handler follows the same programming model as other Rugs, so it\nshould look familiar.",
            "title": "Example Command Handler"
        },
        {
            "location": "/user-guide/rug/command-handlers/#declaration",
            "text": "The first lines group the Rug typing imports which, provide interfaces and\ndecorators to implement and declare your handlers. The   CreateIssueCommand \nclass expresses how the command is invoked, as well as how to handle the error\nscenario.  GenericErrorHandler  is a   Response Handlers \nto handle the failure case of the  create-github-issue   execute   instruction .  We declare our handler through  decorators . The first argument\nof the  @CommandHandler  decorator is the name of the command,\nthe second is its description. These make the handlers visible and discoverable.",
            "title": "Declaration"
        },
        {
            "location": "/user-guide/rug/command-handlers/#intent",
            "text": "A Rug command handler can have associated intent that users can send when talking\nwith the Atomist bot. The intent is described using the  @Intent \ndecorator (line 20). Whenever a user sends the  @atomist create issue  message\nto the Atomist bot, the Rug runtime runs the  CreateGitHubIssue \ncommand handler. Declaring Intent is the way we declare the commands that are\nmade availble to users in chat.   Command Handlers invoking Command Handlers  Most of the time, it makes sense to add the  @Intent  decorator.\nHowever, it\u2019s also possible to invoke Command Handlers from Command Handlers\nby adding them to the Plan (more on this later), so for these handlers, it\nmight not make sense to expose them directly to chat users as commands.",
            "title": "Intent"
        },
        {
            "location": "/user-guide/rug/command-handlers/#discovery",
            "text": "All Rugs should be annotated with one or more  @Tags   decorators  to optimize their discoverability. For \nexample if you were to create an Rug that alters a README file\nthen the following  @Tags  would be applicable:  @Tags ( \"readme\" ,   \"documentation\" )   Tag values should consist of only lower case letters, numbers, and\ndashes ( - ).  If possible, try to include at least one of the tags on your Rug maps to an image\nfor a nicer rendering.  The following tags currently have images: docker , github ,  travis-ci ,  apache ,  git ,  spring-boot , spring ,  clojure ,  go ,  java ,  python ,  scala , and documentation .",
            "title": "Discovery"
        },
        {
            "location": "/user-guide/rug/command-handlers/#implementation",
            "text": "You define the class which implements your command handler (line 21). The class is\nexported so that it can referenced from unit tests. A command handler implements\nthe  HandleCommand  interface. This interface requires the handle ( command :  HandlerContext ) :   CommandPlan  method to be\nimplemented. It is a convention for the command handler and the class that defines\nit to have the same name.  The  handle  method takes a single argument, a HandlerContext  instance. This gives you access to a path expression engine  to query your organization\u2019s projects. The method\nmust return a  CommandPlan .",
            "title": "Implementation"
        },
        {
            "location": "/user-guide/rug/command-handlers/#parameters",
            "text": "Rug command handlers can take parameters like other Rugs. Parameters are declared using the  @Parameter  decorator. \nThe decorated variable names the parameter. If you assign a value to that\nvariable, it becomes the parameter\u2019s default value. The  @Parameter \ndecorator adds additional metadata via a single argument: a JavaScript object\nwhose properties are documented in the  conventions . Though the only\nmandatory property is  pattern . It is highly recommended to also\nset  description ,  displayName  and  validInput  in order to help other users when invoking Rugs via\nthe Atomist bot.",
            "title": "Parameters"
        },
        {
            "location": "/user-guide/rug/command-handlers/#mapped-parameters",
            "text": "Rug command handlers can define what are called Mapped Parameters to receive\nrelevant contextual information when invoked via the Atomist bot. Mapped Parameters, declared using the  @MappedParameter  decorator, \nbehave much like ordinary Parameters declared by the   @Parameter  \ndecorator, but are defined and provided by an external system, in most cases,\nthe Atomist Bot itself.  For example, the  \"atomist://github/repository/owner\"  Mapped Parameter will be\npopulated with the name of owner (user or organization) of the GitHub repository\nassociated with a particular chat channel.  A TypeScript helper class called  MappedParameters  exists to \naid discovery and use of Mapped Parameters. It lives in an NPM module at @atomist/rug/operations/Handlers.ts :  abstract   class   MappedParameters   { \n   static   readonly   GITHUB_REPO_OWNER :  string   =   \"atomist://github/repository/owner\" \n   static   readonly   GITHUB_REPOSITORY :  string   =   \"atomist://github/repository\" \n   static   readonly   SLACK_CHANNEL :  string   =   \"atomist://slack/channel\" \n   static   readonly   SLACK_TEAM :  string   =   \"atomist://slack/team\" \n   static   readonly   SLACK_USER :  string   =   \"atomist://slack/user\" \n   static   readonly   GITHUB_WEBHOOK_URL :  string   =   \"atomist://github_webhook_url\"  }",
            "title": "Mapped Parameters"
        },
        {
            "location": "/user-guide/rug/command-handlers/#commandplans",
            "text": "A  CommandPlan  describes the actions to be taken by the Rug runtime\non behalf of the handler. CommandPlans are composed of  Messages  and/or respondables . Respondables instruct the rug runtime to immediately\nperform ordinary rug operations, whereas messages are sent to the Atomist Bot for\ndisplay to the user.",
            "title": "CommandPlans"
        },
        {
            "location": "/user-guide/rug/command-handlers/#messages",
            "text": "A  Message  represents presentable content to be rendered in chat by the Atomist\nBot to a chat channel or user. However, each of the two available message types\nachieve this in different ways.",
            "title": "Messages"
        },
        {
            "location": "/user-guide/rug/command-handlers/#directed-messages",
            "text": "A Directed Message is sent directly to on or more users or channels. No\nautomatic routing is performed by the Atomist Bot. It\u2019s possible to\nadd Directed Messages to a Plan returned by any handler type.  The simplest use of a Response Message just echos back some plain text to\nthe user that invoked the command:       handle ( command :  HandlerContext ) :   CommandPlan   { \n         const   bob   =   new   UserAddress ( \"@bob\" ); \n         return   CommandPlan . ofMessage ( new   DirectedMessage ( \"Hello world!\" ,   bob )); \n     }   It\u2019s possible to add more channels or usernames:  handle ( response :  Response < any > ) :   CommandPlan   { \n     const   bob   =   new   UserAddress ( \"@bob\" ); \n     let   msg    =   new   DirectedMessage ( \"Hello everyone!\" ,   bob ); \n     msg . addAddress ( new   ChannelAddress ( \"#general\" )); \n     return   CommandPlan . ofMessage ( msg );  }   By default, the body of the message is assumed to be  \"text/plain , and will be\ndisplayed verbatim. The message can also be JSON formatted according to Slack\u2019s message standards :       handle ( command :  HandlerContext ) :   CommandPlan   { \n         const   user   =   new   UserAddress ( \"@bob\" ); \n         const   json   =   { \n             \"text\" :   \"I am a test message https://www.atomist.com\" , \n             \"attachments\" :   [{ \n                \"text\" :   \"And here\u2019s an attachment!\" \n              }] \n         } \n         const   msg   =   new   DirectedMessage ( JSON . stringify ( json ),   user ,   MessageMimeTypes . SLACK_JSON ); \n         return   CommandPlan . ofMessage ( msg ); \n     }",
            "title": "Directed Messages"
        },
        {
            "location": "/user-guide/rug/command-handlers/#response-messages",
            "text": "A Response Message is much like a  DirectedMesssage , except that\nthe destination for the message is optional because the Atomist Bot chooses the\nchannel or user to respond to based on where the command was invoked in the chat\nsystem. As such, it really only makes sense to return Response Messages in Plans\nreturned from Command Handlers.  The most simple use of a Response Message just echos back some plain text to\nthe user that invoked the command:       handle ( command :  HandlerContext ) :   CommandPlan   { \n         return   CommandPlan . ofMessage ( new   ResponseMessage ( \"Hello world!\" )) \n     }   In addition to the default recipient, we can add one or more MessageAddress to the message to send the same message to other\nchat users or channels.  handle ( response :  Response < any > ) :   CommandPlan   { \n     let   message    =   new   ResponseMessage ( \"Hello other world!\" ); \n     message . addAddress ( new   UserAddress ( \"@bob\" )) \n     return   CommandPlan . ofMessage ( message );  }   By default, the body of the message is assumed to be  text/plain , and will be\ndisplayed verbatim. The message can also be JSON formatted\naccording to  Slack\u2019s message standards :       handle ( command :  HandlerContext ) :   CommandPlan   { \n         const   json   =   { \n             \"text\" :   \"I am a test message https://www.atomist.com\" , \n             \"attachments\" :   [{ \n                \"text\" :   \"And here\u2019s an attachment!\" \n              }] \n         } \n         const   msgg   =   new   ResponseMessage ( JSON . stringify ( json )   ,   MessageMimeTypes . SLACK_JSON ) \n         return   CommandPlan . ofMessage ( message ) \n     }",
            "title": "Response Messages"
        },
        {
            "location": "/user-guide/rug/command-handlers/#respondables",
            "text": "An  CommandRespondable  is really just a container for an instruction and\nsome optional  onError  and  onSuccess  capabilities. The  onError  and  onSuccess \nproperties of an  CommandRespondable  can be  messages , CommandPlans  or  response handlers .  const   plan   =   new   CommandPlan ();  plan . add ( \n     { \n         instruction :   { \n             kind :   \"execute\" , \n             name :   \"create-github-issue\" , \n             parameters :  this \n         }, \n         onError :   { \n             kind :   \"respond\" , \n             name :   \"GenericErrorHandler\" , \n             parameters :  this \n         }, \n         onSuccess :  new   ResponseMesssage ( \"Successfully created issue\" ) \n     }  )  plan . add ( handleErrors ( exec ,   this ))  return   plan ;   The example above shows how send a message back to the user or channel that invoked\nthe command  onSuccess  or to invoke the  GenericErrorHandler   Response Handler \nif creation fails.",
            "title": "Respondables"
        },
        {
            "location": "/user-guide/rug/command-handlers/#instructions",
            "text": "Instructions in an  CommandRespondable  have the following properties:   kind :   \"generate\"   |   \"edit\"   |   \"execute\"   |   \"command\" : the kind of instruction  name :  string : the name of the operation to apply  parameters :   {} : key/value pairs passed to the operation  project? :  string : Project name (only for generators & editors)   Instructions can be used to have the rug runtime run Rugs, such as invoking\na Generator ( \"generate\" ), an Editor ( \"edit\" ),\na  Rug Funtion  ( \"execute\" ) or even another Command\nHandler.",
            "title": "Instructions"
        },
        {
            "location": "/user-guide/rug/command-handlers/#rug-functions",
            "text": "Rug Functions, as indicated by their name, are functions that can be invoked\nfrom within Event or Command Handlers. They can be scheduled for invocation by\nadding an instruction of kind  execute  to a plan:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 plan . add ( \n     { \n         instruction :   { \n             kind :   \"execute\" , \n             name :   \"http\" , \n             parameters :   { \n                 url :   \"https://api.github.com/repos/atomist/rug\" , \n                 method :   \"post\" , \n                 config :   { \n                     headers :   { \n                         \"Content-Type\" :   \"application/json\" , \n                         \"Authorization\" :   `token #{github://user_token?scopes=repo}` , \n                     }, \n                     body :  JSON.stringify ( createRepoRequest ) \n                 } \n             } \n         }, \n         onSuccess :  new   DirectMessage ( \"Woot!\" ,   new   ChannelAddress ( \"#random\" )), \n         onError :  new   DirectMessage ( \"Un oh\" ,   new   ChannelAddress ( \"#random\" )) \n     }  )    The plan above instructs the Rug Runtime to invoke the  http  Rug Function,\npassing all the  parameters  to it, and sending appropriate messages to the #random  channel  onSuccess  or  onError .  To use a Rug Function from an Event or Command Handler, its archive\u2019s\ncoordinates must be present in the  .atomist.extensions  section of\nthe Rug project\u2019s  package.json .   Security  All Rug Function archives must be signed by Atomist and be explicitly\nwhitelisted in the Atomist service. Otherwise, the execution of the invoking\nhandler will be aborted.   Secrets  can also be passed to Rug Functions, but currently this is only supported\nfor Command Handlers.  The special  #{<secret path>}  notation used above is a way of injecting the value\nof a secret (in this case, a GitHub token with  repo  scope) in to the parameters\nto a function via string filtering. Rug Functions can also be  annotated \nso that if the secrets required are known in advance, we don\u2019t need to use paramter\nfiltering.  The following Rug Function archives available:   rug-function-http  - perform arbitrary HTTP requests  rug-functions-travis  - encrypt secrets, start/stop builds  rug-functions-aws  - perform s3 operations and so on    Creating your own Rug functions  Right now there is no support for user-created Rug functions. Please get in\ntouch by joining our  Slack team  if you need one\nthat doesn\u2019t already exist.",
            "title": "Rug Functions"
        },
        {
            "location": "/user-guide/rug/command-handlers/#secrets",
            "text": "Secrets are pieces of sensitive information stored securely by Atomist. Secrets\nare used by  Rug Functions  to provide access\nto secured systems, such as the GitHub API.  Handlers that invoke Rug Functions that require secrets must use the @Secrets  decorator to declare to the Rug runtime that those\nsecrets will be required during the execution of the handler\u2019s CommandPlan:  ...  @Secrets ( \"github://user_token?scopes=repo,read:org\" )  class   CloseIssueCommand   implements   HandleCommand   { \n     //...  }   The  @Secrets  decorator takes a comma separate list of secret\npaths. The decorator provides enough context to the Atomist Bot such that it\ncan initiate the secure collection of the require secret data, such as a GitHub\ntoken collected via OAuth flow.   Confidentiality  All sensitive data stored by Atomist are encrypted at rest in Vault .   There are currently two types of secrets:   GitHub tokens: automatically collected by the Atomist Bot  \"github://user_token?scopes=repo\"  -  repo  scoped user token  \"github://team_token?scopes=repo\"  -  repo  scoped\nteam token Both user and team GitHub tokens require the scopes\nneeded by the  token  to be provided as a comma-separated list.    Generic Secrets: manual collection  \"secret://user?path=/some/secret\"  - generic user secret  \"secret://team?path=/some/secret\"  - generic team secret      Generic Secrets  These are currently only available for very specific and mostly internal use\ncases as we currently have no secure public mechanism for collecting and storing\nthem, though this is something we are hoping to support in the near future. They\nare mentioned here to avoid any confusion when seen in publically visible Handlers.",
            "title": "Secrets"
        },
        {
            "location": "/user-guide/rug/command-handlers/#response-handlers",
            "text": "A  Respond  object (declared using  { kind :   \"respond\" } )\nindicates the desire to handle the response to an Instruction using a ResponseHandler  object.  import   { \n     Parameter ,   ParseJson ,   ResponseHandler ,   Tags ,  }   from   \"@atomist/rug/operations/Decorators\" ;  import   { \n     ChannelAddress ,   DirectedMessage ,   EventPlan ,   HandlerContext , \n     HandleResponse ,   Response ,   ResponseMessage ,  }   from   \"@atomist/rug/operations/Handlers\" ;  @ResponseHandler ( \"GenericSuccessHandler\" ,   \"displays a success message in chat\" )  @Tags ( \"success\" )  class   GenericSuccessHandler   implements   HandleResponse < any >   { \n\n     @Parameter ({   description :   \"Success msg\" ,   pattern :   \"@any\"   }) \n     public   msg :  string ; \n\n     public   handle (   @ParseJson   response :  Response < any > ) :   EventPlan   { \n         const   rand   =   new   ChannelAddress ( \"#random\" ); \n         const   result   =   ` ${ this . msg } :  ${ response . body . status } ` ; \n         return   new   EventPlan (). add ( new   DirectedMessage ( result ,   rand )); \n     }  }   Response handlers are declared with the  ResponseHandler  decorator\nand the class must implement the handle ( response :  Response < T > ) :   EventPlan   |   CommandPlan  method of the HandleResponse < T >  interface. When the handler receives a JSON\npayload, you can benefit from automatic JSON deserialization into an object by\ndecorating the response parameter with the  @ParseJson  decorator,\nfor example  handle ( @ParseJson   response :  Response < T > ) :   CommandPlan .  Response Handlers must also return a plan, just like any handler. However, they\nmust return the appropriate type of plan for the execution chain in which they\nrespond. So for an  Event Handler  they must\nreturn an  EventPlan , and for a  Command Handler \nthey must return a  CommandPlan .   It\u2019s all asynchronous  It is important to appreciate that because handlers return plans,\nthe actions declared in that plan are executed asynchronously. In other\nwords, plans are just data the Rug runtime knows how to interpret but your\nhandler cannot invoke those Rugs directly. So it\u2019s not safe to make\nassumptions about when instructions in a plan will be run, although\nit is fair to say that the Atomist platform will do its best to apply them\nas soon as possible.",
            "title": "Response Handlers"
        },
        {
            "location": "/user-guide/rug/editors/",
            "text": "The most common task performed on a daily basis is to change the code of a\nproject. Those updates can target a single file but can also refer to many\nresources.\n\n\nRug editors automate updates, from the simplest to most complex.\n\n\nAnatomy of an Editor\n\u00b6\n\n\nAssume our team has an existing Spring Boot Rest project cloned or copied/pasted\nfrom in other projects. These manual actions are brittle at best and usually\nends up with team members wondering what they did wrong.\n\n\nLet\u2019s suppose however that project is already a Rug project, it would still\nbe a running Spring Boot project in its own right. Here is such a project:\n\n\n~/workspace/spring-boot-rest-basic\n\n\n    \u251c\u2500\u2500 .atomist\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 editors\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 NewSpringBootService.ts\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 NewSpringBootService.feature\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \u2514\u2500\u2500 Steps.ts\n\n\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json\n\n\n    \u251c\u2500\u2500 .atomist.yml\n\n\n    \u251c\u2500\u2500 .gitignore\n\n\n    \u251c\u2500\u2500 pom.xml\n\n\n    \u251c\u2500\u2500 .project\n\n\n    \u251c\u2500\u2500 README.md\n\n\n    \u251c\u2500\u2500 src\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 main\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 company\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 HomeController.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 MyRestServiceApplication.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 MyRestServiceConfiguration.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 application.properties\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 logback.xml\n\n\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\n\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 java\n\n\n    \u2502\u00a0\u00a0         \u2514\u2500\u2500 com\n\n\n    \u2502\u00a0\u00a0             \u2514\u2500\u2500 company\n\n\n    \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceApplicationTests.java\n\n\n    \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceOutOfContainerIntegrationTests.java\n\n\n    \u2502\u00a0\u00a0                 \u2514\u2500\u2500 MyRestServiceWebIntegrationTests.java\n\n\n    \u2514\u2500\u2500 .travis.yml\n\n\n\n\n\nHowever, rather than copying bits and pieces, the team could codify the\ndevelopment automation tasks into Rug editors that could be tested and\nevolved as the team would need it.\n\n\nEditors live in the \n.atomist/editors\n directory and their tests in the\n\n.atomist/tests\n directory. The \nNewSpringBootService.ts\n is the generator from\nthe \nRug generator section\n, editors live alongside it deminstrating we can\ncodify not only the inception of a project but its evolution as well.\n\n\nLet\u2019s go through one of those Rug editors in the next section.\n\n\nA Basic Editor\n\u00b6\n\n\nLet\u2019s suppose we need to automate the task of adding a controller to a Spring\nBoot service. That controller will respond to requests for the \n/calendar\n\nendpoint.\n\n\nBefore we can dive into the editor itself, let\u2019s review what\u2019s needed here:\n\n\n\n\nAdd a new class under \nsrc/main/java/com/company\n\n\nDecorate that class with the \n@RestController\n and\n  \n@RequestMapping\n decorators\n\n\nIndicate the endpoint at which this controller takes place: \n/calendar\n\n\n\n\nThese tasks are what we are going to encode in a Rug editor.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nimport\n \n{\n \nEditProject\n \n}\n \nfrom\n \n'@atomist/rug/operations/ProjectEditor'\n;\n\n\nimport\n \n{\n \nEditor\n,\n \nParameter\n,\n \nTags\n \n}\n \nfrom\n \n'@atomist/rug/operations/Decorators'\n;\n\n\nimport\n \n{\n \nPattern\n \n}\n \nfrom\n \n'@atomist/rug/operations/RugOperation'\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n'@atomist/rug/model/Project'\n;\n\n\n\n@Editor\n(\n\"AddSpringBootRestController\"\n,\n \n\"adds a new REST controller to a Spring Boot project\"\n)\n\n\n@Tags\n(\n\"spring\"\n,\n \n\"spring boot\"\n,\n \n\"rest\"\n)\n\n\nexport\n \nclass\n \nAddSpringBootRestController\n \nimplements\n \nEditProject\n \n{\n\n\n    \n@Parameter\n({\n\n        \ndisplayName\n:\n \n\"Class Name\"\n,\n\n        \ndescription\n:\n \n\"name for the controller class\"\n,\n\n        \npattern\n: \nPattern.java_class\n,\n\n        \nvalidInput\n:\n \n\"a valid Java class name\"\n,\n\n        \nminLength\n: \n1\n,\n\n        \nmaxLength\n: \n50\n\n    \n})\n\n    \ncontroller_class_name\n: \nstring\n;\n\n\n    \n@Parameter\n({\n\n        \ndisplayName\n:\n \n\"Path at which the request will be served\"\n,\n\n        \ndescription\n:\n \n\"REST endpoint\"\n,\n\n        \npattern\n: \nPattern.any\n,\n\n        \nvalidInput\n:\n \n\"a valid HTTP path\"\n,\n\n        \nminLength\n: \n1\n,\n\n    \n})\n\n    \nendpoint\n: \nstring\n;\n\n\n    \nedit\n(\nproject\n: \nProject\n)\n \n{\n\n\n        \nconst\n \nrawJavaFileContent\n \n=\n \n`package com.company;\n\n\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n\nimport org.springframework.web.bind.annotation.RestController;\n\n\n\n@RestController\n\n\n@RequestMapping(value=\"\n${\nthis\n.\nendpoint\n}\n\")\n\n\npublic class \n${\nthis\n.\ncontroller_class_name\n}\nController {\n\n\n}`\n;\n\n\n        \nproject\n.\naddFile\n(\n`src/main/java/com/company/\n${\nthis\n.\ncontroller_class_name\n}\nController.java`\n,\n \nrawJavaFileContent\n);\n\n    \n}\n\n\n}\n\n\nexport\n \nconst\n \naddSpringBootRestController\n \n=\n \nnew\n \nAddSpringBootRestController\n();\n\n\n\n\n\n\n\nThe first few lines group the Rug typings our script will be using throughout\n(lines 1\u20134). Next, we declare our editor through TypeScript \ndecorators\n\n(line 6). The first argument of the \n@Editor\n decorator is the name\nof the editor. This the public visible and discoverable name of the Rug. This\nname, along with the editors group and repository, form the fully-qualified name\nof the editor. The second argument of the \n@Editor\n decorator is a\nshort description of the editor. The following line uses the\n\n@Tags\n decorator to apply some tags to our editor so people can\nsearch for it more easily. Using the \n@Tags\n decorator is optional\nbut highly recommended.\n\n\nWe then define the class which implements our editor (line 8). An editor\nimplements the \nEditProject\n interface. That interface requires the\n\nedit\n(\nProject\n)\n method to be defined (line 28). It is convention\nfor the editor and the class that implements it to have the same name.\n\n\nYou will likely want to customize your Rugs\u2019 input to tune their output\naccording to user-supplied values. Such customization is achieved through\nparameters that your editor must declare in the class via the\n\n@Parameter\n decorator. This decorator\nprovides all the metadata of the parameter whereas the decorated variable\ndeclaration provides its name and default value, if any. The\n\n@Parameter\n decorator accepts a single argument, a JavaScript\nobject. That object accepts \nproperties\n documented in the Rug\nconventions but, only the \npattern\n property is required. A pattern\nis an \nanchored\n regular expression that validates the input. Here we rely on\nthe \nPattern\n.\nany\n and \nPattern\n.\njava_class\n patterns\nbundled by Atomist in the TypeScript dependencies.\n\n\nThe \nedit\n method takes a single argument, a\n\nProject\n object. That object gives you access to the entire\nstructure and content of the project your editor is applied to. Use it to access\nand update the content of any resource in that project according to the goal of\nyour editor. You have the full power of TypeScript and the Rug programming model\nand [language extensions][langext] to achieve this.\n\n\nAs we can see, in this example, we simply create the content of the controller\nclass customizing it from the parameters before saving that content in the\nappropriate file in the project.\n\n\n\n\nTip\n\n\nIn a real Rug editor, you would want to also parameterize the package\npath as your users may have changed it in their own project.\n\n\n\n\nA Rug should always be accompanied by one or more \ntests\n. Here, this is what\na basic test could look like. First the feature descriving the test scenario\nfor that editor:\n\n\nFeature:\n Add a new REST Controller to a Spring Boot project\n\n\n\nScenario:\n A new controller class should be added\n\n\n Given \nan empty project\n\n\n \nWhen \nadding a new controller\n\n\n \nThen \nthe controller class should be created\n\n\n \nThen \nthe controller class has the supplied name\n\n\n \nThen \nthe controller class has the supplied endpoint\n\n\n\n\n\nThe implementation of such test goes into \n.atomist/tests/Steps.ts\n:\n\n\nimport\n \n{\n \nGiven\n,\n \nWhen\n,\n \nThen\n,\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\nimport\n \n{\n \nResult\n \n}\n \nfrom\n \n\"@atomist/rug/test/Result\"\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\n\nWhen\n(\n\"adding a new controller\"\n,\n \n(\np\n: \nProject\n,\n \nworld\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n  \nlet\n \ngenerator\n \n=\n \nworld\n.\ngenerator\n(\n\"NewSpringBootService\"\n);\n\n  \nworld\n.\ngenerateWith\n(\ngenerator\n,\n \n{\n\"service_class_name\"\n:\n \n\"CalendarService\"\n});\n\n\n  \nlet\n \neditor\n \n=\n \nworld\n.\neditor\n(\n\"AddSpringBootRestController\"\n);\n\n  \nworld\n.\neditWith\n(\neditor\n,\n \n{\n'endpoint'\n:\n \n'/calendar'\n,\n \n'controller_class_name'\n:\n \n'Calendar'\n})\n\n\n});\n\n\n\nThen\n(\n\"the controller class should be created\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfileExists\n(\n\"src/main/java/com/company/CalendarController.java\"\n)\n\n\n);\n\n\nThen\n(\n\"the controller class has the supplied name\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfindFile\n(\n\"src/main/java/com/company/CalendarController.java\"\n).\ncontains\n(\n\"CalendarController\"\n)\n\n\n);\n\n\nThen\n(\n\"the controller class has the supplied endpoint\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfindFile\n(\n\"src/main/java/com/company/CalendarController.java\"\n).\ncontains\n(\n\"/calendar\"\n)\n\n\n);\n\n\n\n\n\nSuch a test should pass when executed:\n\n\n$\n rug \ntest\n\n\nResolving dependencies for com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\nInvoking TypeScript Compiler on ts script sources\n\n\n  Created .atomist/tests/Steps.js.map\n\n\n  Created .atomist/tests/Steps.js\n\n\n  Created .atomist/editors/AddSpringBootRestController.js\n\n\n  Created .atomist/editors/AddSpringBootRestController.js.map\n\n\n  Created .atomist/editors/NewSpringBootService.js\n\n\n  Created .atomist/editors/NewSpringBootService.js.map\n\n\nProcessing script sources completed\n\n\nLoading com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\n  Executing feature Add a new REST Controller to a Spring Boot project\n\n\n    Executing test scenario A new controller class should be added\n\n\n  Creating project_name\n\n\n  Executing feature Creating new Spring Rest Service projects\n\n\n    Executing test scenario A default Spring Rest project structure should be generated\n\n\n  Creating project_name\n\n\nRunning tests in com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\n\nSuccessfully executed 2 of 2 tests: Test SUCCESS\n\n\n\n\n\nAlthough this editor is useful, if we stopped there, its users would still\nhave to implement the REST endpoints in that controller by hand. As Atomist\ncan navigate code as we much as filesystem, we certainly can add a new editor\nthat does just that. Here such an editor:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\nimport\n \n{\n \nEditProject\n \n}\n \nfrom\n \n'@atomist/rug/operations/ProjectEditor'\n;\n\n\nimport\n \n{\n \nEditor\n,\n \nParameter\n,\n \nTags\n \n}\n \nfrom\n \n'@atomist/rug/operations/Decorators'\n;\n\n\nimport\n \n{\n \nPattern\n \n}\n \nfrom\n \n'@atomist/rug/operations/RugOperation'\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n'@atomist/rug/model/Project'\n;\n\n\nimport\n \n{\n \nPathExpressionEngine\n,\n \nTextTreeNode\n \n}\n \nfrom\n \n'@atomist/rug/tree/PathExpression'\n;\n\n\n\n@Editor\n(\n\"AddSpringBootRestControllerRequestMapping\"\n,\n \n\"adds a new endpoint mapping to a REST controller\"\n)\n\n\n@Tags\n(\n\"spring\"\n,\n \n\"spring boot\"\n,\n \n\"rest\"\n)\n\n\nexport\n \nclass\n \nAddSpringBootRestControllerRequestMapping\n \nimplements\n \nEditProject\n \n{\n\n\n    \n@Parameter\n({\n\n        \ndisplayName\n:\n \n\"Controller Name\"\n,\n\n        \ndescription\n:\n \n\"name for the controller class\"\n,\n\n        \npattern\n: \nPattern.java_class\n,\n\n        \nvalidInput\n:\n \n\"a valid Java class name\"\n,\n\n        \nminLength\n: \n1\n,\n\n        \nmaxLength\n: \n50\n\n    \n})\n\n    \ncontroller_name\n: \nstring\n;\n\n\n    \n@Parameter\n({\n\n        \ndisplayName\n:\n \n\"Method Name\"\n,\n\n        \ndescription\n:\n \n\"name for the method to add\"\n,\n\n        \npattern\n: \nPattern.java_identifier\n,\n\n        \nvalidInput\n:\n \n\"a valid Java method name\"\n,\n\n        \nminLength\n: \n1\n,\n\n        \nmaxLength\n: \n50\n\n    \n})\n\n    \nmethod_name\n: \nstring\n;\n\n\n    \n@Parameter\n({\n\n        \ndisplayName\n:\n \n\"Path at which the request will be served under the controller's endpoint\"\n,\n\n        \ndescription\n:\n \n\"REST endpoint\"\n,\n\n        \npattern\n: \nPattern.any\n,\n\n        \nvalidInput\n:\n \n\"a valid HTTP path\"\n,\n\n        \nminLength\n: \n1\n,\n\n    \n})\n\n    \nendpoint\n: \nstring\n;\n\n\n    \nedit\n(\nproject\n: \nProject\n)\n \n{\n\n        \nlet\n \neng\n: \nPathExpressionEngine\n \n=\n \nproject\n.\ncontext\n().\npathExpressionEngine\n();\n\n\n        \neng\n.\nwith\n<\nTextTreeNode\n>\n(\nproject\n,\n \n`/src//File()[@name=\"\n${\nthis\n.\ncontroller_name\n}\n.java\"]/JavaFile()//classDeclaration`\n,\n \nf\n \n=>\n \n{\n\n            \nf\n.\nupdate\n(\n`@RequestMapping(value=\"/\n${\nthis\n.\nendpoint\n}\n\", method=RequestMethod.GET)\n\n\n    public String \n${\nthis\n.\nmethod_name\n}\n() {\n\n\n        throw new UnsupportedOperationException(\"No implemented\");\n\n\n    }`\n);\n\n        \n});\n\n    \n}\n\n\n}\n\n\nexport\n \nconst\n \naddSpringBootRestControllerRequestMapping\n \n=\n \nnew\n \nAddSpringBootRestControllerRequestMapping\n();\n\n\n\n\n\n\n\nThis editor follows the same structure as explained earlier, it\u2019s interesting\npart is its body which demonstrates the power of \npath expressions\n to\nquery note the filesystem but code structures as well. Let\u2019s deconstruct the\npath expression declared here:\n\n\n`/src//File()[@name=\"\n${\nthis\n.\ncontroller_name\n}\n.java\"]/JavaFile()//classDeclaration`\n\n\n\n\n\nStarting from the \nsrc\n top-level directory of the project, we search for the\nJava file the user targets via the editor\u2019s parameter\n\ncontroller_name\n. Once that file is found, we inform the Rug\nruntime to switch to parsing that file, using the \nJavaFile()\n language\nextension, so we can navigate its content through an AST-based tree model. The\n\n//classDeclaration\n segment tells the expression engine to look for all classes\nin that tree. Since we are in a Java file, we retrieve the only top-level class\nit contains.\n\n\n\n\nANTLR to the rescue\n\n\nThe Rug runtime relies on well-known \nANTLR grammars\n to parse\nlanguages like Java, C# or Python. The \n//classDeclaration\n segment is a\ndirect rule of the \nJava8 grammar\n. You do not need to install\nANTLR as it is provided by the Rug runtime.\n\n\n\n\nOnce we have found the class we are interested in updating, we can indeed add\nthe method\u2019s definition as per the user-supplied parameters. This changes is\nautomatically saved to disk and our class is now updated with the appropriate\nmethod.\n\n\nWe obviously tested that editor as explained above through a BDD feature and\nscenario which steps are implemented in \n.atomist/tests/Steps.ts\n.\n\n\nFeature:\n Add a new endpoint to a REST Controller in a Spring Boot project\n\n\n\nScenario:\n A new endpoint meyhod should be added\n\n\n Given \nan empty project\n\n\n \nWhen \nadding a new endpoint to a controller\n\n\n \nThen \nthe endpoint method should be created in the controller class\n\n\n\n\n\nimport\n \n{\n \nGiven\n,\n \nWhen\n,\n \nThen\n,\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\nimport\n \n{\n \nResult\n \n}\n \nfrom\n \n\"@atomist/rug/test/Result\"\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nFile\n \n}\n \nfrom\n \n\"@atomist/rug/model/File\"\n;\n\n\n \nWhen\n(\n\"adding a new endpoint to a controller\"\n,\n \n(\np\n: \nProject\n,\n \nworld\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n  \nlet\n \ngenerator\n \n=\n \nworld\n.\ngenerator\n(\n\"NewSpringBootService\"\n);\n\n  \nworld\n.\ngenerateWith\n(\ngenerator\n,\n \n{\n\"service_class_name\"\n:\n \n\"CalendarService\"\n});\n\n\n  \nlet\n \ncontroller\n \n=\n \nworld\n.\neditor\n(\n\"AddSpringBootRestController\"\n);\n\n  \nworld\n.\neditWith\n(\ncontroller\n,\n \n{\n'endpoint'\n:\n \n'/calendar'\n,\n \n'controller_class_name'\n:\n \n'Calendar'\n})\n\n\n  \nlet\n \neditor\n \n=\n \nworld\n.\neditor\n(\n\"AddSpringBootRestControllerRequestMapping\"\n);\n\n  \nworld\n.\neditWith\n(\neditor\n,\n \n{\n\n      \n'endpoint'\n:\n \n'/today'\n,\n\n      \n'method_name'\n:\n \n'getToday'\n,\n\n      \n'controller_name'\n:\n \n'CalendarController'\n\n    \n})\n\n\n});\n\n\n\nThen\n(\n\"the endpoint method should be created in the controller class\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nlet\n \nf\n: \nFile\n \n=\n \np\n.\nfindFile\n(\n\"src/main/java/com/company/CalendarController.java\"\n);\n\n    \nreturn\n \nf\n.\ncontains\n(\n\"/today\"\n)\n \n&&\n \nf\n.\ncontains\n(\n\"getToday\"\n);\n\n\n});\n\n\n\n\n\n\n\nCompose your Rugs!\n\n\nNotice how we compose by using the generator we declared in the\n\ngenerators\n section a well as our first editor described above. This is a\nwell-known convention when writing Rugs that we encourage you to follow.",
            "title": "Editors"
        },
        {
            "location": "/user-guide/rug/editors/#anatomy-of-an-editor",
            "text": "Assume our team has an existing Spring Boot Rest project cloned or copied/pasted\nfrom in other projects. These manual actions are brittle at best and usually\nends up with team members wondering what they did wrong.  Let\u2019s suppose however that project is already a Rug project, it would still\nbe a running Spring Boot project in its own right. Here is such a project:  ~/workspace/spring-boot-rest-basic      \u251c\u2500\u2500 .atomist      \u2502\u00a0\u00a0 \u251c\u2500\u2500 editors      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 NewSpringBootService.ts      \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore      \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json      \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 NewSpringBootService.feature      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \u2514\u2500\u2500 Steps.ts      \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json      \u251c\u2500\u2500 .atomist.yml      \u251c\u2500\u2500 .gitignore      \u251c\u2500\u2500 pom.xml      \u251c\u2500\u2500 .project      \u251c\u2500\u2500 README.md      \u251c\u2500\u2500 src      \u2502\u00a0\u00a0 \u251c\u2500\u2500 main      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 com      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 company      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 HomeController.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 MyRestServiceApplication.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 MyRestServiceConfiguration.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 application.properties      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 logback.xml      \u2502\u00a0\u00a0 \u2514\u2500\u2500 test      \u2502\u00a0\u00a0     \u2514\u2500\u2500 java      \u2502\u00a0\u00a0         \u2514\u2500\u2500 com      \u2502\u00a0\u00a0             \u2514\u2500\u2500 company      \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceApplicationTests.java      \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceOutOfContainerIntegrationTests.java      \u2502\u00a0\u00a0                 \u2514\u2500\u2500 MyRestServiceWebIntegrationTests.java      \u2514\u2500\u2500 .travis.yml   However, rather than copying bits and pieces, the team could codify the\ndevelopment automation tasks into Rug editors that could be tested and\nevolved as the team would need it.  Editors live in the  .atomist/editors  directory and their tests in the .atomist/tests  directory. The  NewSpringBootService.ts  is the generator from\nthe  Rug generator section , editors live alongside it deminstrating we can\ncodify not only the inception of a project but its evolution as well.  Let\u2019s go through one of those Rug editors in the next section.",
            "title": "Anatomy of an Editor"
        },
        {
            "location": "/user-guide/rug/editors/#a-basic-editor",
            "text": "Let\u2019s suppose we need to automate the task of adding a controller to a Spring\nBoot service. That controller will respond to requests for the  /calendar \nendpoint.  Before we can dive into the editor itself, let\u2019s review what\u2019s needed here:   Add a new class under  src/main/java/com/company  Decorate that class with the  @RestController  and\n   @RequestMapping  decorators  Indicate the endpoint at which this controller takes place:  /calendar   These tasks are what we are going to encode in a Rug editor.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 import   {   EditProject   }   from   '@atomist/rug/operations/ProjectEditor' ;  import   {   Editor ,   Parameter ,   Tags   }   from   '@atomist/rug/operations/Decorators' ;  import   {   Pattern   }   from   '@atomist/rug/operations/RugOperation' ;  import   {   Project   }   from   '@atomist/rug/model/Project' ;  @Editor ( \"AddSpringBootRestController\" ,   \"adds a new REST controller to a Spring Boot project\" )  @Tags ( \"spring\" ,   \"spring boot\" ,   \"rest\" )  export   class   AddSpringBootRestController   implements   EditProject   { \n\n     @Parameter ({ \n         displayName :   \"Class Name\" , \n         description :   \"name for the controller class\" , \n         pattern :  Pattern.java_class , \n         validInput :   \"a valid Java class name\" , \n         minLength :  1 , \n         maxLength :  50 \n     }) \n     controller_class_name :  string ; \n\n     @Parameter ({ \n         displayName :   \"Path at which the request will be served\" , \n         description :   \"REST endpoint\" , \n         pattern :  Pattern.any , \n         validInput :   \"a valid HTTP path\" , \n         minLength :  1 , \n     }) \n     endpoint :  string ; \n\n     edit ( project :  Project )   { \n\n         const   rawJavaFileContent   =   `package com.company;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RestController;  @RestController  @RequestMapping(value=\" ${ this . endpoint } \")  public class  ${ this . controller_class_name } Controller {  }` ; \n\n         project . addFile ( `src/main/java/com/company/ ${ this . controller_class_name } Controller.java` ,   rawJavaFileContent ); \n     }  }  export   const   addSpringBootRestController   =   new   AddSpringBootRestController ();    The first few lines group the Rug typings our script will be using throughout\n(lines 1\u20134). Next, we declare our editor through TypeScript  decorators \n(line 6). The first argument of the  @Editor  decorator is the name\nof the editor. This the public visible and discoverable name of the Rug. This\nname, along with the editors group and repository, form the fully-qualified name\nof the editor. The second argument of the  @Editor  decorator is a\nshort description of the editor. The following line uses the @Tags  decorator to apply some tags to our editor so people can\nsearch for it more easily. Using the  @Tags  decorator is optional\nbut highly recommended.  We then define the class which implements our editor (line 8). An editor\nimplements the  EditProject  interface. That interface requires the edit ( Project )  method to be defined (line 28). It is convention\nfor the editor and the class that implements it to have the same name.  You will likely want to customize your Rugs\u2019 input to tune their output\naccording to user-supplied values. Such customization is achieved through\nparameters that your editor must declare in the class via the @Parameter  decorator. This decorator\nprovides all the metadata of the parameter whereas the decorated variable\ndeclaration provides its name and default value, if any. The @Parameter  decorator accepts a single argument, a JavaScript\nobject. That object accepts  properties  documented in the Rug\nconventions but, only the  pattern  property is required. A pattern\nis an  anchored  regular expression that validates the input. Here we rely on\nthe  Pattern . any  and  Pattern . java_class  patterns\nbundled by Atomist in the TypeScript dependencies.  The  edit  method takes a single argument, a Project  object. That object gives you access to the entire\nstructure and content of the project your editor is applied to. Use it to access\nand update the content of any resource in that project according to the goal of\nyour editor. You have the full power of TypeScript and the Rug programming model\nand [language extensions][langext] to achieve this.  As we can see, in this example, we simply create the content of the controller\nclass customizing it from the parameters before saving that content in the\nappropriate file in the project.   Tip  In a real Rug editor, you would want to also parameterize the package\npath as your users may have changed it in their own project.   A Rug should always be accompanied by one or more  tests . Here, this is what\na basic test could look like. First the feature descriving the test scenario\nfor that editor:  Feature:  Add a new REST Controller to a Spring Boot project  Scenario:  A new controller class should be added   Given  an empty project    When  adding a new controller    Then  the controller class should be created    Then  the controller class has the supplied name    Then  the controller class has the supplied endpoint   The implementation of such test goes into  .atomist/tests/Steps.ts :  import   {   Given ,   When ,   Then ,   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  import   {   Result   }   from   \"@atomist/rug/test/Result\" ;  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  When ( \"adding a new controller\" ,   ( p :  Project ,   world :  ProjectScenarioWorld )   =>   { \n   let   generator   =   world . generator ( \"NewSpringBootService\" ); \n   world . generateWith ( generator ,   { \"service_class_name\" :   \"CalendarService\" }); \n\n   let   editor   =   world . editor ( \"AddSpringBootRestController\" ); \n   world . editWith ( editor ,   { 'endpoint' :   '/calendar' ,   'controller_class_name' :   'Calendar' })  });  Then ( \"the controller class should be created\" ,   ( p :  Project )   => \n     p . fileExists ( \"src/main/java/com/company/CalendarController.java\" )  );  Then ( \"the controller class has the supplied name\" ,   ( p :  Project )   => \n     p . findFile ( \"src/main/java/com/company/CalendarController.java\" ). contains ( \"CalendarController\" )  );  Then ( \"the controller class has the supplied endpoint\" ,   ( p :  Project )   => \n     p . findFile ( \"src/main/java/com/company/CalendarController.java\" ). contains ( \"/calendar\" )  );   Such a test should pass when executed:  $  rug  test  Resolving dependencies for com.company.rugs:spring-boot-service:0.13.0:local completed  Invoking TypeScript Compiler on ts script sources    Created .atomist/tests/Steps.js.map    Created .atomist/tests/Steps.js    Created .atomist/editors/AddSpringBootRestController.js    Created .atomist/editors/AddSpringBootRestController.js.map    Created .atomist/editors/NewSpringBootService.js    Created .atomist/editors/NewSpringBootService.js.map  Processing script sources completed  Loading com.company.rugs:spring-boot-service:0.13.0:local completed    Executing feature Add a new REST Controller to a Spring Boot project      Executing test scenario A new controller class should be added    Creating project_name    Executing feature Creating new Spring Rest Service projects      Executing test scenario A default Spring Rest project structure should be generated    Creating project_name  Running tests in com.company.rugs:spring-boot-service:0.13.0:local completed  Successfully executed 2 of 2 tests: Test SUCCESS   Although this editor is useful, if we stopped there, its users would still\nhave to implement the REST endpoints in that controller by hand. As Atomist\ncan navigate code as we much as filesystem, we certainly can add a new editor\nthat does just that. Here such an editor:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51 import   {   EditProject   }   from   '@atomist/rug/operations/ProjectEditor' ;  import   {   Editor ,   Parameter ,   Tags   }   from   '@atomist/rug/operations/Decorators' ;  import   {   Pattern   }   from   '@atomist/rug/operations/RugOperation' ;  import   {   Project   }   from   '@atomist/rug/model/Project' ;  import   {   PathExpressionEngine ,   TextTreeNode   }   from   '@atomist/rug/tree/PathExpression' ;  @Editor ( \"AddSpringBootRestControllerRequestMapping\" ,   \"adds a new endpoint mapping to a REST controller\" )  @Tags ( \"spring\" ,   \"spring boot\" ,   \"rest\" )  export   class   AddSpringBootRestControllerRequestMapping   implements   EditProject   { \n\n     @Parameter ({ \n         displayName :   \"Controller Name\" , \n         description :   \"name for the controller class\" , \n         pattern :  Pattern.java_class , \n         validInput :   \"a valid Java class name\" , \n         minLength :  1 , \n         maxLength :  50 \n     }) \n     controller_name :  string ; \n\n     @Parameter ({ \n         displayName :   \"Method Name\" , \n         description :   \"name for the method to add\" , \n         pattern :  Pattern.java_identifier , \n         validInput :   \"a valid Java method name\" , \n         minLength :  1 , \n         maxLength :  50 \n     }) \n     method_name :  string ; \n\n     @Parameter ({ \n         displayName :   \"Path at which the request will be served under the controller's endpoint\" , \n         description :   \"REST endpoint\" , \n         pattern :  Pattern.any , \n         validInput :   \"a valid HTTP path\" , \n         minLength :  1 , \n     }) \n     endpoint :  string ; \n\n     edit ( project :  Project )   { \n         let   eng :  PathExpressionEngine   =   project . context (). pathExpressionEngine (); \n\n         eng . with < TextTreeNode > ( project ,   `/src//File()[@name=\" ${ this . controller_name } .java\"]/JavaFile()//classDeclaration` ,   f   =>   { \n             f . update ( `@RequestMapping(value=\"/ ${ this . endpoint } \", method=RequestMethod.GET)      public String  ${ this . method_name } () {          throw new UnsupportedOperationException(\"No implemented\");      }` ); \n         }); \n     }  }  export   const   addSpringBootRestControllerRequestMapping   =   new   AddSpringBootRestControllerRequestMapping ();    This editor follows the same structure as explained earlier, it\u2019s interesting\npart is its body which demonstrates the power of  path expressions  to\nquery note the filesystem but code structures as well. Let\u2019s deconstruct the\npath expression declared here:  `/src//File()[@name=\" ${ this . controller_name } .java\"]/JavaFile()//classDeclaration`   Starting from the  src  top-level directory of the project, we search for the\nJava file the user targets via the editor\u2019s parameter controller_name . Once that file is found, we inform the Rug\nruntime to switch to parsing that file, using the  JavaFile()  language\nextension, so we can navigate its content through an AST-based tree model. The //classDeclaration  segment tells the expression engine to look for all classes\nin that tree. Since we are in a Java file, we retrieve the only top-level class\nit contains.   ANTLR to the rescue  The Rug runtime relies on well-known  ANTLR grammars  to parse\nlanguages like Java, C# or Python. The  //classDeclaration  segment is a\ndirect rule of the  Java8 grammar . You do not need to install\nANTLR as it is provided by the Rug runtime.   Once we have found the class we are interested in updating, we can indeed add\nthe method\u2019s definition as per the user-supplied parameters. This changes is\nautomatically saved to disk and our class is now updated with the appropriate\nmethod.  We obviously tested that editor as explained above through a BDD feature and\nscenario which steps are implemented in  .atomist/tests/Steps.ts .  Feature:  Add a new endpoint to a REST Controller in a Spring Boot project  Scenario:  A new endpoint meyhod should be added   Given  an empty project    When  adding a new endpoint to a controller    Then  the endpoint method should be created in the controller class   import   {   Given ,   When ,   Then ,   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  import   {   Result   }   from   \"@atomist/rug/test/Result\" ;  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   File   }   from   \"@atomist/rug/model/File\" ; \n\n  When ( \"adding a new endpoint to a controller\" ,   ( p :  Project ,   world :  ProjectScenarioWorld )   =>   { \n   let   generator   =   world . generator ( \"NewSpringBootService\" ); \n   world . generateWith ( generator ,   { \"service_class_name\" :   \"CalendarService\" }); \n\n   let   controller   =   world . editor ( \"AddSpringBootRestController\" ); \n   world . editWith ( controller ,   { 'endpoint' :   '/calendar' ,   'controller_class_name' :   'Calendar' }) \n\n   let   editor   =   world . editor ( \"AddSpringBootRestControllerRequestMapping\" ); \n   world . editWith ( editor ,   { \n       'endpoint' :   '/today' , \n       'method_name' :   'getToday' , \n       'controller_name' :   'CalendarController' \n     })  });  Then ( \"the endpoint method should be created in the controller class\" ,   ( p :  Project )   =>   { \n     let   f :  File   =   p . findFile ( \"src/main/java/com/company/CalendarController.java\" ); \n     return   f . contains ( \"/today\" )   &&   f . contains ( \"getToday\" );  });    Compose your Rugs!  Notice how we compose by using the generator we declared in the generators  section a well as our first editor described above. This is a\nwell-known convention when writing Rugs that we encourage you to follow.",
            "title": "A Basic Editor"
        },
        {
            "location": "/user-guide/rug/generators/",
            "text": "Rug generators create new projects from an existing source project,\nwhere the source project itself is a working project in its own right.\nA Rug generator has two major components: the \u201cmodel\u201d project and the\nmodifications needed to transform the model project into a new\nproject.  The model project can be any working project you want to use\nto create new projects.  The transformations are encoded in the Rug\ngenerator script located under the project\u2019s \n.atomist\n directory.\nUsing these components, a generator does the followings:\n\n\n\n\nCopy the content of its host project, \n.atomist\n directory\n    (and anything listed in \n.atomist/ignore\n)\n    excluded, into the new target directory\n\n\nRuns the generator\u2019s \npopulate\n function against the contents of\n    target directory\n\n\n\n\nLet\u2019s look more closely at what makes a project a Rug generator.\n\n\nAnatomy of a Generator\n\u00b6\n\n\nSuppose we have a model project our team clones to quickly get the skeleton of a\n\nSpring Bot Rest Service\n.  The contents of the model project are\nthe following.\n\n\n~/workspace/spring-boot-rest-basic\n\n\n    \u251c\u2500\u2500 .gitignore\n\n\n    \u251c\u2500\u2500 pom.xml\n\n\n    \u251c\u2500\u2500 README.md\n\n\n    \u251c\u2500\u2500 src\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 main\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 company\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 HomeController.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 MyRestServiceApplication.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 MyRestServiceConfiguration.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 application.properties\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 logback.xml\n\n\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\n\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 java\n\n\n    \u2502\u00a0\u00a0         \u2514\u2500\u2500 com\n\n\n    \u2502\u00a0\u00a0             \u2514\u2500\u2500 company\n\n\n    \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceApplicationTests.java\n\n\n    \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceOutOfContainerIntegrationTests.java\n\n\n    \u2502\u00a0\u00a0                 \u2514\u2500\u2500 MyRestServiceWebIntegrationTests.java\n\n\n\n\n\nTo convert out model project into a \nRug generator\n, we can use the\n\nConvertExistingProjectToGenerator\n Rug editor in \nrug-editors\n to\nadd all the necessary directories and files:\n\n\n$\n rug edit atomist-rugs:rug-editors:ConvertExistingProjectToGenerator \n\\\n\n    \narchive_name\n=\nspring-boot-service \n\\\n\n    \ngroup_id\n=\ncompany-rugs \n\\\n\n    \nversion\n=\n0\n.13.0 \n\\\n\n    \ngenerator_name\n=\nNewSpringBootService \n\\\n\n    \ndescription\n=\n\"Rug generator for a Spring Boot REST service\"\n\n\nProcessing dependencies\n\n\n  Downloading atomist-rugs/rug-editors/maven-metadata.xml \u2190 rugs (740 bytes) succeeded\n\n\n  Downloading atomist-rugs/rug-editors/maven-metadata.xml \u2190 global (740 bytes) succeeded\n\n\n  Downloading atomist-rugs/rug-editors/0.14.0/rug-editors-0.14.0.pom \u2190 rugs (635 bytes) succeeded\n\n\n  Downloading atomist-rugs/rug-editors/0.14.0/rug-editors-0.14.0-metadata.json \u2190 rugs (14 kb) succeeded\n\n\n  Downloading atomist-rugs/rug-editors/0.14.0/rug-editors-0.14.0.zip \u2190 rugs (194 kb) succeeded\n\n\nResolving dependencies for atomist-rugs:rug-editors:latest completed\n\n\nLoading atomist-rugs:rug-editors:0.14.0 into runtime completed\n\n\n  TypeScript files added, run `cd .atomist && npm install`\n\n\n\nRunning editor ConvertExistingProjectToGenerator of atomist-rugs:rug-editors:0.14.0 completed\n\n\n\n\u2192 Project\n\n\n  ~/workspace/spring-boot-rest-basic (14 kb in 20 files)\n\n\n\n\u2192 Changes\n\n\n  \u251c\u2500\u2500 .atomist/package.json created (57 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/tsconfig.json created (627 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/.gitignore created (27 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts created (602 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/tests/NewSpringBootService.rt created (153 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts updated (580 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts updated (583 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts updated (584 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/tests/NewSpringBootService.rt updated (155 bytes)\n\n\n  \u251c\u2500\u2500 .atomist/tests/NewSpringBootService.rt updated (880 bytes)\n\n\n  \u2514\u2500\u2500 .atomist.yml created (2 kb)\n\n\n\n\n\nThe \ngroup_id\n and \narchive_name\n parameters, coupled with the name of the Rug\ngenerator, define the fully-qualified name of the \nRug archive\n (the\npublished package of a Rug).\n\n\nOnce this is completed, the project should look like this:\n\n\n~/workspace/spring-boot-rest-basic\n\n\n    \u251c\u2500\u2500 .atomist\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 editors\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 NewSpringBootService.ts\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 NewSpringBootService.feature\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \u2514\u2500\u2500 Steps.ts\n\n\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json\n\n\n    \u251c\u2500\u2500 .atomist.yml\n\n\n    \u251c\u2500\u2500 .gitignore\n\n\n    \u251c\u2500\u2500 pom.xml\n\n\n    \u251c\u2500\u2500 .project\n\n\n    \u251c\u2500\u2500 README.md\n\n\n    \u251c\u2500\u2500 src\n\n\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 main\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 company\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 HomeController.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 MyRestServiceApplication.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 MyRestServiceConfiguration.java\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 application.properties\n\n\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 logback.xml\n\n\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\n\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 java\n\n\n    \u2502\u00a0\u00a0         \u2514\u2500\u2500 com\n\n\n    \u2502\u00a0\u00a0             \u2514\u2500\u2500 company\n\n\n    \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceApplicationTests.java\n\n\n    \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceOutOfContainerIntegrationTests.java\n\n\n    \u2502\u00a0\u00a0                 \u2514\u2500\u2500 MyRestServiceWebIntegrationTests.java\n\n\n\n\n\nThe \n.atomist\n directory contains a metadata file, \npackage.json\n,\ndefining characteristics of the project and declaring \nTypeScript\n\ndependencies, and has the Rug generator script and its associated test\nin appropriate subdirectories.\n\n\n\n\nBecause all of the Atomist files are hidden under the \n.atomist\n\ndirectory, our generator project is still a fully functioning,\nperfectly valid Spring Boot project.\n\n\n\n\nLet\u2019s take a close look at the Rug generator script.\n\n\nA Basic Generator Script\n\u00b6\n\n\nThe generator script\u2019s \npopulate\n method is invoked after\nthe model project\u2019s files have been copied to the target project.  The default\ncontents of the generator script we added above look like the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nimport\n \n{\n \nPopulateProject\n \n}\n \nfrom\n \n'@atomist/rug/operations/ProjectGenerator'\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n'@atomist/rug/model/Project'\n;\n\n\nimport\n \n{\n \nPattern\n \n}\n \nfrom\n \n'@atomist/rug/operations/RugOperation'\n;\n\n\nimport\n \n{\n \nGenerator\n,\n \nParameter\n,\n \nTags\n \n}\n \nfrom\n \n'@atomist/rug/operations/Decorators'\n;\n\n\n\n@Generator\n(\n\"NewSpringBootService\"\n,\n \n\"Rug project for Spring Rest Services\"\n)\n\n\n@Tags\n(\n\"documentation\"\n)\n\n\nexport\n \nclass\n \nNewSpringBootService\n \nimplements\n \nPopulateProject\n \n{\n\n\n    \npopulate\n(\nproject\n: \nProject\n)\n \n{\n\n        \nconsole\n.\nlog\n(\n`Creating \n${\nproject\n.\nname\n}\n`\n);\n\n    \n}\n\n\n}\n\n\n\nexport\n \nconst\n \nnewSpringBootService\n \n=\n \nnew\n \nNewSpringBootService\n();\n\n\n\n\n\n\n\nAfter importing the TypeScript Rug typings for the elements we will be\nusing (lines 1\u20134), we use a \ndecorator\n to declare the\nfollowing class a generator (line 6).  The first argument to the\n\n@Generator\n decorator is the name of the generator.\nThis is the externally visible and discoverable name of the Rug.  This\nname, along with the generators group and repository, form the\nfully-qualified name of the generator.  The second argument to the\n\n@Generator\n decorator is a brief description of the\ngenerator.  On line 7 we use the \n@Tags\n decorator to\napply some tags to our generator so people can search for it more\neasily.  Using the \n@Tags\n decorator is optional but\nhighly recommended.\n\n\nWe define the class that will implement our generator on line 8.  A\ngenerator implements the \nPopulateProject\n interface.\nThis interface requires the \npopulate\n(\nProject\n)\n method to\nbe defined, which we do on line 10 (more on that below).  It is\nconvention for the generator and the class that implements it to have\nthe same name.\n\n\nIn the last line of the generator script we export an instance of that\ngenerator to make it visible to the Rug runtime when it executed (line 15).\nLike the generator class name, the name of the \nconst\n\ndoes not matter, but it is convention to use the generator/class name,\nlower-casing the first letter.\n\n\nAs explained earlier, a generator copies the content of the project where it\nlives into a target directory before applying changes. The definition of our\ngenerator currently performs only the copy (this is done automatically for us).\nLet\u2019s now amend the generator to modify the copied contents, for example to\nchange the name of the copied class. An action users would likely do manually.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nimport\n \n{\n \nPopulateProject\n \n}\n \nfrom\n \n'@atomist/rug/operations/ProjectGenerator'\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n'@atomist/rug/model/Project'\n;\n\n\nimport\n \n{\n \nFile\n \n}\n \nfrom\n \n'@atomist/rug/model/File'\n;\n\n\nimport\n \n{\n \nPattern\n \n}\n \nfrom\n \n'@atomist/rug/operations/RugOperation'\n;\n\n\nimport\n \n{\n \nGenerator\n,\n \nParameter\n,\n \nTags\n \n}\n \nfrom\n \n'@atomist/rug/operations/Decorators'\n;\n\n\nimport\n \n{\n \nPathExpressionEngine\n \n}\n \nfrom\n \n'@atomist/rug/tree/PathExpression'\n;\n\n\n\n\n@Generator\n(\n\"NewSpringBootService\"\n,\n \n\"Rug project for Spring Rest Services\"\n)\n\n\n@Tags\n(\n\"documentation\"\n)\n\n\nexport\n \nclass\n \nNewSpringBootService\n \nimplements\n \nPopulateProject\n \n{\n\n\n    \n@Parameter\n({\n\n        \ndisplayName\n:\n \n\"Class Name\"\n,\n\n        \ndescription\n:\n \n\"name for the service class\"\n,\n\n        \npattern\n: \nPattern.java_class\n,\n\n        \nvalidInput\n:\n \n\"a valid Java class name, which contains only alphanumeric characters, $ and _ and does not start with a number\"\n,\n\n        \nminLength\n: \n1\n,\n\n        \nmaxLength\n: \n50\n,\n\n        \nrequired\n: \nfalse\n\n    \n})\n\n    \nservice_class_name\n: \nstring\n;\n\n\n    \npopulate\n(\nproject\n: \nProject\n)\n \n{\n\n        \nconsole\n.\nlog\n(\n`Creating \n${\nproject\n.\nname\n}\n`\n);\n\n\n\n        \nlet\n \neng\n: \nPathExpressionEngine\n \n=\n \nproject\n.\ncontext\n.\npathExpressionEngine\n\n\n        \neng\n.\nwith\n<\nFile\n>\n(\nproject\n,\n \n'/src//File()[contains(@name, \"MyRestService\")]'\n,\n \nf\n \n=>\n \n{\n\n\n            \nf\n.\nreplace\n(\n\"MyRestService\"\n,\n \nthis\n.\nservice_class_name\n);\n\n\n            \nf\n.\nsetPath\n(\nf\n.\npath\n.\nreplace\n(\n\"MyRestService\"\n,\n \nthis\n.\nservice_class_name\n));\n\n\n        \n});\n\n\n    \n}\n\n\n}\n\n\n\nexport\n \nconst\n \nnewSpringBootService\n \n=\n \nnew\n \nNewSpringBootService\n();\n\n\n\n\n\n\n\nRugs, like typical methods, often take parameters to customize their\nbehavior.  Generators have a required parameter: the name of the\nproject that will be generated.  The project name parameter is\nautomatically defined for a generate.  All other parameters used by\nthe generator must be declared.  Parameters are declared using the\n\n@Parameter\n decorator (line 10).  The \n@Parameter\n decorator provides the metadata for the parameter while\nthe subsequent instance variable declaration provides the name and\ndefault value, if any.  The \n@Parameter\n decorator\naccepts a single argument, a JavaScript object.  The JavaScript object\npassed to \n@Parameter\n accepts all of the property names\nshown above, but only \npattern\n is mandatory.  The \npattern\n property\nprovides an anchored regular expression used to validate user input.\nHere we use one the Atomist pre-defined \nPattern\ns (line\n13).  Despite the fact that the other \n@Parameter\n\nproperties are option, it is highly recommended to provide them to\nhelp consumers of your generator.\n\n\nThe \npopulate\n method takes a single argument, a\n\nProject\n object.  The \nProject\n provided to\nthis method contains the contents of the generated project, i.e., all\nthe files copied from the generator project.  Using this object, you\ncan alter the exact copy of the original project as appropriate so the\nresult is the new project with the desired contents.  To effect your\ndesired changes, you have the power of TypeScript and the Rug\nprogramming model.\n\n\nIn that regards, as Atomist comprehends filesystem and code structure, the Rug\nprogramming model offers a powerful mechanism to make the above example a lot\nless brittle through \npath expressions\n. In this generator script, we query\nthe filesystem for all files containing a specific token in their names\n(line 27). Then for each one of these files, we replace its content (line 28)\nand move it to different path (line 29).\n\n\nRugs should be tested as any other pieces of software, Rug and its runtime\nnatively supports a \nBDD-centric testing approach\n, based on the\nGherkin DSL.\n\n\nThe test for our generator could be described as follows in\n\n.atomist/tests/NewSpringBootService.feature\n:\n\n\nFeature:\n Creating new Spring Rest Service projects\n\n\n\nScenario:\n A default Spring Rest project structure should be generated\n\n\n Given \nan empty project\n\n\n\n \nWhen \nrunning the Spring Boot Service generator\n\n\n\n \nThen \nthe name of the application file is changed\n\n\n \nThen \nthe name of the configuration file is changed\n\n\n \nThen \nthe name of the application tests file is changed\n\n\n \nThen \nthe name of the integration tests file is changed\n\n\n \nThen \nthe name of the web integration tests file is changed\n\n\n\n \nThen \nthe name of the class in the application file is changed\n\n\n \nThen \nthe name of the class in the configuration file is changed\n\n\n \nThen \nthe name of the class in the application tests file is changed\n\n\n \nThen \nthe name of the class in the integration tests file is changed\n\n\n \nThen \nthe name of the class in the web integration tests is changed\n\n\n\n\n\nImplemented by the steps in \n.atomist/tests/Steps.ts\n file:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nimport\n \n{\n \nGiven\n,\n \nWhen\n,\n \nThen\n,\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\nimport\n \n{\n \nResult\n \n}\n \nfrom\n \n\"@atomist/rug/test/Result\"\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\n\nGiven\n(\n\"an empty project\"\n,\n \np\n \n=>\n \n{})\n\n\n\nWhen\n(\n\"running the Spring Boot Service generator\"\n,\n \n(\np\n: \nProject\n,\n \nworld\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n  \nlet\n \ngenerator\n \n=\n \nworld\n.\ngenerator\n(\n\"NewSpringBootService\"\n);\n\n  \nworld\n.\ngenerateWith\n(\ngenerator\n,\n \n{\n\"service_class_name\"\n:\n \n\"CalendarService\"\n});\n\n\n})\n\n\n\nThen\n(\n\"the name of the application file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfileExists\n(\n\"src/main/java/com/company/CalendarServiceApplication.java\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the configuration file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfileExists\n(\n\"src/main/java/com/company/CalendarServiceConfiguration.java\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the application tests file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfileExists\n(\n\"src/test/java/com/company/CalendarServiceApplicationTests.java\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the integration tests file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfileExists\n(\n\"src/test/java/com/company/CalendarServiceOutOfContainerIntegrationTests.java\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the web integration tests file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfileExists\n(\n\"src/test/java/com/company/CalendarServiceWebIntegrationTests.java\"\n)\n\n\n)\n\n\n\nThen\n(\n\"the name of the class in the application file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfindFile\n(\n\"src/main/java/com/company/CalendarServiceApplication.java\"\n).\ncontains\n(\n\"CalendarServiceApplication\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the class in the configuration file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfindFile\n(\n\"src/main/java/com/company/CalendarServiceConfiguration.java\"\n).\ncontains\n(\n\"CalendarServiceConfiguration\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the class in the application tests file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfindFile\n(\n\"src/test/java/com/company/CalendarServiceApplicationTests.java\"\n).\ncontains\n(\n\"CalendarServiceApplicationTests\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the class in the integration tests file is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfindFile\n(\n\"src/test/java/com/company/CalendarServiceOutOfContainerIntegrationTests.java\"\n).\ncontains\n(\n\"CalendarServiceOutOfContainerIntegrationTests\"\n)\n\n\n)\n\n\nThen\n(\n\"the name of the class in the web integration tests is changed\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n\n    \np\n.\nfindFile\n(\n\"src/test/java/com/company/CalendarServiceWebIntegrationTests.java\"\n).\ncontains\n(\n\"CalendarServiceWebIntegrationTests\"\n)\n\n\n)\n\n\n\n\n\n\n\nIf you\u2019re not familiar with this approach, the\n\n.atomist/tests/NewSpringBootService.feature\n describes our tests in a set of\nhypotheses and expectations. All those steps are implemented in the\n\n.atomist/tests/Steps.ts\n file which is executed when the test is run:\n\n\n$\n rug \ntest\n\n\nResolving dependencies for com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\nInvoking TypeScript Compiler on ts script sources\n\n\n  Created .atomist/tests/Steps.js.map\n\n\n  Created .atomist/tests/Steps.js\n\n\n  Created .atomist/editors/NewSpringBootService.js.map\n\n\n  Created .atomist/editors/NewSpringBootService.js\n\n\nProcessing script sources completed\n\n\nLoading com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\n  Executing feature Creating new Spring Rest Service projects\n\n\n    Executing test scenario A default Spring Rest project structure should be generated\n\n\n  Creating project_name\n\n\nRunning tests in com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\n\nSuccessfully executed 1 of 1 test: Test SUCCESS\n\n\n\n\n\nAssuming we change one of the hypotheses to make it fail, \nrug\n would notify us\nwith a relevant error message:\n\n\n$\n rug \ntest\n\n\nResolving dependencies for com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\nInvoking TypeScript Compiler on ts script sources\n\n\n  Created .atomist/tests/Steps.js.map\n\n\n  Created .atomist/tests/Steps.js\n\n\n  Created .atomist/editors/NewSpringBootService.js\n\n\n  Created .atomist/editors/NewSpringBootService.js.map\n\n\nProcessing script sources completed\n\n\nLoading com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\n  Executing feature Creating new Spring Rest Service projects\n\n\n    Executing test scenario A default Spring Rest project structure should be generated\n\n\n  Creating project_name\n\n\nRunning tests in com.company.rugs:spring-boot-service:0.13.0:local completed\n\n\n\n\u2192 Test Report\n\n\n  Failures\n\n\n  \u2514\u2500\u252c Creating new Spring Rest Service projects\n\n\n    \u2514\u2500\u252c A default Spring Rest project structure should be generated\n\n\n      \u251c\u2500\u252c the name of the application file is changed: Failed\n\n\n      | \u2514\u2500\u2500 function (p) {\n\n\n    return p.fileExists(\"src/main/java/com/company/CalndarServiceApplication.java\");\n\n\n}\n\n\n      \u251c\u2500\u2500 the name of the application tests file is changed: Passed\n\n\n      \u251c\u2500\u2500 the name of the class in the application file is changed: Passed\n\n\n      \u251c\u2500\u2500 the name of the class in the application tests file is changed: Passed\n\n\n      \u251c\u2500\u2500 the name of the class in the configuration file is changed: Passed\n\n\n      \u251c\u2500\u2500 the name of the class in the integration tests file is changed: Passed\n\n\n      \u251c\u2500\u2500 the name of the class in the web integration tests is changed: Passed\n\n\n      \u251c\u2500\u2500 the name of the configuration file is changed: Passed\n\n\n      \u251c\u2500\u2500 the name of the integration tests file is changed: Passed\n\n\n      \u2514\u2500\u2500 the name of the web integration tests file is changed: Passed\n\n\n\nUnsuccessfully executed 1 of 1 test: Test FAILURE\n\n\n\n\n\nAs you can see, Rug generator scripts are simple functions that apply\nchanges against a freshly copy of your its content. This changes may be\nparametarized to tailor the result to the user\u2019s expectations. Finally,\nfollowing a test-driven approach, generators can be quickly validated before\nbeing released.",
            "title": "Generators"
        },
        {
            "location": "/user-guide/rug/generators/#anatomy-of-a-generator",
            "text": "Suppose we have a model project our team clones to quickly get the skeleton of a Spring Bot Rest Service .  The contents of the model project are\nthe following.  ~/workspace/spring-boot-rest-basic      \u251c\u2500\u2500 .gitignore      \u251c\u2500\u2500 pom.xml      \u251c\u2500\u2500 README.md      \u251c\u2500\u2500 src      \u2502\u00a0\u00a0 \u251c\u2500\u2500 main      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 com      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 company      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 HomeController.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 MyRestServiceApplication.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 MyRestServiceConfiguration.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 application.properties      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 logback.xml      \u2502\u00a0\u00a0 \u2514\u2500\u2500 test      \u2502\u00a0\u00a0     \u2514\u2500\u2500 java      \u2502\u00a0\u00a0         \u2514\u2500\u2500 com      \u2502\u00a0\u00a0             \u2514\u2500\u2500 company      \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceApplicationTests.java      \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceOutOfContainerIntegrationTests.java      \u2502\u00a0\u00a0                 \u2514\u2500\u2500 MyRestServiceWebIntegrationTests.java   To convert out model project into a  Rug generator , we can use the ConvertExistingProjectToGenerator  Rug editor in  rug-editors  to\nadd all the necessary directories and files:  $  rug edit atomist-rugs:rug-editors:ConvertExistingProjectToGenerator  \\ \n     archive_name = spring-boot-service  \\ \n     group_id = company-rugs  \\ \n     version = 0 .13.0  \\ \n     generator_name = NewSpringBootService  \\ \n     description = \"Rug generator for a Spring Boot REST service\"  Processing dependencies    Downloading atomist-rugs/rug-editors/maven-metadata.xml \u2190 rugs (740 bytes) succeeded    Downloading atomist-rugs/rug-editors/maven-metadata.xml \u2190 global (740 bytes) succeeded    Downloading atomist-rugs/rug-editors/0.14.0/rug-editors-0.14.0.pom \u2190 rugs (635 bytes) succeeded    Downloading atomist-rugs/rug-editors/0.14.0/rug-editors-0.14.0-metadata.json \u2190 rugs (14 kb) succeeded    Downloading atomist-rugs/rug-editors/0.14.0/rug-editors-0.14.0.zip \u2190 rugs (194 kb) succeeded  Resolving dependencies for atomist-rugs:rug-editors:latest completed  Loading atomist-rugs:rug-editors:0.14.0 into runtime completed    TypeScript files added, run `cd .atomist && npm install`  Running editor ConvertExistingProjectToGenerator of atomist-rugs:rug-editors:0.14.0 completed  \u2192 Project    ~/workspace/spring-boot-rest-basic (14 kb in 20 files)  \u2192 Changes    \u251c\u2500\u2500 .atomist/package.json created (57 bytes)    \u251c\u2500\u2500 .atomist/tsconfig.json created (627 bytes)    \u251c\u2500\u2500 .atomist/.gitignore created (27 bytes)    \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts created (602 bytes)    \u251c\u2500\u2500 .atomist/tests/NewSpringBootService.rt created (153 bytes)    \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts updated (580 bytes)    \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts updated (583 bytes)    \u251c\u2500\u2500 .atomist/editors/NewSpringBootService.ts updated (584 bytes)    \u251c\u2500\u2500 .atomist/tests/NewSpringBootService.rt updated (155 bytes)    \u251c\u2500\u2500 .atomist/tests/NewSpringBootService.rt updated (880 bytes)    \u2514\u2500\u2500 .atomist.yml created (2 kb)   The  group_id  and  archive_name  parameters, coupled with the name of the Rug\ngenerator, define the fully-qualified name of the  Rug archive  (the\npublished package of a Rug).  Once this is completed, the project should look like this:  ~/workspace/spring-boot-rest-basic      \u251c\u2500\u2500 .atomist      \u2502\u00a0\u00a0 \u251c\u2500\u2500 editors      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 NewSpringBootService.ts      \u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore      \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json      \u2502\u00a0\u00a0 \u251c\u2500\u2500 tests      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 NewSpringBootService.feature      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \u2514\u2500\u2500 Steps.ts      \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json      \u251c\u2500\u2500 .atomist.yml      \u251c\u2500\u2500 .gitignore      \u251c\u2500\u2500 pom.xml      \u251c\u2500\u2500 .project      \u251c\u2500\u2500 README.md      \u251c\u2500\u2500 src      \u2502\u00a0\u00a0 \u251c\u2500\u2500 main      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 com      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 company      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 HomeController.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 MyRestServiceApplication.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 MyRestServiceConfiguration.java      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 application.properties      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 logback.xml      \u2502\u00a0\u00a0 \u2514\u2500\u2500 test      \u2502\u00a0\u00a0     \u2514\u2500\u2500 java      \u2502\u00a0\u00a0         \u2514\u2500\u2500 com      \u2502\u00a0\u00a0             \u2514\u2500\u2500 company      \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceApplicationTests.java      \u2502\u00a0\u00a0                 \u251c\u2500\u2500 MyRestServiceOutOfContainerIntegrationTests.java      \u2502\u00a0\u00a0                 \u2514\u2500\u2500 MyRestServiceWebIntegrationTests.java   The  .atomist  directory contains a metadata file,  package.json ,\ndefining characteristics of the project and declaring  TypeScript \ndependencies, and has the Rug generator script and its associated test\nin appropriate subdirectories.   Because all of the Atomist files are hidden under the  .atomist \ndirectory, our generator project is still a fully functioning,\nperfectly valid Spring Boot project.   Let\u2019s take a close look at the Rug generator script.",
            "title": "Anatomy of a Generator"
        },
        {
            "location": "/user-guide/rug/generators/#a-basic-generator-script",
            "text": "The generator script\u2019s  populate  method is invoked after\nthe model project\u2019s files have been copied to the target project.  The default\ncontents of the generator script we added above look like the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 import   {   PopulateProject   }   from   '@atomist/rug/operations/ProjectGenerator' ;  import   {   Project   }   from   '@atomist/rug/model/Project' ;  import   {   Pattern   }   from   '@atomist/rug/operations/RugOperation' ;  import   {   Generator ,   Parameter ,   Tags   }   from   '@atomist/rug/operations/Decorators' ;  @Generator ( \"NewSpringBootService\" ,   \"Rug project for Spring Rest Services\" )  @Tags ( \"documentation\" )  export   class   NewSpringBootService   implements   PopulateProject   { \n\n     populate ( project :  Project )   { \n         console . log ( `Creating  ${ project . name } ` ); \n     }  }  export   const   newSpringBootService   =   new   NewSpringBootService ();    After importing the TypeScript Rug typings for the elements we will be\nusing (lines 1\u20134), we use a  decorator  to declare the\nfollowing class a generator (line 6).  The first argument to the @Generator  decorator is the name of the generator.\nThis is the externally visible and discoverable name of the Rug.  This\nname, along with the generators group and repository, form the\nfully-qualified name of the generator.  The second argument to the @Generator  decorator is a brief description of the\ngenerator.  On line 7 we use the  @Tags  decorator to\napply some tags to our generator so people can search for it more\neasily.  Using the  @Tags  decorator is optional but\nhighly recommended.  We define the class that will implement our generator on line 8.  A\ngenerator implements the  PopulateProject  interface.\nThis interface requires the  populate ( Project )  method to\nbe defined, which we do on line 10 (more on that below).  It is\nconvention for the generator and the class that implements it to have\nthe same name.  In the last line of the generator script we export an instance of that\ngenerator to make it visible to the Rug runtime when it executed (line 15).\nLike the generator class name, the name of the  const \ndoes not matter, but it is convention to use the generator/class name,\nlower-casing the first letter.  As explained earlier, a generator copies the content of the project where it\nlives into a target directory before applying changes. The definition of our\ngenerator currently performs only the copy (this is done automatically for us).\nLet\u2019s now amend the generator to modify the copied contents, for example to\nchange the name of the copied class. An action users would likely do manually.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34 import   {   PopulateProject   }   from   '@atomist/rug/operations/ProjectGenerator' ;  import   {   Project   }   from   '@atomist/rug/model/Project' ;  import   {   File   }   from   '@atomist/rug/model/File' ;  import   {   Pattern   }   from   '@atomist/rug/operations/RugOperation' ;  import   {   Generator ,   Parameter ,   Tags   }   from   '@atomist/rug/operations/Decorators' ;  import   {   PathExpressionEngine   }   from   '@atomist/rug/tree/PathExpression' ;   @Generator ( \"NewSpringBootService\" ,   \"Rug project for Spring Rest Services\" )  @Tags ( \"documentation\" )  export   class   NewSpringBootService   implements   PopulateProject   { \n\n     @Parameter ({ \n         displayName :   \"Class Name\" , \n         description :   \"name for the service class\" , \n         pattern :  Pattern.java_class , \n         validInput :   \"a valid Java class name, which contains only alphanumeric characters, $ and _ and does not start with a number\" , \n         minLength :  1 , \n         maxLength :  50 , \n         required :  false \n     }) \n     service_class_name :  string ; \n\n     populate ( project :  Project )   { \n         console . log ( `Creating  ${ project . name } ` );           let   eng :  PathExpressionEngine   =   project . context . pathExpressionEngine           eng . with < File > ( project ,   '/src//File()[contains(@name, \"MyRestService\")]' ,   f   =>   {               f . replace ( \"MyRestService\" ,   this . service_class_name );               f . setPath ( f . path . replace ( \"MyRestService\" ,   this . service_class_name ));           });       }  }  export   const   newSpringBootService   =   new   NewSpringBootService ();    Rugs, like typical methods, often take parameters to customize their\nbehavior.  Generators have a required parameter: the name of the\nproject that will be generated.  The project name parameter is\nautomatically defined for a generate.  All other parameters used by\nthe generator must be declared.  Parameters are declared using the @Parameter  decorator (line 10).  The  @Parameter  decorator provides the metadata for the parameter while\nthe subsequent instance variable declaration provides the name and\ndefault value, if any.  The  @Parameter  decorator\naccepts a single argument, a JavaScript object.  The JavaScript object\npassed to  @Parameter  accepts all of the property names\nshown above, but only  pattern  is mandatory.  The  pattern  property\nprovides an anchored regular expression used to validate user input.\nHere we use one the Atomist pre-defined  Pattern s (line\n13).  Despite the fact that the other  @Parameter \nproperties are option, it is highly recommended to provide them to\nhelp consumers of your generator.  The  populate  method takes a single argument, a Project  object.  The  Project  provided to\nthis method contains the contents of the generated project, i.e., all\nthe files copied from the generator project.  Using this object, you\ncan alter the exact copy of the original project as appropriate so the\nresult is the new project with the desired contents.  To effect your\ndesired changes, you have the power of TypeScript and the Rug\nprogramming model.  In that regards, as Atomist comprehends filesystem and code structure, the Rug\nprogramming model offers a powerful mechanism to make the above example a lot\nless brittle through  path expressions . In this generator script, we query\nthe filesystem for all files containing a specific token in their names\n(line 27). Then for each one of these files, we replace its content (line 28)\nand move it to different path (line 29).  Rugs should be tested as any other pieces of software, Rug and its runtime\nnatively supports a  BDD-centric testing approach , based on the\nGherkin DSL.  The test for our generator could be described as follows in .atomist/tests/NewSpringBootService.feature :  Feature:  Creating new Spring Rest Service projects  Scenario:  A default Spring Rest project structure should be generated   Given  an empty project    When  running the Spring Boot Service generator    Then  the name of the application file is changed    Then  the name of the configuration file is changed    Then  the name of the application tests file is changed    Then  the name of the integration tests file is changed    Then  the name of the web integration tests file is changed    Then  the name of the class in the application file is changed    Then  the name of the class in the configuration file is changed    Then  the name of the class in the application tests file is changed    Then  the name of the class in the integration tests file is changed    Then  the name of the class in the web integration tests is changed   Implemented by the steps in  .atomist/tests/Steps.ts  file:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42 import   {   Given ,   When ,   Then ,   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  import   {   Result   }   from   \"@atomist/rug/test/Result\" ;  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  Given ( \"an empty project\" ,   p   =>   {})  When ( \"running the Spring Boot Service generator\" ,   ( p :  Project ,   world :  ProjectScenarioWorld )   =>   { \n   let   generator   =   world . generator ( \"NewSpringBootService\" ); \n   world . generateWith ( generator ,   { \"service_class_name\" :   \"CalendarService\" });  })  Then ( \"the name of the application file is changed\" ,   ( p :  Project )   => \n     p . fileExists ( \"src/main/java/com/company/CalendarServiceApplication.java\" )  )  Then ( \"the name of the configuration file is changed\" ,   ( p :  Project )   => \n     p . fileExists ( \"src/main/java/com/company/CalendarServiceConfiguration.java\" )  )  Then ( \"the name of the application tests file is changed\" ,   ( p :  Project )   => \n     p . fileExists ( \"src/test/java/com/company/CalendarServiceApplicationTests.java\" )  )  Then ( \"the name of the integration tests file is changed\" ,   ( p :  Project )   => \n     p . fileExists ( \"src/test/java/com/company/CalendarServiceOutOfContainerIntegrationTests.java\" )  )  Then ( \"the name of the web integration tests file is changed\" ,   ( p :  Project )   => \n     p . fileExists ( \"src/test/java/com/company/CalendarServiceWebIntegrationTests.java\" )  )  Then ( \"the name of the class in the application file is changed\" ,   ( p :  Project )   => \n     p . findFile ( \"src/main/java/com/company/CalendarServiceApplication.java\" ). contains ( \"CalendarServiceApplication\" )  )  Then ( \"the name of the class in the configuration file is changed\" ,   ( p :  Project )   => \n     p . findFile ( \"src/main/java/com/company/CalendarServiceConfiguration.java\" ). contains ( \"CalendarServiceConfiguration\" )  )  Then ( \"the name of the class in the application tests file is changed\" ,   ( p :  Project )   => \n     p . findFile ( \"src/test/java/com/company/CalendarServiceApplicationTests.java\" ). contains ( \"CalendarServiceApplicationTests\" )  )  Then ( \"the name of the class in the integration tests file is changed\" ,   ( p :  Project )   => \n     p . findFile ( \"src/test/java/com/company/CalendarServiceOutOfContainerIntegrationTests.java\" ). contains ( \"CalendarServiceOutOfContainerIntegrationTests\" )  )  Then ( \"the name of the class in the web integration tests is changed\" ,   ( p :  Project )   => \n     p . findFile ( \"src/test/java/com/company/CalendarServiceWebIntegrationTests.java\" ). contains ( \"CalendarServiceWebIntegrationTests\" )  )    If you\u2019re not familiar with this approach, the .atomist/tests/NewSpringBootService.feature  describes our tests in a set of\nhypotheses and expectations. All those steps are implemented in the .atomist/tests/Steps.ts  file which is executed when the test is run:  $  rug  test  Resolving dependencies for com.company.rugs:spring-boot-service:0.13.0:local completed  Invoking TypeScript Compiler on ts script sources    Created .atomist/tests/Steps.js.map    Created .atomist/tests/Steps.js    Created .atomist/editors/NewSpringBootService.js.map    Created .atomist/editors/NewSpringBootService.js  Processing script sources completed  Loading com.company.rugs:spring-boot-service:0.13.0:local completed    Executing feature Creating new Spring Rest Service projects      Executing test scenario A default Spring Rest project structure should be generated    Creating project_name  Running tests in com.company.rugs:spring-boot-service:0.13.0:local completed  Successfully executed 1 of 1 test: Test SUCCESS   Assuming we change one of the hypotheses to make it fail,  rug  would notify us\nwith a relevant error message:  $  rug  test  Resolving dependencies for com.company.rugs:spring-boot-service:0.13.0:local completed  Invoking TypeScript Compiler on ts script sources    Created .atomist/tests/Steps.js.map    Created .atomist/tests/Steps.js    Created .atomist/editors/NewSpringBootService.js    Created .atomist/editors/NewSpringBootService.js.map  Processing script sources completed  Loading com.company.rugs:spring-boot-service:0.13.0:local completed    Executing feature Creating new Spring Rest Service projects      Executing test scenario A default Spring Rest project structure should be generated    Creating project_name  Running tests in com.company.rugs:spring-boot-service:0.13.0:local completed  \u2192 Test Report    Failures    \u2514\u2500\u252c Creating new Spring Rest Service projects      \u2514\u2500\u252c A default Spring Rest project structure should be generated        \u251c\u2500\u252c the name of the application file is changed: Failed        | \u2514\u2500\u2500 function (p) {      return p.fileExists(\"src/main/java/com/company/CalndarServiceApplication.java\");  }        \u251c\u2500\u2500 the name of the application tests file is changed: Passed        \u251c\u2500\u2500 the name of the class in the application file is changed: Passed        \u251c\u2500\u2500 the name of the class in the application tests file is changed: Passed        \u251c\u2500\u2500 the name of the class in the configuration file is changed: Passed        \u251c\u2500\u2500 the name of the class in the integration tests file is changed: Passed        \u251c\u2500\u2500 the name of the class in the web integration tests is changed: Passed        \u251c\u2500\u2500 the name of the configuration file is changed: Passed        \u251c\u2500\u2500 the name of the integration tests file is changed: Passed        \u2514\u2500\u2500 the name of the web integration tests file is changed: Passed  Unsuccessfully executed 1 of 1 test: Test FAILURE   As you can see, Rug generator scripts are simple functions that apply\nchanges against a freshly copy of your its content. This changes may be\nparametarized to tailor the result to the user\u2019s expectations. Finally,\nfollowing a test-driven approach, generators can be quickly validated before\nbeing released.",
            "title": "A Basic Generator Script"
        },
        {
            "location": "/user-guide/rug/rug-functions/",
            "text": "Rug Functions, as indicated by their name, are functions that can be invoked\nfrom within Event or Command Handlers. They can be scheduled for invocation by\nadding an instruction of kind \nexecute\n to a plan:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nplan\n.\nadd\n(\n\n    \n{\n\n        \ninstruction\n:\n \n{\n\n            \nkind\n:\n \n\"execute\"\n,\n\n            \nname\n:\n \n\"http\"\n,\n\n            \nparameters\n:\n \n{\n\n                \nurl\n:\n \n\"https://api.github.com/repos/atomist/rug\"\n,\n\n                \nmethod\n:\n \n\"post\"\n,\n\n                \nconfig\n:\n \n{\n\n                    \nheaders\n:\n \n{\n\n                        \n\"Content-Type\"\n:\n \n\"application/json\"\n,\n\n                        \n\"Authorization\"\n:\n \n`token #{github://user_token?scopes=repo}`\n,\n\n                    \n},\n\n                    \nbody\n: \nJSON.stringify\n(\ncreateRepoRequest\n)\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \nonSuccess\n: \nnew\n \nDirectMessage\n(\n\"Woot!\"\n,\n \nnew\n \nChannelAddress\n(\n\"#random\"\n)),\n\n        \nonError\n: \nnew\n \nDirectMessage\n(\n\"Un oh\"\n,\n \nnew\n \nChannelAddress\n(\n\"#random\"\n))\n\n    \n}\n\n\n)\n\n\n\n\n\n\n\nThe plan above instructs the Rug Runtime to invoke the \nhttp\n Rug Function,\npassing all the \nparameters\n to it, and sending appropriate messages to the\n\n#random\n channel \nonSuccess\n or \nonError\n.\n\n\nTo use a Rug Function from an Event or Command Handler, its archive\u2019s\ncoordinates must be present in the \n.atomist.extensions\n section of\nthe Rug project\u2019s \npackage.json\n.\n\n\n\n\nSecurity\n\n\nAll Rug Function archives must be signed by Atomist and be explicitly\nwhitelisted in the Atomist service. Otherwise, the execution of the invoking\nhandler will be aborted.\n\n\n\n\nSecrets\n can also be passed to Rug Functions, but currently this is only supported\nfor Command Handlers.\n\n\nThe special \n#{<secret path>}\n notation used above is a way of injecting the value\nof a secret (in this case, a GitHub token with \nrepo\n scope) in to the parameters\nto a function via string filtering. Rug Functions can also be \nannotated\n\nso that if the secrets required are known in advance, we don\u2019t need to use paramter\nfiltering.\n\n\nThe following Rug Function archives available:\n\n\n\n\nrug-function-http\n - perform arbitrary HTTP requests\n\n\nrug-functions-travis\n - encrypt secrets, start/stop builds\n\n\nrug-functions-aws\n - perform s3 operations and so on\n\n\n\n\n\n\nCreating your own Rug functions\n\n\nRight now there is no support for user-created Rug functions. Please get in\ntouch by joining our \nSlack team\n if you need one\nthat doesn\u2019t already exist.\n\n\n\n\nSecrets\n\u00b6\n\n\nSecrets are pieces of sensitive information stored securely by Atomist. Secrets\nare used by \nRug Functions\n to provide access\nto secured systems, such as the GitHub API.\n\n\nHandlers that invoke Rug Functions that require secrets must use the\n\n@Secrets\n decorator to declare to the Rug runtime that those\nsecrets will be required during the execution of the handler\u2019s CommandPlan:\n\n\n...\n\n\n@Secrets\n(\n\"github://user_token?scopes=repo,read:org\"\n)\n\n\nclass\n \nCloseIssueCommand\n \nimplements\n \nHandleCommand\n \n{\n\n    \n//...\n\n\n}\n\n\n\n\n\nThe \n@Secrets\n decorator takes a comma separate list of secret\npaths. The decorator provides enough context to the Atomist Bot such that it\ncan initiate the secure collection of the require secret data, such as a GitHub\ntoken collected via OAuth flow.\n\n\n\n\nConfidentiality\n\n\nAll sensitive data stored by Atomist are encrypted at rest in\n\nVault\n.\n\n\n\n\nThere are currently two types of secrets:\n\n\n\n\nGitHub tokens: automatically collected by the Atomist Bot\n\n\n\"github://user_token?scopes=repo\"\n - \nrepo\n scoped user token\n\n\n\"github://team_token?scopes=repo\"\n - \nrepo\n scoped\nteam token Both user and team GitHub tokens require the scopes\nneeded by the \ntoken\n to be provided as a comma-separated list.\n\n\n\n\n\n\nGeneric Secrets: manual collection\n\n\n\"secret://user?path=/some/secret\"\n - generic user secret\n\n\n\"secret://team?path=/some/secret\"\n - generic team secret\n\n\n\n\n\n\n\n\n\n\nGeneric Secrets\n\n\nThese are currently only available for very specific and mostly internal use\ncases as we currently have no secure public mechanism for collecting and storing\nthem, though this is something we are hoping to support in the near future. They\nare mentioned here to avoid any confusion when seen in publically visible Handlers.",
            "title": "Rug Functions"
        },
        {
            "location": "/user-guide/rug/rug-functions/#secrets",
            "text": "Secrets are pieces of sensitive information stored securely by Atomist. Secrets\nare used by  Rug Functions  to provide access\nto secured systems, such as the GitHub API.  Handlers that invoke Rug Functions that require secrets must use the @Secrets  decorator to declare to the Rug runtime that those\nsecrets will be required during the execution of the handler\u2019s CommandPlan:  ...  @Secrets ( \"github://user_token?scopes=repo,read:org\" )  class   CloseIssueCommand   implements   HandleCommand   { \n     //...  }   The  @Secrets  decorator takes a comma separate list of secret\npaths. The decorator provides enough context to the Atomist Bot such that it\ncan initiate the secure collection of the require secret data, such as a GitHub\ntoken collected via OAuth flow.   Confidentiality  All sensitive data stored by Atomist are encrypted at rest in Vault .   There are currently two types of secrets:   GitHub tokens: automatically collected by the Atomist Bot  \"github://user_token?scopes=repo\"  -  repo  scoped user token  \"github://team_token?scopes=repo\"  -  repo  scoped\nteam token Both user and team GitHub tokens require the scopes\nneeded by the  token  to be provided as a comma-separated list.    Generic Secrets: manual collection  \"secret://user?path=/some/secret\"  - generic user secret  \"secret://team?path=/some/secret\"  - generic team secret      Generic Secrets  These are currently only available for very specific and mostly internal use\ncases as we currently have no secure public mechanism for collecting and storing\nthem, though this is something we are hoping to support in the near future. They\nare mentioned here to avoid any confusion when seen in publically visible Handlers.",
            "title": "Secrets"
        },
        {
            "location": "/user-guide/rug/secrets/",
            "text": "Secrets are pieces of sensitive information stored securely by Atomist. Secrets\nare used by \nRug Functions\n to provide access\nto secured systems, such as the GitHub API.\n\n\nHandlers that invoke Rug Functions that require secrets must use the\n\n@Secrets\n decorator to declare to the Rug runtime that those\nsecrets will be required during the execution of the handler\u2019s CommandPlan:\n\n\n...\n\n\n@Secrets\n(\n\"github://user_token?scopes=repo,read:org\"\n)\n\n\nclass\n \nCloseIssueCommand\n \nimplements\n \nHandleCommand\n \n{\n\n    \n//...\n\n\n}\n\n\n\n\n\nThe \n@Secrets\n decorator takes a comma separate list of secret\npaths. The decorator provides enough context to the Atomist Bot such that it\ncan initiate the secure collection of the require secret data, such as a GitHub\ntoken collected via OAuth flow.\n\n\n\n\nConfidentiality\n\n\nAll sensitive data stored by Atomist are encrypted at rest in\n\nVault\n.\n\n\n\n\nThere are currently two types of secrets:\n\n\n\n\nGitHub tokens: automatically collected by the Atomist Bot\n\n\n\"github://user_token?scopes=repo\"\n - \nrepo\n scoped user token\n\n\n\"github://team_token?scopes=repo\"\n - \nrepo\n scoped\nteam token Both user and team GitHub tokens require the scopes\nneeded by the \ntoken\n to be provided as a comma-separated list.\n\n\n\n\n\n\nGeneric Secrets: manual collection\n\n\n\"secret://user?path=/some/secret\"\n - generic user secret\n\n\n\"secret://team?path=/some/secret\"\n - generic team secret\n\n\n\n\n\n\n\n\n\n\nGeneric Secrets\n\n\nThese are currently only available for very specific and mostly internal use\ncases as we currently have no secure public mechanism for collecting and storing\nthem, though this is something we are hoping to support in the near future. They\nare mentioned here to avoid any confusion when seen in publically visible Handlers.",
            "title": "Secrets"
        },
        {
            "location": "/user-guide/rug/extensions/",
            "text": "Rug extensions represent different types of source code, events, and\nsystems which Rug can understand and interact with.  Each Rug\nextension defines a set of operations you can use to get and\nmodify the system or language it represents.\n\n\nA fundamental Rug extension is \nProject\n.  \nProject\n represents a\nsource code repository and allows you get information about the\nrepository, e.g., if a file exists, and to alter the repository, e.g.,\nadd or delete a file.\n\n\nAtomist makes several Rug extensions available to all its users.  Many\nof the standard extensions provide understanding and operations to\nalter common software development languages like Java, C#, Python,\nClojure, and Scala.  Other extensions provide connectivity to common\nsoftware development tools like CI platforms.",
            "title": "Extensions"
        },
        {
            "location": "/user-guide/rug/path-expressions/",
            "text": "Rug path expressions, inspired by \nXPath\n, provide a means to\nnavigate entities in Rug with high precision.  From selecting events\nwith highly-specific criteria to matching only certain \ncatch\n blocks,\npath expressions from a powerful and flexible way to select code and\nevents to operate on.\n\n\n\n\nPath expressions everywhere\n\n\nPath expressions are a core concept everywhere in Rug.  Their\ndetailed semantics differ between project operations and handlers,\nbut the fact that everything is addressable and navigable from any\nstarting point is universally applicable.\n\n\n\n\n\n\n\nSurgical selections\n\u00b6\n\n\nWhen running a Rug against a \nProject\n, you can locate a file with a\nknown name with some code like the following line:\n\n\nproject\n.\nfindFile\n(\n\"mkdocs.yml\"\n).\nreplace\n(\n\"<NAME>\"\n,\n \nproject\n.\nname\n);\n\n\n\n\n\nThis approach provides a simple mechanism for finding a file within a\nproject if you know its path.  But what if you want to select a file\nbased on something other than its path?  What if you want to select\nseveral files that all satisfy common criteria?  What if you want to\nselect just a part of a file?  To allow users to select elements with\nsuch flexibility and specificity, Atomist provides a powerful tool\ncalled \npath expressions\n.\n\n\nQuery the file system\n\u00b6\n\n\nThe above code selecting a file by path can be written as a path\nexpression.  First, we must import the \nPathExpressionEngine\n\n\nimport\n \n{\n \nPathExpressionEngine\n \n}\n \nfrom\n \n\"@atomist/rug/tree/PathExpression\"\n;\n\n\n\n\n\nand fetch the \nPathExpressionEngine\n from the\n\nProject\n context.\n\n\nlet\n \neng\n: \nPathExpressionEngine\n \n=\n \nproject\n.\ncontext\n.\npathExpressionEngine\n;\n\n\n\n\n\nWe then rewrite the \nfindFile\n()\n function call using the\n\nPathExpressionEngine\n method \nwith\n()\n,\nsupplying the appropriate path expression to select the file based on\nname.\n\n\neng\n.\nwith\n<\nFile\n>\n(\nproject\n,\n \n\"/*[@name='mkdocs.yml']\"\n,\n \n(\nf\n)\n \n=>\n \n{\n\n    \nf\n.\nreplace\n(\n\"<NAME>\"\n,\n \nproject\n.\nname\n);\n\n\n})\n\n\n\n\n\nThe final argument of of the \nwith\n()\n method is a\nfunction which receives as its argument all \nFile\ns that\nsatisfy the path expression, one at a time, and can then operate on\neach match in turn.  Here we call the \nreplace\n()\n method\njust as we did before.  For this simple case, using path expressions\nmay is a bit more involved, but it demonstrates the concepts well.\n\n\nQuery the code\n\u00b6\n\n\nWhile querying a project for files using path expressions allows for\ngreater flexibility than the other means of navigating files in a\nproject, a more powerful way is to query the content of the target file\ndirectly. This file is a YAML structure, we therefore use a\nspecific path expression engine that knows how to navigate this kind\nof structure.\n\n\nFirst the expected import statements:\n\n\nimport\n \n*\n \nas\n \nyaml\n \nfrom\n \n\"@atomist/rug/ast/yaml/Types\"\n;\n\n\nimport\n \n{\n \nYamlPathExpressionEngine\n \n}\n \nfrom\n \n\"@atomist/rug/ast/yaml/YamlPathExpressionEngine\"\n;\n\n\n\n\n\nLet\u2019s amend our previous example:\n\n\nlet\n \neng\n: \nPathExpressionEngine\n \n=\n \nnew\n \nYamlPathExpressionEngine\n(\nproject\n.\ncontext\n.\npathExpressionEngine\n);\n\n\n\neng\n.\nwith\n<\nyaml\n.\nYamlString\n>\n(\nproject\n,\n \n\"/*[@name='mkdocs.yml']/YamlFile()/*[@name='site_name']\"\n,\n \n(\nfield\n)\n \n=>\n \n{\n\n    \nfield\n.\nupdateText\n(\nproject\n.\nname\n);\n\n\n})\n\n\n\n\n\nFirst we create a specific YAML-aware path expression engine, this\nwill offer us appropriate methods to work on a YAML structure.  The\npath expression we provide begins with the familiar file system query,\nidentifying a file named \nmkdocs.yml\n.  The next step in the path\nexpression, \nYamlFile()\n is something new.  The \nYamlFile()\n step\ntells Rug to address the file(s) it has found using the preceding\ncriteria as not just a generic \nFile\n, but a more\nspecific \nYamlFile\n.  The \nYamlFile\n type\nhas the ability to enter into the YAML syntax tree, allowing you to\nquery and select individual elements of the YAML document.  Here,\n\n/*[@name='site_name']\n tells Rug that we want fields named\n\nsite_name\n in the parsed YAML document.  Each such field in the YAML\ndocument is passed to the function defined in the third argument to\n\nwith\n()\n.  This function replaces the original value of\nthat field using the method \nfield\n.\nupdateText\n(\nproject\n.\nname\n())\n, a method defined specifically on\nthe \nyaml.YamlString\n type.\n\n\nTrees Versus Graphs\n\u00b6\n\n\nWhile path expressions are core to Rug, there\u2019s an important\ndifference between path expressions against projects, which you\ntypically write in editors, and path expressions against the Atomist\nCortex (the overall model for your development team): \nProject\nstructure is a tree, while the Cortex structure is a graph.\n\n\nProject Trees\n\u00b6\n\n\nWhen you write a path expression against your projects, you are\nnaturally drilling \ndown\n into its structure. The structure is\nnaturally hierarchical. There will be no cycles and you\u2019ll eventually\nend up with terminal nodes, that have no further relationships. There\nis only a single path between the root node and any descendant. You\ncan assume in your code that all data in the tree will be available to\nyou as you continue to descend.\n\n\nConsider the following path expression against a project:\n\n\n//JavaFile()//catchClause//catchType[@value='Exception']\n\n\n\n\nIt drills into the AST of Java files to find every catch clause that\ncatches type \nException\n. Note that we use \n//\n to find all\ndescendants with the given name, so we can ignore the number of\nintermediate steps in the Java language grammar. (However,\nthe \nANTLR grammar for Java\n is a useful reference. The\nproduction names we use such as \ncatchClause\n are directly taken from\nit.)\n\n\nThe tree abstraction works seamlessly and intuitively across project\ndirectory structure (which is itself a tree) and the ASTs of\nstructured files within projects. Catching \nException\n is usually bad\npractice in production code. However, there may be times when we\u2019re\nquite happy to do it in tests. Assuming our projects follow a\nconventional Java project layout, we can easily modify this path\nexpression to match only production code, by prepending a directory\npath:\n\n\n/src/main/java//JavaFile()//catchClause//catchType[@value='Exception']\n\n\n\n\nThis will only drill into files in the \nsrc/main/java\n directory.\n\n\nCortex Graph\n\u00b6\n\n\nWhen writing \nhandlers\n, we are working with the Atomist Cortex model\nof your team\u2019s development data. This is a \ngraph\n rather than a\ntree. Some key differences:\n\n\n\n\nIt\u2019s not strictly hierarchical\n\n\nThere may be cycles\n\n\nThe notion of a \u201cterminal node\u201d is less clear\n\n\nThere can be more than one path between two nodes. (Note that when\n    we drill into a project we switch from a graph to a tree. Once in\n    tree mode we can rely on tree semantics all the way down.)\n\n\n\n\nWith the more general graph model, the concept of \nmaterialization\n\nbecomes important. Unlike when working with project trees, we can no\nlonger assume that all data will be available if we keep\nnavigating. (This is impossible as without a guarantee of terminal\nnodes, a graph\u2019s relationships may never terminate.)\n\n\nThus, with the Cortex model, path expressions have two functions:\n\n\n\n\nLimit what nodes match, just as in project trees\n\n\nSpecify how deep graph materialization should be be. \nWe can\n    assume that any node referenced in the query will be available\n    whenever we have a match, meaning that we don\u2019t have to check for\n    null or undefined in our TypeScript or JavaScript code.\n\n\nBecause we aren\u2019t working with a strict hierarchy, and because\n    there can be multiple paths between nodes, the \n//\n \nself or\n    descendants\n axis tends to be less useful. Similarly, the notion\n    of descending via \n/\n is less intuitive and relevant.\n\n\n\n\nThus we often choose to build path expressions using \nquery by\nexample\n. This is an established technique for searching for data via\nexamples of data that should match.\n\n\nimport\n \n*\n \nas\n \ncortex\n \nfrom\n \n\"@atomist/cortex/stub/Types\"\n;\n\n\nimport\n \n*\n \nas\n \nquery\n \nfrom\n \n'@atomist/rugs/util/tree/QueryByExample'\n;\n\n\n\n...\n\n\n\n@EventHandler\n(\n\"name\"\n,\n \n\"description\"\n,\n\n    \nquery\n.\nforRoot\n(\n\n        \nnew\n \ncortex\n.\nBuild\n()\n\n        \n.\nwithStatus\n(\n\"passed\"\n)\n\n        \n.\nwithRepo\n(\n\n            \nnew\n \ncortex\n.\nRepo\n().\nwithOwner\n(\n\"atomist\"\n)\n\n        \n)\n\n\n)\n\n\n\n\n\nWe first import the Cortex stubs. These implement Cortex interfaces\nsuch as \nBuild\n and \nRepo\n, and are used for query by example and\ntesting. Then we can instantiate a graph of example objects by using\nno-arg constructors and fluent builder methods such as \nwithStatus\n.\n\n\nThen you can use the functions in the \nQueryByExample\n module from the\n\nrugs\n node module. In this case, the \nforRoot\n function will\ninterrogate the object graph to create predicates reflecting the\nrelationships and simple properties. The generated path expression\nwill look as follows:\n\n\n/Build()[@status='passed']\n    [/repo::Repo()[@owner='atomist']]\n\n\n\n\nThus the example above is equivalent to:\n\n\n@EventHandler\n(\n\"name\"\n,\n \n\"description\"\n,\n\n    \n`/Build()[@status='passed']\n\n\n        [/repo::Repo()[@owner='atomist']]`\n)\n\n\n\n\n\nQuery by example has the advantage of excellent tool support. Your\nfavorite editor will provide suggestions for potential paths and\n\n\nBest Practice: Reuse of Path Expression Components\n\u00b6\n\n\nPath expressions are inherently composable, whether in editors,\nreviewer or handlers.\n\n\nWhether using a path expression string style or query by example, it\u2019s\ngood practice to reuse predicates for subgraphs. Take our previous\nquery:\n\n\nquery\n.\nforRoot\n(\n\n        \nnew\n \ncortex\n.\nBuild\n()\n\n        \n.\nwithStatus\n(\n\"passed\"\n)\n\n        \n.\nwithRepo\n(\n\n            \nnew\n \ncortex\n.\nRepo\n()\n\n                \n.\nwithOwner\n(\n\"atomist\"\n)\n\n        \n);\n\n\n\n\n\nThis can be rewritten as follows, simply using TypeScript constructs:\n\n\nquery\n.\nforRoot\n(\n\n        \nnew\n \ncortex\n.\nBuild\n()\n\n        \n.\nwithStatus\n(\n\"passed\"\n)\n\n        \n.\nwithRepo\n(\natomistRepo\n);\n\n\n\nconst\n \natomistRepo\n \n=\n \nnew\n \ncortex\n.\nRepo\n().\nwithOwner\n(\n\"atomist\"\n);\n\n\n\n\n\nObviously the benefit is greater when path expressions are complex.\n\n\nWe can also use functions, rather than constants, to parameterize\ncommonly used subgraphs.\n\n\nSuch reuse is a convenient way of capturing commonly needed structures\nfor materialization as well as narrowing matches, eliminating\nduplication and ensuring we have one place to keep them up to date.",
            "title": "Path Expressions"
        },
        {
            "location": "/user-guide/rug/path-expressions/#surgical-selections",
            "text": "When running a Rug against a  Project , you can locate a file with a\nknown name with some code like the following line:  project . findFile ( \"mkdocs.yml\" ). replace ( \"<NAME>\" ,   project . name );   This approach provides a simple mechanism for finding a file within a\nproject if you know its path.  But what if you want to select a file\nbased on something other than its path?  What if you want to select\nseveral files that all satisfy common criteria?  What if you want to\nselect just a part of a file?  To allow users to select elements with\nsuch flexibility and specificity, Atomist provides a powerful tool\ncalled  path expressions .",
            "title": "Surgical selections"
        },
        {
            "location": "/user-guide/rug/path-expressions/#query-the-file-system",
            "text": "The above code selecting a file by path can be written as a path\nexpression.  First, we must import the  PathExpressionEngine  import   {   PathExpressionEngine   }   from   \"@atomist/rug/tree/PathExpression\" ;   and fetch the  PathExpressionEngine  from the Project  context.  let   eng :  PathExpressionEngine   =   project . context . pathExpressionEngine ;   We then rewrite the  findFile ()  function call using the PathExpressionEngine  method  with () ,\nsupplying the appropriate path expression to select the file based on\nname.  eng . with < File > ( project ,   \"/*[@name='mkdocs.yml']\" ,   ( f )   =>   { \n     f . replace ( \"<NAME>\" ,   project . name );  })   The final argument of of the  with ()  method is a\nfunction which receives as its argument all  File s that\nsatisfy the path expression, one at a time, and can then operate on\neach match in turn.  Here we call the  replace ()  method\njust as we did before.  For this simple case, using path expressions\nmay is a bit more involved, but it demonstrates the concepts well.",
            "title": "Query the file system"
        },
        {
            "location": "/user-guide/rug/path-expressions/#query-the-code",
            "text": "While querying a project for files using path expressions allows for\ngreater flexibility than the other means of navigating files in a\nproject, a more powerful way is to query the content of the target file\ndirectly. This file is a YAML structure, we therefore use a\nspecific path expression engine that knows how to navigate this kind\nof structure.  First the expected import statements:  import   *   as   yaml   from   \"@atomist/rug/ast/yaml/Types\" ;  import   {   YamlPathExpressionEngine   }   from   \"@atomist/rug/ast/yaml/YamlPathExpressionEngine\" ;   Let\u2019s amend our previous example:  let   eng :  PathExpressionEngine   =   new   YamlPathExpressionEngine ( project . context . pathExpressionEngine );  eng . with < yaml . YamlString > ( project ,   \"/*[@name='mkdocs.yml']/YamlFile()/*[@name='site_name']\" ,   ( field )   =>   { \n     field . updateText ( project . name );  })   First we create a specific YAML-aware path expression engine, this\nwill offer us appropriate methods to work on a YAML structure.  The\npath expression we provide begins with the familiar file system query,\nidentifying a file named  mkdocs.yml .  The next step in the path\nexpression,  YamlFile()  is something new.  The  YamlFile()  step\ntells Rug to address the file(s) it has found using the preceding\ncriteria as not just a generic  File , but a more\nspecific  YamlFile .  The  YamlFile  type\nhas the ability to enter into the YAML syntax tree, allowing you to\nquery and select individual elements of the YAML document.  Here, /*[@name='site_name']  tells Rug that we want fields named site_name  in the parsed YAML document.  Each such field in the YAML\ndocument is passed to the function defined in the third argument to with () .  This function replaces the original value of\nthat field using the method  field . updateText ( project . name ()) , a method defined specifically on\nthe  yaml.YamlString  type.",
            "title": "Query the code"
        },
        {
            "location": "/user-guide/rug/path-expressions/#trees-versus-graphs",
            "text": "While path expressions are core to Rug, there\u2019s an important\ndifference between path expressions against projects, which you\ntypically write in editors, and path expressions against the Atomist\nCortex (the overall model for your development team):  Project\nstructure is a tree, while the Cortex structure is a graph.",
            "title": "Trees Versus Graphs"
        },
        {
            "location": "/user-guide/rug/path-expressions/#project-trees",
            "text": "When you write a path expression against your projects, you are\nnaturally drilling  down  into its structure. The structure is\nnaturally hierarchical. There will be no cycles and you\u2019ll eventually\nend up with terminal nodes, that have no further relationships. There\nis only a single path between the root node and any descendant. You\ncan assume in your code that all data in the tree will be available to\nyou as you continue to descend.  Consider the following path expression against a project:  //JavaFile()//catchClause//catchType[@value='Exception']  It drills into the AST of Java files to find every catch clause that\ncatches type  Exception . Note that we use  //  to find all\ndescendants with the given name, so we can ignore the number of\nintermediate steps in the Java language grammar. (However,\nthe  ANTLR grammar for Java  is a useful reference. The\nproduction names we use such as  catchClause  are directly taken from\nit.)  The tree abstraction works seamlessly and intuitively across project\ndirectory structure (which is itself a tree) and the ASTs of\nstructured files within projects. Catching  Exception  is usually bad\npractice in production code. However, there may be times when we\u2019re\nquite happy to do it in tests. Assuming our projects follow a\nconventional Java project layout, we can easily modify this path\nexpression to match only production code, by prepending a directory\npath:  /src/main/java//JavaFile()//catchClause//catchType[@value='Exception']  This will only drill into files in the  src/main/java  directory.",
            "title": "Project Trees"
        },
        {
            "location": "/user-guide/rug/path-expressions/#cortex-graph",
            "text": "When writing  handlers , we are working with the Atomist Cortex model\nof your team\u2019s development data. This is a  graph  rather than a\ntree. Some key differences:   It\u2019s not strictly hierarchical  There may be cycles  The notion of a \u201cterminal node\u201d is less clear  There can be more than one path between two nodes. (Note that when\n    we drill into a project we switch from a graph to a tree. Once in\n    tree mode we can rely on tree semantics all the way down.)   With the more general graph model, the concept of  materialization \nbecomes important. Unlike when working with project trees, we can no\nlonger assume that all data will be available if we keep\nnavigating. (This is impossible as without a guarantee of terminal\nnodes, a graph\u2019s relationships may never terminate.)  Thus, with the Cortex model, path expressions have two functions:   Limit what nodes match, just as in project trees  Specify how deep graph materialization should be be.  We can\n    assume that any node referenced in the query will be available\n    whenever we have a match, meaning that we don\u2019t have to check for\n    null or undefined in our TypeScript or JavaScript code.  Because we aren\u2019t working with a strict hierarchy, and because\n    there can be multiple paths between nodes, the  //   self or\n    descendants  axis tends to be less useful. Similarly, the notion\n    of descending via  /  is less intuitive and relevant.   Thus we often choose to build path expressions using  query by\nexample . This is an established technique for searching for data via\nexamples of data that should match.  import   *   as   cortex   from   \"@atomist/cortex/stub/Types\" ;  import   *   as   query   from   '@atomist/rugs/util/tree/QueryByExample' ;  ...  @EventHandler ( \"name\" ,   \"description\" , \n     query . forRoot ( \n         new   cortex . Build () \n         . withStatus ( \"passed\" ) \n         . withRepo ( \n             new   cortex . Repo (). withOwner ( \"atomist\" ) \n         )  )   We first import the Cortex stubs. These implement Cortex interfaces\nsuch as  Build  and  Repo , and are used for query by example and\ntesting. Then we can instantiate a graph of example objects by using\nno-arg constructors and fluent builder methods such as  withStatus .  Then you can use the functions in the  QueryByExample  module from the rugs  node module. In this case, the  forRoot  function will\ninterrogate the object graph to create predicates reflecting the\nrelationships and simple properties. The generated path expression\nwill look as follows:  /Build()[@status='passed']\n    [/repo::Repo()[@owner='atomist']]  Thus the example above is equivalent to:  @EventHandler ( \"name\" ,   \"description\" , \n     `/Build()[@status='passed']          [/repo::Repo()[@owner='atomist']]` )   Query by example has the advantage of excellent tool support. Your\nfavorite editor will provide suggestions for potential paths and",
            "title": "Cortex Graph"
        },
        {
            "location": "/user-guide/rug/path-expressions/#best-practice-reuse-of-path-expression-components",
            "text": "Path expressions are inherently composable, whether in editors,\nreviewer or handlers.  Whether using a path expression string style or query by example, it\u2019s\ngood practice to reuse predicates for subgraphs. Take our previous\nquery:  query . forRoot ( \n         new   cortex . Build () \n         . withStatus ( \"passed\" ) \n         . withRepo ( \n             new   cortex . Repo () \n                 . withOwner ( \"atomist\" ) \n         );   This can be rewritten as follows, simply using TypeScript constructs:  query . forRoot ( \n         new   cortex . Build () \n         . withStatus ( \"passed\" ) \n         . withRepo ( atomistRepo );  const   atomistRepo   =   new   cortex . Repo (). withOwner ( \"atomist\" );   Obviously the benefit is greater when path expressions are complex.  We can also use functions, rather than constants, to parameterize\ncommonly used subgraphs.  Such reuse is a convenient way of capturing commonly needed structures\nfor materialization as well as narrowing matches, eliminating\nduplication and ensuring we have one place to keep them up to date.",
            "title": "Best Practice: Reuse of Path Expression Components"
        },
        {
            "location": "/user-guide/rug/microgrammars/",
            "text": "Microgrammars are \n\u201cpartial grammars designed to extract\nchecker-specific features only\u201d\n.\n\n\nWhen there is no existing Rug \nextension\n and plain file\nmanipulation is too clumsy and random,\nthe \nmicrogrammar (pdf)\n support in Rug provides an\neffective way of declaring a way to safely select and extract a\nportion of a file so that it can be inspected and manipulated by your\nRugs.\n\n\n\n\nFor more on microgrammars we recommend you check out\nthis \npost by Adrian Colyer\n.\n\n\n\n\nThe Atomist implementation of microgrammars is undergoing rapid\ndevelopment and change.  Please see\nthe \n@atomist/microgrammar\n TypeScript\nimplementation for the latest documentation and usage.",
            "title": "Microgrammars"
        },
        {
            "location": "/user-guide/rug/templates/",
            "text": "Atomist discourages the use of templates\n\n\nOne of the guiding principles of Atomist is that editors and\ngenerators should originate from working projects and those\nprojects should remain operational under their native tooling.\nUsing templates undermines this principle.  Templates are hard to\ntest and it is easy to forget to keep them up to date.  We\nrecommend transforming real project files over using templates\nhidden away under the \n.atomist/templates\n directory.\n\n\n\n\nRug Templates are files that contain parameterized content that can be\nused by Rug \ngenerators\n\nand \neditors\n.  Templates are located in the\n\n.atomist/templates\n directory.\n\n\nCurrently Rug supports using\nboth \nVelocity\n\nand \nMustache\n styles of template.\nVelocity templates must have a \n.vm\n extension.  Mustache templates\nmust have a \n.mustache\n extension.",
            "title": "Templates"
        },
        {
            "location": "/user-guide/rug/tests/",
            "text": "Rug provides a testing framework based\non \nBehavior-Driven Development (BDD)\n concepts.  This allows\nrapid, in-memory testing of Rugs.\n\n\nThe framework is based on the well known \nGherkin BDD DSL\n\nand inspired by solutions built on it, such\nas \ncucumber-js\n.  All logic is coded in TypeScript or\nJavaScript. If you are familiar with Cucumber (versions of which exist\nfor many languages), you should find the Rug test framework\nparticularly easy to learn; if not, it should still be intuitive.\n\n\nApproach\n\u00b6\n\n\nRug is designed to support \nTest Driven Development\n using unit\ntests and BDD.  We recommend following the \u201cred \u2192 green \u2192\nrefactor\u201d approach.\n\n\n\n\nPrerequisites\n\n\nYou will need the \nRug CLI\n and \nNode.js\n\ninstalled to run tests.\n\n\n\n\nFor unit testing, we recommend using the \nMocha\n framework\nwith \nPower Assert\n.  You should put your Mocha unit\ntests in the \n.atomist/mocha\n directory to avoid conflicts with where\nthe Rug CLI looks for the BDD tests.  With this setup, your\n\n.atomist/package.json\n would look something like this:\n\n\n{\n\n  \n\"dependencies\"\n:\n \n{\n\n    \n\"@atomist/rugs\"\n:\n \n\"^1.0.0-m.4\"\n\n  \n},\n\n  \n\"devDependencies\"\n:\n \n{\n\n    \n\"@types/mocha\"\n:\n \n\"^2.2.40\"\n,\n\n    \n\"@types/power-assert\"\n:\n \n\"^1.4.29\"\n,\n\n    \n\"espower-typescript\"\n:\n \n\"^8.0.0\"\n,\n\n    \n\"mocha\"\n:\n \n\"^3.2.0\"\n,\n\n    \n\"power-assert\"\n:\n \n\"^1.4.2\"\n,\n\n    \n\"tslint\"\n:\n \n\"^5.0.0\"\n,\n\n    \n\"typescript\"\n:\n \n\"2.3.2\"\n\n  \n},\n\n  \n\"directories\"\n:\n \n{\n\n    \n\"test\"\n:\n \n\"mocha\"\n\n  \n},\n\n  \n\"scripts\"\n:\n \n{\n\n    \n\"lint\"\n:\n \n\"tslint '**/*.ts' --exclude 'node_modules/**' -t verbose\"\n,\n\n    \n\"mocha\"\n:\n \n\"mocha --compilers ts:espower-typescript/guess 'mocha/**/*.ts'\"\n,\n\n    \n\"test\"\n:\n \n\"npm run mocha && rug test\"\n\n  \n}\n\n\n}\n\n\n\n\n\nand you can run your unit tests with the following command:\n\n\n$\n \n(\n \ncd\n .atomist \n&&\n npm run mocha \n)\n\n\n\n\n\nor run both the unit and BDD tests with this command:\n\n\n$\n \n(\n \ncd\n .atomist \n&&\n npm \ntest\n \n)\n\n\n\n\n\nThe documentation for \nMocha\n and \nPower Assert\n\ncan help you get started with unit testing in TypeScript/JavaScript.\nThe rest of this document focuses on Rug BDD testing.\n\n\nQuick overview\n\u00b6\n\n\nBefore taking a deeper dive into the Rug BDD approach, let\u2019s look at\nan example.\n\n\nConsider the following simple editor that will rename a Java file.\n\n\nimport\n \n{\n \nEditProject\n \n}\n \nfrom\n \n'@atomist/rug/operations/ProjectEditor'\n;\n\n\nimport\n \n{\n \nEditor\n \n}\n \nfrom\n \n'@atomist/rug/operations/Decorators'\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n'@atomist/rug/model/Core'\n;\n\n\nimport\n \n{\n \nPathExpressionEngine\n \n}\n \nfrom\n \n'@atomist/rug/tree/PathExpression'\n;\n\n\nimport\n \n{\n \nJavaClass\n \n}\n \nfrom\n \n'@atomist/rug/model/JavaClass'\n;\n\n\n\n@Editor\n(\n\"Renamer\"\n,\n \n\"Renames Java class\"\n)\n\n\nexport\n \nclass\n \nRenamer\n \n{\n\n\n    \nedit\n(\nproject\n: \nProject\n)\n \n{\n\n        \nconst\n \neng\n \n=\n \nproject\n.\ncontext\n.\npathExpressionEngine\n;\n\n        \neng\n.\nwith\n<\nJavaClass\n>\n(\nproject\n,\n \n\"//JavaClass()[@name='Dog']\"\n,\n \njc\n \n=>\n \n{\n\n            \njc\n.\nrename\n(\n\"Cat\"\n);\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\nWe want to test that the editor works as intended.  First, we write a\nGherkin \n.feature\n file that is an easily readable description of the\nbehaviors we expect.  We\u2019ll name the file \nRenaming.feature\n and place it\nunder \n.atomist/tests/project\n.\n\n\nFeature:\n Renaming a Java file\n\n\n  We should be able to rename Java files.\n\n\n  Specifically, we should be able to rename\n\n\n  dog files into cat files.\n\n\n\n  \nScenario:\n Dogs can be turned into cats\n\n\n    Given \na file named src/main/java/Dog.java\n\n\n    \nWhen \nedit with Renamer\n\n\n    \nThen \nthere should be one file\n\n\n    \nThen \nthe file is now src/main/java/Cat.java\n\n\n\n\n\nWalking through this definition:\n\n\n\n\nThe syntax is standard Gherkin.  It is human-readable and contains\n    a specification of the desired behavior, but not how that behavior\n    is to be verified.\n\n\nA Gherkin \nfeature\n can contain one or more \nscenarios\n. You can\n    include as many feature files in the \n.atomist/tests/project\n\n    directory as you like.\n\n\nEach scenario is typically broken down into three blocks of\n    \ngiven\n, \nwhen\n, and \nthen\n steps, following the BDD style.\n    Typically there is a single \nwhen\n step\u2013the execution of a Rug.\n    There are often multiple \ngiven\n and \nthen\n steps.  \nThen\n steps\n    are assertions, and it is good practice to break them up for\n    clarity, so failures are specific.\n\n\n\n\n\n\nThe Rug Gherkin parser does not support the \nAnd\n keyword.  Just\nuse the appropriate step keyword multiple times.\n\n\n\n\nWe now have a clear specification of the desired behavior.  How does\nthe test infrastructure know how to execute these steps?\n\n\nAs in \ncucumber-js\n, we delegate to JavaScript or TypeScript to\nexecute these steps.  In keeping with our general preference for\nTypeScript, let\u2019s see the TypeScript steps corresponding to the above\nfeature:\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nGiven\n,\n \nWhen\n,\n \nThen\n,\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\n\nGiven\n(\n\"a file named src/main/java/Dog.java\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \np\n.\naddFile\n(\n\"src/main/java/Dog.java\"\n,\n \n\"public class Dog {}\"\n);\n\n\n});\n\n\n\nWhen\n(\n\"edit with Renamer\"\n,\n \n(\np\n: \nProject\n,\n \nw\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n    \nconst\n \neditor\n \n=\n \nw\n.\neditor\n(\n\"Renamer\"\n);\n\n    \nw\n.\neditWith\n(\neditor\n,\n \n{});\n\n\n});\n\n\n\nThen\n(\n\"there should be one file\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nreturn\n \np\n.\ntotalFileCount\n()\n \n===\n \n1\n;\n\n\n});\n\n\n\nThen\n(\n\"the file is now src/main/java/Cat.java\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nreturn\n \np\n.\nfileExists\n(\n\"src/main/java/Cat.java\"\n);\n\n\n});\n\n\n\n\n\nWe start by importing Rug modules needed for testing, namely\n\nProject\n, the core test functions \nGiven\n,\n\nWhen\n, and \nThen\n, and the testing module\n\nProjectScenarioWorld\n, which provides the context in\nwhich each scenario runs.\n\n\nStep definitions are linked to the steps in the feature via strings,\nsuch as \n\"a file named src/main/java/Dog.java\"\n.  The\nfirst argument for each type of step is a string that should match the\nstring after the same step type in the feature file.  The second\nargument is a function, i.e., callback, that implements the step.\nThis step-implementing function takes two arguments.  The first\nargument is a \nProject\n object and the second optional\nargument is a \nProjectScenarioWorld\n.  You can see only\nthe \nWhen\n step uses the optional second argument, so it\nis the only one that declares it (see below for more details\non \nworlds\n).  Step definitions may be provided in any\nTypeScript or JavaScript file under \n.atomist/tests/project\n. They\nwill be loaded automatically by the test infrastructure.\n\n\nDifferent scenarios and even different features may share step\ndefinitions.  This is beneficial in the case of common steps, e.g.,\n\nGiven \nan empty archive\n, which can be shared across many\nfeatures and scenarios.\n\n\nWorlds\n\u00b6\n\n\nAs mentioned briefly above, each scenario has a \nworld\n in which it\nexecutes.  A \nworld\n is an isolated context for each scenario\nexecution that allows you to control how your Rug is being tested and\nhow the results of the tests are evaluated.  The scenario\u2019s world is\nencapsulated in the TypeScript \nScenarioWorld\n interface\nand made available to the functions implementing each step in the\nscenario.  The modifications made to the scenario\u2019s world in each step\nis visible to all subsequent steps in the scenario.  So the scenario\u2019s\nworld is, more or less, the \nstate\n of the scenario at each step.\n\n\nThe type of world made available to each scenario depends on what is\nbeing tested.  When testing handlers, the world provided to the\nfunctions implementing the steps is a derivative of \nHandlerScenarioWorld\n.  \nHandlerScenarioWorld\n extends\n\nScenarioWorld\n, adding handler-specific methods such as\nthe ability to verify created plans.  The handler scenario world is\nthe first argument to all the functions implementing the handler\nscenario steps.  For example, the declaration for the \nWhen\n function is effectively:\n\n\nimport\n \n{\n \nHandlerScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\nexport\n \nfunction\n \nWhen\n(\ns\n: \nstring\n,\n \nf\n:\n \n(\nHandlerScenarioWorld\n)\n \n=>\n \nvoid\n);\n\n\n\n\n\nWhen testing Rugs that deal with projects, e.g., generators and\neditors, the world provided to the function implementing the scenario\nsteps is a \nProjectScenarioWorld\n.  The \nProjectScenarioWorld\n interface extends \nScenarioWorld\n,\nadding functions to find and execute editors and generators, query the\nnumber of modifications made, and see if editing succeeded.  The\nscenario world is an optional second parameter to the function that\nimplements each scenario step.  For example, the declaration of the\n\nGiven\n function is effectively:\n\n\nimport\n \n{\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\nexport\n \nfunction\n \nGiven\n(\ns\n: \nstring\n,\n \nf\n:\n \n(\nProject\n,\n \nProjectScenarioWorld\n?\n)\n \n=>\n \nvoid\n);\n\n\n\n\n\nIn practice, what you do with the scenario\u2019s world depends on what\n\nphase\n of the scenario you are in.  Each BDD testing scenario has\nthree phases, mapping directly to the different types of Gherkin\nsteps:\n\n\n\n\nSetup\n: the \nGiven\n steps are used to set up\n    testing prerequisites within the world\n\n\nExecution\n: the action being tested is executed on\n    the world in the \nWhen\n step\n\n\nAssertions\n: the state of the scenario\u2019s world is\n    interrogated in the \nThen\n steps\n\n\n\n\nIn the following sections, we will delve into each of these phases and\ndescribe in detail how the scenario\u2019s world can be used in each phase\nto enable testing.\n\n\nSetup\n\u00b6\n\n\nThe \nGiven\n step is used to set up a world for a testing\nscenario.  Many testing scenarios can be entirely setup using\na \n\u201cwell-known step\u201d\n, but sometimes you need to customize\nfor your particular scenario.\n\n\nHandler setup\n\u00b6\n\n\nWhen testing command handlers, you almost always use the \u201cnothing\u201d\nwell-known step that, as you might expect, does nothing.\n\n\nGiven \nnothing\n\n\n\n\n\nAs with all well-known steps, you do not need to supply an\nimplementation, one is already available to the BDD tests by Rug.\n\n\nTo avoid unwanted side effects during testing, the testing framework\nwill only consider executing event handlers that are explicitly\nregistered within a scenario.  Thus, the setup for event handler\ntesting typically involves registering the event handler being tested\nin the \nGiven\n step.  The following Gherkin step:\n\n\nGiven \nHandlerToTest is registered\n\n\n\n\n\ncould be implemented using the following TypeScript function:\n\n\nimport\n \n{\n \nGiven\n,\n \nEventHandlerScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\n\nGiven\n(\n\"HandlerToTest is registered\"\n,\n \n(\nw\n: \nEventHandlerScenarioWorld\n)\n \n=>\n \n{\n\n    \nw\n.\nregisterHandler\n(\n\"HandlerToTest\"\n);\n\n\n});\n\n\n\n\n\nThe event handler is looked up by name using the \nregisterHandler\n method of \nEventHandlerScenarioWorld\n,\nwhich extends \nHandlerScenarioWorld\n with event handler\nspecific methods.  The name used should be the same as the first\nargument to the \n@EventHandler\n decorator.  If the\nhandler cannot be found in the current archive, the test scenario will\nfail.\n\n\nSince this is so common, there is a well-known step for it.\n\n\nGiven \nHandlerToTest handler\n\n\n\n\n\nThe above step in a feature file will register the \u201cHandlerToTest\u201d\nevent handler for a scenario.  You do not need to supply an\nimplementation.\n\n\nProject setup\n\u00b6\n\n\nWhen testing generators you typically start with an empty project,\nwhich is provided as a well-known step.\n\n\nGiven \nan empty project\n\n\n\n\n\nCustomizations when testing editors typically involve a series of\nsteps, each creating a file to populate the project for testing.  As\nan example, consider the \nGiven\n steps below.\n\n\nGiven \na project POM\n\n\nGiven \na Java source file\n\n\n\n\n\nThese steps could be implemented with the following TypeScript\nfunctions.\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nGiven\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\n\nGiven\n(\n\"a project POM\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \np\n.\naddFile\n(\n\"pom.xml\"\n,\n \n`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n\n    <modelVersion>4.0.0</modelVersion>\n\n\n    <groupId>atomist</groupId>\n\n\n    <artifactId>ruggery</artifactId>\n\n\n    <version>0.1.0-SNAPSHOT</version>\n\n\n</project>\n\n\n`\n);\n\n\n});\n\n\n\nGiven\n(\n\"a Java source file\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \np\n.\naddFile\n(\n\"src/main/java/Some.java\"\n,\n \n`public class Some {}`\n);\n\n\n});\n\n\n\n\n\nThere are also well-known steps for populating the project to be\ntested with the contents of the Rug project itself.  The first copies\nthe entire contents of the Rug project, including the \n.atomist\n\ndirectory, into the project being used in the test.\n\n\nGiven \nthe archive root\n\n\n\n\n\nThe second form copies everything \nbut\n the \n.atomist\n directory into\nthe project being used in the test.\n\n\nGiven \narchive non Atomist content\n\n\n\n\n\nExecution\n\u00b6\n\n\nFor each scenario there is typically one \nWhen\n step\ntriggering a single action, sending an event or invoking a command\nhandler, editor, or generator.\n\n\nTriggering command handlers\n\u00b6\n\n\nA command handler is typically triggered from within chat by someone\nsending the Atomist Bot a message with the command handler\u2019s intent.\nTo simulate this action in the testing framework, you use the\n\ninvokeHandler\n method.\n\n\nimport\n \n{\n \nCommandHandlerScenarioWorld\n,\n \nWhen\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\n\nWhen\n(\n\"the TestCommandHandler is invoked\"\n,\n \n(\nw\n: \nCommandHandlerScenarioWorld\n)\n \n=>\n \n{\n\n    \nconst\n \nhandler\n \n=\n \nw\n.\ncommandHandler\n(\n\"TestCommandHandler\"\n);\n\n    \nw\n.\ninvokeHandler\n(\nhandler\n,\n \n{});\n\n\n});\n\n\n\n\n\nThe \nCommandHandlerScenarioWorld\n interface used above\ninherits from \nHandlerScenarioWorld\n, adding methods\nspecific to command handlers.  Before invoking the command handler,\nyou use the \nCommandHandlerScenarioWorld\n object to\nlookup the handler by name using the \ncommandHandler\n\nmethod.  The name you provide is the same as the name used in the\n\n@CommandHandler\n decorator.\n\n\nSending events\n\u00b6\n\n\nTo simulate an event occurring when testing an event handler, you\nfirst create the appropriate \nevent object\n from the classes\nin the \ncortex/stub\n directory.  Then, you use the \nsendEvent\n method\nof \nEventHandlerScenarioWorld\n to trigger the receipt of\nthat event.\n\n\nimport\n \n*\n \nas\n \nstub\n \nfrom\n \n\"@atomist/cortex/stub/Types\"\n;\n\n\nimport\n \n{\n \nWhen\n,\n \nEventHandlerScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\n\nWhen\n(\n\"a new Tag is received\"\n,\n \n(\nw\n: \nEventHandlerScenarioWorld\n)\n \n=>\n \n{\n\n    \nconst\n \nevent\n \n=\n \nnew\n \nstub\n.\nTag\n();\n\n    \nw\n.\nsendEvent\n(\nevent\n);\n\n\n});\n\n\n\n\n\nRemember that you must have registered an event handler that responds\nto that exact kind of event.  You can create arbitrarily complex\nevents using the \u201cstub\u201d objects.\n\n\nimport\n \n*\n \nas\n \nstub\n \nfrom\n \n\"@atomist/cortex/stub/Types\"\n;\n\n\nimport\n \n{\n \nWhen\n,\n \nEventHandlerScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\n\nWhen\n(\n\"an initial commit is received\"\n,\n \n(\nw\n: \nEventHandlerScenarioWorld\n)\n \n=>\n \n{\n\n    \nconst\n \nevent\n \n=\n \nnew\n \nstub\n.\nPush\n()\n\n        \n.\naddCommits\n(\nnew\n \nstub\n.\nCommit\n().\nwithMessage\n(\n\"initial commit by Atomist\"\n))\n\n        \n.\nwithRepo\n(\nnew\n \nstub\n.\nRepo\n().\nwithName\n(\nrepoName\n).\nwithOwner\n(\norgName\n)\n\n            \n.\nwithOrg\n(\nnew\n \nstub\n.\nOrg\n().\nwithOwner\n(\norgName\n)\n\n                \n.\nwithChatTeam\n(\nnew\n \nstub\n.\nChatTeam\n().\nwithId\n(\n\"NONESUCH\"\n).\nwithName\n(\n\"chatter\"\n).\nwithProvider\n(\n\"Slack\"\n))));\n\n    \nw\n.\nsendEvent\n(\nevent\n);\n\n\n});\n\n\n\n\n\nModifying projects\n\u00b6\n\n\nThe \u201cQuick Overview\u201d example above showed how the \nProjectScenarioWorld\n is used to look up and execute an editor.  The\napproach is similar for generators.\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nWhen\n,\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\n\nWhen\n(\n\"project generated\"\n,\n \n(\np\n: \nProject\n,\n \nw\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n    \nconst\n \ngenerator\n \n=\n \nw\n.\ngenerator\n(\n\"SomeGenerator\"\n);\n\n    \nw\n.\ngenerateWith\n(\ngenerator\n,\n \n\"new-project\"\n,\n \n{\n \nparam1\n:\n \n\"value1\"\n \n});\n\n\n});\n\n\n\n\n\nThe generator is looked up by name using the \ngenerator\n method on\n\nProjectScenarioWorld\n, providing the same name used as\nthe first argument to the \n@Generator\n decorator.  The\ngenerator is executed using the \ngenerateWith\n method.  The\n\ngenerateWith\n method takes three arguments: the generator, the name\nof the project to be generated, and a JavaScript object whose keys are\nthe names of the generator parameters and whose values are the values\nof those parameters.\n\n\nFailure\n\u00b6\n\n\nIf you want to simulate failure or discover in your \nWhere\n\nstep that your world is in an invalid state, the \nScenarioWorld\n interface provides a method to abort the scenario.  If\nyou are testing handlers, using the \nabort\n method would\nlook like this:\n\n\nimport\n \n{\n \nScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/ScenarioWorld\"\n;\n\n\nimport\n \n{\n \nWhen\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\n\nWhen\n(\n\"the scenario aborts\"\n,\n \n(\nw\n: \nScenarioWorld\n)\n \n=>\n \n{\n\n    \nw\n.\nabort\n();\n\n\n});\n\n\n\n\n\nIf you are testing editors and generators, it would look like this:\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/ScenarioWorld\"\n;\n\n\nimport\n \n{\n \nWhen\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\n\nWhen\n(\n\"the scenario aborts\"\n,\n \n(\np\n: \nProject\n,\n \nw\n: \nScenarioWorld\n)\n \n=>\n \n{\n\n    \nw\n.\nabort\n();\n\n\n});\n\n\n\n\n\nThe result of the above steps would be that the scenario is marked as\naborted, meaning that subsequent steps, aside from a test to see if\nthe scenario aborted, will not be attempted and marked as failed.\n\n\nAssertions\n\u00b6\n\n\nThe \nThen\n steps consist of one or more assertions about the\nfinal state of the scenario world.  The \nThen\n\nimplementation should return either \nboolean\n or\n\nvoid\n.  It is good practice for each step to be\nfine-grained, containing only a single assertion, so that reports are\nmaximally informative about what succeeded and failed.  The code of\neach failed assertion will be available in the test report provided by\nthe Rug CLI.\n\n\nThe \nScenarioWorld\n interface provides methods for\nchecking if parameters passed to a Rug were valid and checking if a\nscenario aborted, e.g., if a Rug throws an \nError\n.  The\nexample below shows how to use each of these methods in a handler\nscenario \nThen\n step.\n\n\nimport\n \n{\n \nScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/ScenarioWorld\"\n;\n\n\nimport\n \n{\n \nThen\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\n\nThen\n(\n\"the parameters were valid\"\n,\n \n(\nw\n: \nScenarioWorld\n)\n \n=>\n \n{\n\n    \nreturn\n \nw\n.\ninvalidParameters\n()\n \n==\n \nnull\n;\n\n\n});\n\n\n\nThen\n(\n\"it aborted\"\n,\n \n(\nw\n: \nScenarioWorld\n)\n \n=>\n \n{\n\n    \nreturn\n \nw\n.\naborted\n();\n\n\n});\n\n\n\n\n\nThe code would look similar for editor and generator scenario\n\nThen\n steps, except that you would import \nThen\n from \n@atomist/rug/test/project/Core\n and each callback would\naccept the arguments \n(\np\n: \nProject\n,\n \nw\n: \nScenarioWorld\n)\n.\nBut it is probably easier to use the well-known steps when testing\neditors and generators.\n\n\nThen \nparameters were valid\n\n\nThen \nparameters were invalid\n\n\nThen \nthe scenario aborted\n\n\n\n\n\nHandler assertions\n\u00b6\n\n\nHandlers return a \nPlan\n object, which is simply a data\nstructure.  You can easily examine them, checking messages and\ninstructions as appropriate.  For messages, you can check their\ncontent and addressing.  For instructions, you can check if they are\nof the right kind, are calling the right Rug, and have the proper\nresponse handlers.  A JavaScript assertion framework such\nas \nChai\n can help.  You can get the plan returned by a handler\nusing the \nplan\n method on \nHandlerScenarioWorld\n.\n\n\nimport\n \n{\n \nDirectedMessage\n \n}\n \nfrom\n \n\"@atomist/rug/operations/Handlers\"\n;\n\n\nimport\n \n{\n \nThen\n,\n \nEventHandlerScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/handler/Core\"\n;\n\n\n\nThen\n(\n\"the event handler should respond with the correct message\"\n,\n\n    \n(\nw\n: \nEventHandlerScenarioWorld\n)\n \n=>\n \n{\n\n        \nconst\n \nexpected\n \n=\n \n\"the message\"\n;\n\n        \nconst\n \nmessage\n \n=\n \nw\n.\nplan\n().\nmessages\n[\n0\n]\n \nas\n \nDirectedMessage\n;\n\n        \nreturn\n \nmessage\n.\nbody\n \n===\n \nexpected\n\n            \n&&\n \nmessage\n.\nchannelNames\n.\nlength\n \n===\n \n1\n\n            \n&&\n \nmessage\n.\nchannelNames\n[\n0\n]\n \n===\n \n\"#some-channel\"\n;\n\n    \n},\n\n\n);\n\n\n\n\n\nThe above example is for an event handler and uses \nEventHandlerScenarioWorld\n, which extends \nHandlerScenarioWorld\n, as the callback argument type.\n\n\nProject assertions\n\u00b6\n\n\nWhen testing editors and generators, the callback provided as the\nsecond argument to the \nThen\n accepts a \nProject\n and optional \nProjectScenarioWorld\n.  A typical\nassertion for a generator will assert that files will be created and\nhave the appropriate content.  The feature file might look like\n\n\nThen \nthe README exists\n\n\nThen \nthe README contains the project name\n\n\nThen \nthe class source file exists\n\n\nThen \nthe class source file contains the class name\n\n\n\n\n\nand those steps would be implemented\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nThen\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\n\nThen\n(\n\"the README exists\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nreturn\n \np\n.\nfileExists\n(\n\"README.md\"\n);\n\n\n});\n\n\n\nThen\n(\n\"the README contains the project name\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nreturn\n \np\n.\nfileContains\n(\n\"README.md\"\n,\n \np\n.\nname\n());\n\n\n});\n\n\n\nThen\n(\n\"the class source file exists\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nreturn\n \np\n.\nfileExists\n(\n\"src/main/java/Sugar.java\"\n);\n\n\n});\n\n\n\nThen\n(\n\"the class source file contains the class name\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nconst\n \nclassName\n \n=\n \n\"Sugar\"\n;\n\n    \nreturn\n \np\n.\nfileContains\n(\n\"src/main/java/Sugar.java\"\n,\n \n`class \n${\nclassName\n}\n`\n);\n\n\n});\n\n\n\n\n\nTesting that a file exists and that a file has certain contents are so\ncommon that well-known steps are provided for these assertions.\n\n\nThen \nfile at some/path/to/file.txt should exist\n\n\nThen \nfile at some/path/to/file.txt should contain something of interest\n\n\n\n\n\nThe first step asserts that the file \nsome/path/to/file.txt\n exists\nwhile the second asserts that the file contains the literal string\n\nsomething of interest\n.\n\n\nThe \nProjectScenarioWorld\n interface provides the\nfollowing methods to test the outcome of running an \neditor\n.\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nThen\n,\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\n\nThen\n(\n\"some changes were made\"\n,\n \n(\np\n: \nProject\n,\n \nw\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n    \nreturn\n \nw\n.\nmodificationsMade\n();\n\n\n});\n\n\n\nThen\n(\n\"the editor failed\"\n,\n \n(\np\n: \nProject\n,\n \nw\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n    \nreturn\n \nw\n.\nfailed\n();\n\n\n});\n\n\n\n\n\n\n\nFor editors only\n\n\nThe \nmodificationsMade\n and \nfailed\n\nmethods only consider editor operations.  They do not return\nmeaningful results when testing generators.\n\n\n\n\nThere are well-known steps to make using the above methods easier.\n\n\nThen \nchanges were made\n\n\nThen \nit should fail\n\n\n\n\n\nRug parameters\n\u00b6\n\n\nIf the Rug you are testing takes parameters, you pass them in as an\nobject whose property names are the parameter names.  For example,\nwith the \nProjectWorld\n.\neditWith\n function the parameter\nobject is passed as the second argument.  If the \nAlpEditor\n being\ntested below takes a single parameter named \nheir\n, you would set its\nvalue to \n\"Paul\"\n like this:\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nWhen\n,\n \nProjectScenarioWorld\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\n\nWhen\n(\n\"politics takes its course\"\n,\n \n(\np\n: \nProject\n,\n \nw\n: \nProjectScenarioWorld\n)\n \n=>\n \n{\n\n    \nw\n.\neditWith\n(\nw\n.\neditor\n(\n\"AlpEditor\"\n),\n \n{\nheir\n:\n \n\"Paul\"\n});\n\n\n});\n\n\n\n\n\nWell-known steps\n\u00b6\n\n\nA \u201cwell-known step\u201d is a named step that the Rug testing framework\ndefines for you.  You can refer to the step in the\nfeature file but do not have to define it in the steps file. Here are the\nwell-known steps available in handler scenarios.\n\n\n\n\n\n\n\n\nStep Type\n\n\nName\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nGiven\n\n\nnothing\n\n\nA cold, empty world\n\n\n\n\n\n\nGiven\n\n\nSomeHandler handler\n\n\nThe event handler \nSomeHandler\n is registered\n\n\n\n\n\n\nThen\n\n\nno handler fired\n\n\nThe \nPlan\n is \nnull\n\n\n\n\n\n\nThen\n\n\nhandler parameters were valid\n\n\nThe parameters passed to the Rug were valid\n\n\n\n\n\n\nThen\n\n\nhandler parameters were invalid\n\n\nThe parameters passed to the Rug were not valid\n\n\n\n\n\n\nThen\n\n\nplan has no messages\n\n\nThe \nPlan\n has no messages (it could still have instructions)\n\n\n\n\n\n\n\n\nHere are the well-known steps available in project scenarios.\n\n\n\n\n\n\n\n\nStep Type\n\n\nName\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nGiven\n\n\nan empty project\n\n\nAn empty project, useful for generators\n\n\n\n\n\n\nGiven\n\n\nthe archive root\n\n\nThe entire contents of the Rug archive providing the Rug being tested, including the \n.atomist\n directory\n\n\n\n\n\n\nGiven\n\n\narchive non Atomist content\n\n\nThe contents of the Rug archive providing the Rug being tested, excluding the \n.atomist\n directory\n\n\n\n\n\n\nGiven\n\n\ngithub someone/somerepo\n\n\nThe \nProject\n object made available to test steps will be the contents of the master branch of the GitHub.com \nsomeone/somerepo\n repository\n\n\n\n\n\n\nGiven\n\n\ngithub someone/somerepo/somebranch\n\n\nThe \nProject\n object made available to test steps will be the contents of the \nsomebranch\n branch of the GitHub.com \nsomeone/somerepo\n repository\n\n\n\n\n\n\nThen\n\n\nchanges were made\n\n\nThe \neditor\n made changes to the project\n\n\n\n\n\n\nThen\n\n\nno changes were made\n\n\nThe \neditor\n made no changes to the project\n\n\n\n\n\n\nThen\n\n\nparameters were valid\n\n\nThe parameters passed to the Rug were valid\n\n\n\n\n\n\nThen\n\n\nparameters were invalid\n\n\nThe parameters passed to the Rug were not valid\n\n\n\n\n\n\nThen\n\n\nfile at a/path/to/file should exist\n\n\nThe file \na/path/to/file\n exists in the resulting \nProject\n\n\n\n\n\n\nThen\n\n\nfile at a/path/to/file should contain blah blah\n\n\nThe file \na/path/to/file\n exists in the resulting \nProject\n and contains the literal string \nblah blah\n\n\n\n\n\n\nThen\n\n\nit should fail\n\n\nThe Rug runtime was unable to complete executing the Rug\n\n\n\n\n\n\nThen\n\n\nthe scenario aborted\n\n\nThe Rug being executed aborted, typically by throwing an exception\n\n\n\n\n\n\n\n\nIn the unlikely event you want to override a common step definition\nprovided by Atomist or yourself, you can define the same step in your\nstep definitions.  Your local definition will take precedence.\n\n\nDebugging hints\n\u00b6\n\n\nSometimes when testing, it is helpful to print out the contents of a\nfile to help you diagnose why a test is failing.  The Rug testing\nframework provides a few helper functions to provide insight to what\nchanges were made.\n\n\nTo print the entire contents of a project in the test output, use the\n\nHelpers\n.\nprettyListFiles\n function as follows:\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nThen\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\nimport\n \n*\n \nas\n \nhelpers\n \nfrom\n \n\"@atomist/rug/test/project/Helpers\"\n;\n\n\n\nThen\n(\n\"the README exists\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nconsole\n.\nlog\n(\nhelpers\n.\nprettyListFiles\n(\np\n));\n\n    \nreturn\n \np\n.\nfileExists\n(\n\"README.md\"\n);\n\n\n});\n\n\n\n\n\nTo see the contents of a file in the test output, use the\n\nHelpers\n.\ndump\n function.\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/rug/model/Project\"\n;\n\n\nimport\n \n{\n \nThen\n \n}\n \nfrom\n \n\"@atomist/rug/test/project/Core\"\n;\n\n\nimport\n \n*\n \nas\n \nhelpers\n \nfrom\n \n\"@atomist/rug/test/project/Helpers\"\n;\n\n\n\nThen\n(\n\"the README exists\"\n,\n \n(\np\n: \nProject\n)\n \n=>\n \n{\n\n    \nconsole\n.\nlog\n(\nhelpers\n.\ndump\n(\np\n,\n \n\"README.md\"\n));\n\n    \nreturn\n \np\n.\nfileExists\n(\n\"README.md\"\n);\n\n\n});\n\n\n\n\n\nNot currently supported\n\u00b6\n\n\nRug Test does not yet support the full range of Gherkin functionality.\nThe following features are missing:\n\n\n\n\nDoc strings\n\n\nData tables\n\n\nTags\n\n\n\n\nThese may be supported in a future version of Rug.\n\n\nFuture directions\n\u00b6\n\n\n\n\nThe need for more than one source file for each feature is both a\n    strength and weakness of Gherkin.  It\u2019s a strength because each\n    file is in a single, logical, toolable language.  It\u2019s a weakness\n    because of the level of ceremony required and because of the\n    brittle linkage by a string value.  We intend to provide editors\n    that helps with this, automatically creating feature files for\n    editors, and TypeScript files implementing the steps in feature\n    files.\n\n\nIn a future release, BDD testing support will be extended beyond\n    project operations to event handlers.",
            "title": "Tests"
        },
        {
            "location": "/user-guide/rug/tests/#approach",
            "text": "Rug is designed to support  Test Driven Development  using unit\ntests and BDD.  We recommend following the \u201cred \u2192 green \u2192\nrefactor\u201d approach.   Prerequisites  You will need the  Rug CLI  and  Node.js \ninstalled to run tests.   For unit testing, we recommend using the  Mocha  framework\nwith  Power Assert .  You should put your Mocha unit\ntests in the  .atomist/mocha  directory to avoid conflicts with where\nthe Rug CLI looks for the BDD tests.  With this setup, your .atomist/package.json  would look something like this:  { \n   \"dependencies\" :   { \n     \"@atomist/rugs\" :   \"^1.0.0-m.4\" \n   }, \n   \"devDependencies\" :   { \n     \"@types/mocha\" :   \"^2.2.40\" , \n     \"@types/power-assert\" :   \"^1.4.29\" , \n     \"espower-typescript\" :   \"^8.0.0\" , \n     \"mocha\" :   \"^3.2.0\" , \n     \"power-assert\" :   \"^1.4.2\" , \n     \"tslint\" :   \"^5.0.0\" , \n     \"typescript\" :   \"2.3.2\" \n   }, \n   \"directories\" :   { \n     \"test\" :   \"mocha\" \n   }, \n   \"scripts\" :   { \n     \"lint\" :   \"tslint '**/*.ts' --exclude 'node_modules/**' -t verbose\" , \n     \"mocha\" :   \"mocha --compilers ts:espower-typescript/guess 'mocha/**/*.ts'\" , \n     \"test\" :   \"npm run mocha && rug test\" \n   }  }   and you can run your unit tests with the following command:  $   (   cd  .atomist  &&  npm run mocha  )   or run both the unit and BDD tests with this command:  $   (   cd  .atomist  &&  npm  test   )   The documentation for  Mocha  and  Power Assert \ncan help you get started with unit testing in TypeScript/JavaScript.\nThe rest of this document focuses on Rug BDD testing.",
            "title": "Approach"
        },
        {
            "location": "/user-guide/rug/tests/#quick-overview",
            "text": "Before taking a deeper dive into the Rug BDD approach, let\u2019s look at\nan example.  Consider the following simple editor that will rename a Java file.  import   {   EditProject   }   from   '@atomist/rug/operations/ProjectEditor' ;  import   {   Editor   }   from   '@atomist/rug/operations/Decorators' ;  import   {   Project   }   from   '@atomist/rug/model/Core' ;  import   {   PathExpressionEngine   }   from   '@atomist/rug/tree/PathExpression' ;  import   {   JavaClass   }   from   '@atomist/rug/model/JavaClass' ;  @Editor ( \"Renamer\" ,   \"Renames Java class\" )  export   class   Renamer   { \n\n     edit ( project :  Project )   { \n         const   eng   =   project . context . pathExpressionEngine ; \n         eng . with < JavaClass > ( project ,   \"//JavaClass()[@name='Dog']\" ,   jc   =>   { \n             jc . rename ( \"Cat\" ); \n         }); \n     }  }   We want to test that the editor works as intended.  First, we write a\nGherkin  .feature  file that is an easily readable description of the\nbehaviors we expect.  We\u2019ll name the file  Renaming.feature  and place it\nunder  .atomist/tests/project .  Feature:  Renaming a Java file    We should be able to rename Java files.    Specifically, we should be able to rename    dog files into cat files.     Scenario:  Dogs can be turned into cats      Given  a file named src/main/java/Dog.java       When  edit with Renamer       Then  there should be one file       Then  the file is now src/main/java/Cat.java   Walking through this definition:   The syntax is standard Gherkin.  It is human-readable and contains\n    a specification of the desired behavior, but not how that behavior\n    is to be verified.  A Gherkin  feature  can contain one or more  scenarios . You can\n    include as many feature files in the  .atomist/tests/project \n    directory as you like.  Each scenario is typically broken down into three blocks of\n     given ,  when , and  then  steps, following the BDD style.\n    Typically there is a single  when  step\u2013the execution of a Rug.\n    There are often multiple  given  and  then  steps.   Then  steps\n    are assertions, and it is good practice to break them up for\n    clarity, so failures are specific.    The Rug Gherkin parser does not support the  And  keyword.  Just\nuse the appropriate step keyword multiple times.   We now have a clear specification of the desired behavior.  How does\nthe test infrastructure know how to execute these steps?  As in  cucumber-js , we delegate to JavaScript or TypeScript to\nexecute these steps.  In keeping with our general preference for\nTypeScript, let\u2019s see the TypeScript steps corresponding to the above\nfeature:  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   Given ,   When ,   Then ,   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  Given ( \"a file named src/main/java/Dog.java\" ,   ( p :  Project )   =>   { \n     p . addFile ( \"src/main/java/Dog.java\" ,   \"public class Dog {}\" );  });  When ( \"edit with Renamer\" ,   ( p :  Project ,   w :  ProjectScenarioWorld )   =>   { \n     const   editor   =   w . editor ( \"Renamer\" ); \n     w . editWith ( editor ,   {});  });  Then ( \"there should be one file\" ,   ( p :  Project )   =>   { \n     return   p . totalFileCount ()   ===   1 ;  });  Then ( \"the file is now src/main/java/Cat.java\" ,   ( p :  Project )   =>   { \n     return   p . fileExists ( \"src/main/java/Cat.java\" );  });   We start by importing Rug modules needed for testing, namely Project , the core test functions  Given , When , and  Then , and the testing module ProjectScenarioWorld , which provides the context in\nwhich each scenario runs.  Step definitions are linked to the steps in the feature via strings,\nsuch as  \"a file named src/main/java/Dog.java\" .  The\nfirst argument for each type of step is a string that should match the\nstring after the same step type in the feature file.  The second\nargument is a function, i.e., callback, that implements the step.\nThis step-implementing function takes two arguments.  The first\nargument is a  Project  object and the second optional\nargument is a  ProjectScenarioWorld .  You can see only\nthe  When  step uses the optional second argument, so it\nis the only one that declares it (see below for more details\non  worlds ).  Step definitions may be provided in any\nTypeScript or JavaScript file under  .atomist/tests/project . They\nwill be loaded automatically by the test infrastructure.  Different scenarios and even different features may share step\ndefinitions.  This is beneficial in the case of common steps, e.g., Given  an empty archive , which can be shared across many\nfeatures and scenarios.",
            "title": "Quick overview"
        },
        {
            "location": "/user-guide/rug/tests/#worlds",
            "text": "As mentioned briefly above, each scenario has a  world  in which it\nexecutes.  A  world  is an isolated context for each scenario\nexecution that allows you to control how your Rug is being tested and\nhow the results of the tests are evaluated.  The scenario\u2019s world is\nencapsulated in the TypeScript  ScenarioWorld  interface\nand made available to the functions implementing each step in the\nscenario.  The modifications made to the scenario\u2019s world in each step\nis visible to all subsequent steps in the scenario.  So the scenario\u2019s\nworld is, more or less, the  state  of the scenario at each step.  The type of world made available to each scenario depends on what is\nbeing tested.  When testing handlers, the world provided to the\nfunctions implementing the steps is a derivative of  HandlerScenarioWorld .   HandlerScenarioWorld  extends ScenarioWorld , adding handler-specific methods such as\nthe ability to verify created plans.  The handler scenario world is\nthe first argument to all the functions implementing the handler\nscenario steps.  For example, the declaration for the  When  function is effectively:  import   {   HandlerScenarioWorld   }   from   \"@atomist/rug/test/handler/Core\" ;  export   function   When ( s :  string ,   f :   ( HandlerScenarioWorld )   =>   void );   When testing Rugs that deal with projects, e.g., generators and\neditors, the world provided to the function implementing the scenario\nsteps is a  ProjectScenarioWorld .  The  ProjectScenarioWorld  interface extends  ScenarioWorld ,\nadding functions to find and execute editors and generators, query the\nnumber of modifications made, and see if editing succeeded.  The\nscenario world is an optional second parameter to the function that\nimplements each scenario step.  For example, the declaration of the Given  function is effectively:  import   {   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  export   function   Given ( s :  string ,   f :   ( Project ,   ProjectScenarioWorld ? )   =>   void );   In practice, what you do with the scenario\u2019s world depends on what phase  of the scenario you are in.  Each BDD testing scenario has\nthree phases, mapping directly to the different types of Gherkin\nsteps:   Setup : the  Given  steps are used to set up\n    testing prerequisites within the world  Execution : the action being tested is executed on\n    the world in the  When  step  Assertions : the state of the scenario\u2019s world is\n    interrogated in the  Then  steps   In the following sections, we will delve into each of these phases and\ndescribe in detail how the scenario\u2019s world can be used in each phase\nto enable testing.",
            "title": "Worlds"
        },
        {
            "location": "/user-guide/rug/tests/#setup",
            "text": "The  Given  step is used to set up a world for a testing\nscenario.  Many testing scenarios can be entirely setup using\na  \u201cwell-known step\u201d , but sometimes you need to customize\nfor your particular scenario.",
            "title": "Setup"
        },
        {
            "location": "/user-guide/rug/tests/#handler-setup",
            "text": "When testing command handlers, you almost always use the \u201cnothing\u201d\nwell-known step that, as you might expect, does nothing.  Given  nothing   As with all well-known steps, you do not need to supply an\nimplementation, one is already available to the BDD tests by Rug.  To avoid unwanted side effects during testing, the testing framework\nwill only consider executing event handlers that are explicitly\nregistered within a scenario.  Thus, the setup for event handler\ntesting typically involves registering the event handler being tested\nin the  Given  step.  The following Gherkin step:  Given  HandlerToTest is registered   could be implemented using the following TypeScript function:  import   {   Given ,   EventHandlerScenarioWorld   }   from   \"@atomist/rug/test/handler/Core\" ;  Given ( \"HandlerToTest is registered\" ,   ( w :  EventHandlerScenarioWorld )   =>   { \n     w . registerHandler ( \"HandlerToTest\" );  });   The event handler is looked up by name using the  registerHandler  method of  EventHandlerScenarioWorld ,\nwhich extends  HandlerScenarioWorld  with event handler\nspecific methods.  The name used should be the same as the first\nargument to the  @EventHandler  decorator.  If the\nhandler cannot be found in the current archive, the test scenario will\nfail.  Since this is so common, there is a well-known step for it.  Given  HandlerToTest handler   The above step in a feature file will register the \u201cHandlerToTest\u201d\nevent handler for a scenario.  You do not need to supply an\nimplementation.",
            "title": "Handler setup"
        },
        {
            "location": "/user-guide/rug/tests/#project-setup",
            "text": "When testing generators you typically start with an empty project,\nwhich is provided as a well-known step.  Given  an empty project   Customizations when testing editors typically involve a series of\nsteps, each creating a file to populate the project for testing.  As\nan example, consider the  Given  steps below.  Given  a project POM  Given  a Java source file   These steps could be implemented with the following TypeScript\nfunctions.  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   Given   }   from   \"@atomist/rug/test/project/Core\" ;  Given ( \"a project POM\" ,   ( p :  Project )   =>   { \n     p . addFile ( \"pom.xml\" ,   `<?xml version=\"1.0\" encoding=\"UTF-8\"?>  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">      <modelVersion>4.0.0</modelVersion>      <groupId>atomist</groupId>      <artifactId>ruggery</artifactId>      <version>0.1.0-SNAPSHOT</version>  </project>  ` );  });  Given ( \"a Java source file\" ,   ( p :  Project )   =>   { \n     p . addFile ( \"src/main/java/Some.java\" ,   `public class Some {}` );  });   There are also well-known steps for populating the project to be\ntested with the contents of the Rug project itself.  The first copies\nthe entire contents of the Rug project, including the  .atomist \ndirectory, into the project being used in the test.  Given  the archive root   The second form copies everything  but  the  .atomist  directory into\nthe project being used in the test.  Given  archive non Atomist content",
            "title": "Project setup"
        },
        {
            "location": "/user-guide/rug/tests/#execution",
            "text": "For each scenario there is typically one  When  step\ntriggering a single action, sending an event or invoking a command\nhandler, editor, or generator.",
            "title": "Execution"
        },
        {
            "location": "/user-guide/rug/tests/#triggering-command-handlers",
            "text": "A command handler is typically triggered from within chat by someone\nsending the Atomist Bot a message with the command handler\u2019s intent.\nTo simulate this action in the testing framework, you use the invokeHandler  method.  import   {   CommandHandlerScenarioWorld ,   When   }   from   \"@atomist/rug/test/handler/Core\" ;  When ( \"the TestCommandHandler is invoked\" ,   ( w :  CommandHandlerScenarioWorld )   =>   { \n     const   handler   =   w . commandHandler ( \"TestCommandHandler\" ); \n     w . invokeHandler ( handler ,   {});  });   The  CommandHandlerScenarioWorld  interface used above\ninherits from  HandlerScenarioWorld , adding methods\nspecific to command handlers.  Before invoking the command handler,\nyou use the  CommandHandlerScenarioWorld  object to\nlookup the handler by name using the  commandHandler \nmethod.  The name you provide is the same as the name used in the @CommandHandler  decorator.",
            "title": "Triggering command handlers"
        },
        {
            "location": "/user-guide/rug/tests/#sending-events",
            "text": "To simulate an event occurring when testing an event handler, you\nfirst create the appropriate  event object  from the classes\nin the  cortex/stub  directory.  Then, you use the  sendEvent  method\nof  EventHandlerScenarioWorld  to trigger the receipt of\nthat event.  import   *   as   stub   from   \"@atomist/cortex/stub/Types\" ;  import   {   When ,   EventHandlerScenarioWorld   }   from   \"@atomist/rug/test/handler/Core\" ;  When ( \"a new Tag is received\" ,   ( w :  EventHandlerScenarioWorld )   =>   { \n     const   event   =   new   stub . Tag (); \n     w . sendEvent ( event );  });   Remember that you must have registered an event handler that responds\nto that exact kind of event.  You can create arbitrarily complex\nevents using the \u201cstub\u201d objects.  import   *   as   stub   from   \"@atomist/cortex/stub/Types\" ;  import   {   When ,   EventHandlerScenarioWorld   }   from   \"@atomist/rug/test/handler/Core\" ;  When ( \"an initial commit is received\" ,   ( w :  EventHandlerScenarioWorld )   =>   { \n     const   event   =   new   stub . Push () \n         . addCommits ( new   stub . Commit (). withMessage ( \"initial commit by Atomist\" )) \n         . withRepo ( new   stub . Repo (). withName ( repoName ). withOwner ( orgName ) \n             . withOrg ( new   stub . Org (). withOwner ( orgName ) \n                 . withChatTeam ( new   stub . ChatTeam (). withId ( \"NONESUCH\" ). withName ( \"chatter\" ). withProvider ( \"Slack\" )))); \n     w . sendEvent ( event );  });",
            "title": "Sending events"
        },
        {
            "location": "/user-guide/rug/tests/#modifying-projects",
            "text": "The \u201cQuick Overview\u201d example above showed how the  ProjectScenarioWorld  is used to look up and execute an editor.  The\napproach is similar for generators.  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   When ,   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  When ( \"project generated\" ,   ( p :  Project ,   w :  ProjectScenarioWorld )   =>   { \n     const   generator   =   w . generator ( \"SomeGenerator\" ); \n     w . generateWith ( generator ,   \"new-project\" ,   {   param1 :   \"value1\"   });  });   The generator is looked up by name using the  generator  method on ProjectScenarioWorld , providing the same name used as\nthe first argument to the  @Generator  decorator.  The\ngenerator is executed using the  generateWith  method.  The generateWith  method takes three arguments: the generator, the name\nof the project to be generated, and a JavaScript object whose keys are\nthe names of the generator parameters and whose values are the values\nof those parameters.",
            "title": "Modifying projects"
        },
        {
            "location": "/user-guide/rug/tests/#failure",
            "text": "If you want to simulate failure or discover in your  Where \nstep that your world is in an invalid state, the  ScenarioWorld  interface provides a method to abort the scenario.  If\nyou are testing handlers, using the  abort  method would\nlook like this:  import   {   ScenarioWorld   }   from   \"@atomist/rug/test/ScenarioWorld\" ;  import   {   When   }   from   \"@atomist/rug/test/handler/Core\" ;  When ( \"the scenario aborts\" ,   ( w :  ScenarioWorld )   =>   { \n     w . abort ();  });   If you are testing editors and generators, it would look like this:  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   ScenarioWorld   }   from   \"@atomist/rug/test/ScenarioWorld\" ;  import   {   When   }   from   \"@atomist/rug/test/project/Core\" ;  When ( \"the scenario aborts\" ,   ( p :  Project ,   w :  ScenarioWorld )   =>   { \n     w . abort ();  });   The result of the above steps would be that the scenario is marked as\naborted, meaning that subsequent steps, aside from a test to see if\nthe scenario aborted, will not be attempted and marked as failed.",
            "title": "Failure"
        },
        {
            "location": "/user-guide/rug/tests/#assertions",
            "text": "The  Then  steps consist of one or more assertions about the\nfinal state of the scenario world.  The  Then \nimplementation should return either  boolean  or void .  It is good practice for each step to be\nfine-grained, containing only a single assertion, so that reports are\nmaximally informative about what succeeded and failed.  The code of\neach failed assertion will be available in the test report provided by\nthe Rug CLI.  The  ScenarioWorld  interface provides methods for\nchecking if parameters passed to a Rug were valid and checking if a\nscenario aborted, e.g., if a Rug throws an  Error .  The\nexample below shows how to use each of these methods in a handler\nscenario  Then  step.  import   {   ScenarioWorld   }   from   \"@atomist/rug/test/ScenarioWorld\" ;  import   {   Then   }   from   \"@atomist/rug/test/handler/Core\" ;  Then ( \"the parameters were valid\" ,   ( w :  ScenarioWorld )   =>   { \n     return   w . invalidParameters ()   ==   null ;  });  Then ( \"it aborted\" ,   ( w :  ScenarioWorld )   =>   { \n     return   w . aborted ();  });   The code would look similar for editor and generator scenario Then  steps, except that you would import  Then  from  @atomist/rug/test/project/Core  and each callback would\naccept the arguments  ( p :  Project ,   w :  ScenarioWorld ) .\nBut it is probably easier to use the well-known steps when testing\neditors and generators.  Then  parameters were valid  Then  parameters were invalid  Then  the scenario aborted",
            "title": "Assertions"
        },
        {
            "location": "/user-guide/rug/tests/#handler-assertions",
            "text": "Handlers return a  Plan  object, which is simply a data\nstructure.  You can easily examine them, checking messages and\ninstructions as appropriate.  For messages, you can check their\ncontent and addressing.  For instructions, you can check if they are\nof the right kind, are calling the right Rug, and have the proper\nresponse handlers.  A JavaScript assertion framework such\nas  Chai  can help.  You can get the plan returned by a handler\nusing the  plan  method on  HandlerScenarioWorld .  import   {   DirectedMessage   }   from   \"@atomist/rug/operations/Handlers\" ;  import   {   Then ,   EventHandlerScenarioWorld   }   from   \"@atomist/rug/test/handler/Core\" ;  Then ( \"the event handler should respond with the correct message\" , \n     ( w :  EventHandlerScenarioWorld )   =>   { \n         const   expected   =   \"the message\" ; \n         const   message   =   w . plan (). messages [ 0 ]   as   DirectedMessage ; \n         return   message . body   ===   expected \n             &&   message . channelNames . length   ===   1 \n             &&   message . channelNames [ 0 ]   ===   \"#some-channel\" ; \n     },  );   The above example is for an event handler and uses  EventHandlerScenarioWorld , which extends  HandlerScenarioWorld , as the callback argument type.",
            "title": "Handler assertions"
        },
        {
            "location": "/user-guide/rug/tests/#project-assertions",
            "text": "When testing editors and generators, the callback provided as the\nsecond argument to the  Then  accepts a  Project  and optional  ProjectScenarioWorld .  A typical\nassertion for a generator will assert that files will be created and\nhave the appropriate content.  The feature file might look like  Then  the README exists  Then  the README contains the project name  Then  the class source file exists  Then  the class source file contains the class name   and those steps would be implemented  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   Then   }   from   \"@atomist/rug/test/project/Core\" ;  Then ( \"the README exists\" ,   ( p :  Project )   =>   { \n     return   p . fileExists ( \"README.md\" );  });  Then ( \"the README contains the project name\" ,   ( p :  Project )   =>   { \n     return   p . fileContains ( \"README.md\" ,   p . name ());  });  Then ( \"the class source file exists\" ,   ( p :  Project )   =>   { \n     return   p . fileExists ( \"src/main/java/Sugar.java\" );  });  Then ( \"the class source file contains the class name\" ,   ( p :  Project )   =>   { \n     const   className   =   \"Sugar\" ; \n     return   p . fileContains ( \"src/main/java/Sugar.java\" ,   `class  ${ className } ` );  });   Testing that a file exists and that a file has certain contents are so\ncommon that well-known steps are provided for these assertions.  Then  file at some/path/to/file.txt should exist  Then  file at some/path/to/file.txt should contain something of interest   The first step asserts that the file  some/path/to/file.txt  exists\nwhile the second asserts that the file contains the literal string something of interest .  The  ProjectScenarioWorld  interface provides the\nfollowing methods to test the outcome of running an  editor .  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   Then ,   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  Then ( \"some changes were made\" ,   ( p :  Project ,   w :  ProjectScenarioWorld )   =>   { \n     return   w . modificationsMade ();  });  Then ( \"the editor failed\" ,   ( p :  Project ,   w :  ProjectScenarioWorld )   =>   { \n     return   w . failed ();  });    For editors only  The  modificationsMade  and  failed \nmethods only consider editor operations.  They do not return\nmeaningful results when testing generators.   There are well-known steps to make using the above methods easier.  Then  changes were made  Then  it should fail",
            "title": "Project assertions"
        },
        {
            "location": "/user-guide/rug/tests/#rug-parameters",
            "text": "If the Rug you are testing takes parameters, you pass them in as an\nobject whose property names are the parameter names.  For example,\nwith the  ProjectWorld . editWith  function the parameter\nobject is passed as the second argument.  If the  AlpEditor  being\ntested below takes a single parameter named  heir , you would set its\nvalue to  \"Paul\"  like this:  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   When ,   ProjectScenarioWorld   }   from   \"@atomist/rug/test/project/Core\" ;  When ( \"politics takes its course\" ,   ( p :  Project ,   w :  ProjectScenarioWorld )   =>   { \n     w . editWith ( w . editor ( \"AlpEditor\" ),   { heir :   \"Paul\" });  });",
            "title": "Rug parameters"
        },
        {
            "location": "/user-guide/rug/tests/#well-known-steps",
            "text": "A \u201cwell-known step\u201d is a named step that the Rug testing framework\ndefines for you.  You can refer to the step in the\nfeature file but do not have to define it in the steps file. Here are the\nwell-known steps available in handler scenarios.     Step Type  Name  Meaning      Given  nothing  A cold, empty world    Given  SomeHandler handler  The event handler  SomeHandler  is registered    Then  no handler fired  The  Plan  is  null    Then  handler parameters were valid  The parameters passed to the Rug were valid    Then  handler parameters were invalid  The parameters passed to the Rug were not valid    Then  plan has no messages  The  Plan  has no messages (it could still have instructions)     Here are the well-known steps available in project scenarios.     Step Type  Name  Meaning      Given  an empty project  An empty project, useful for generators    Given  the archive root  The entire contents of the Rug archive providing the Rug being tested, including the  .atomist  directory    Given  archive non Atomist content  The contents of the Rug archive providing the Rug being tested, excluding the  .atomist  directory    Given  github someone/somerepo  The  Project  object made available to test steps will be the contents of the master branch of the GitHub.com  someone/somerepo  repository    Given  github someone/somerepo/somebranch  The  Project  object made available to test steps will be the contents of the  somebranch  branch of the GitHub.com  someone/somerepo  repository    Then  changes were made  The  editor  made changes to the project    Then  no changes were made  The  editor  made no changes to the project    Then  parameters were valid  The parameters passed to the Rug were valid    Then  parameters were invalid  The parameters passed to the Rug were not valid    Then  file at a/path/to/file should exist  The file  a/path/to/file  exists in the resulting  Project    Then  file at a/path/to/file should contain blah blah  The file  a/path/to/file  exists in the resulting  Project  and contains the literal string  blah blah    Then  it should fail  The Rug runtime was unable to complete executing the Rug    Then  the scenario aborted  The Rug being executed aborted, typically by throwing an exception     In the unlikely event you want to override a common step definition\nprovided by Atomist or yourself, you can define the same step in your\nstep definitions.  Your local definition will take precedence.",
            "title": "Well-known steps"
        },
        {
            "location": "/user-guide/rug/tests/#debugging-hints",
            "text": "Sometimes when testing, it is helpful to print out the contents of a\nfile to help you diagnose why a test is failing.  The Rug testing\nframework provides a few helper functions to provide insight to what\nchanges were made.  To print the entire contents of a project in the test output, use the Helpers . prettyListFiles  function as follows:  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   Then   }   from   \"@atomist/rug/test/project/Core\" ;  import   *   as   helpers   from   \"@atomist/rug/test/project/Helpers\" ;  Then ( \"the README exists\" ,   ( p :  Project )   =>   { \n     console . log ( helpers . prettyListFiles ( p )); \n     return   p . fileExists ( \"README.md\" );  });   To see the contents of a file in the test output, use the Helpers . dump  function.  import   {   Project   }   from   \"@atomist/rug/model/Project\" ;  import   {   Then   }   from   \"@atomist/rug/test/project/Core\" ;  import   *   as   helpers   from   \"@atomist/rug/test/project/Helpers\" ;  Then ( \"the README exists\" ,   ( p :  Project )   =>   { \n     console . log ( helpers . dump ( p ,   \"README.md\" )); \n     return   p . fileExists ( \"README.md\" );  });",
            "title": "Debugging hints"
        },
        {
            "location": "/user-guide/rug/tests/#not-currently-supported",
            "text": "Rug Test does not yet support the full range of Gherkin functionality.\nThe following features are missing:   Doc strings  Data tables  Tags   These may be supported in a future version of Rug.",
            "title": "Not currently supported"
        },
        {
            "location": "/user-guide/rug/tests/#future-directions",
            "text": "The need for more than one source file for each feature is both a\n    strength and weakness of Gherkin.  It\u2019s a strength because each\n    file is in a single, logical, toolable language.  It\u2019s a weakness\n    because of the level of ceremony required and because of the\n    brittle linkage by a string value.  We intend to provide editors\n    that helps with this, automatically creating feature files for\n    editors, and TypeScript files implementing the steps in feature\n    files.  In a future release, BDD testing support will be extended beyond\n    project operations to event handlers.",
            "title": "Future directions"
        },
        {
            "location": "/user-guide/rug/projects/",
            "text": "A key design goal for Rug was to respect your own tooling as much as\npossible so that \nevery project could be a working Atomist project,\nand every Atomist project remains a working project\n.  Therefore,\nAtomist files reside unobtrusively within your existing projects.\nSpecifically, Atomist files reside in a directory named \n.atomist\n at\nthe root of your project\u2019s source code hierarchy.  Any project that\nhas a \n.atomist\n directory at its root with a valid \npackage.json\n.\n\n\nThe \n.atomist\n directory\n\u00b6\n\n\nA typical Rug project will have a \n.atomist\n directory that looks\nsomething like the following.\n\n\n.atomist\n\n\n\u251c\u2500\u2500 build/\n\n\n\u251c\u2500\u2500 editors/\n\n\n\u251c\u2500\u2500 generators/\n\n\n\u251c\u2500\u2500 handlers/\n\n\n\u251c\u2500\u2500 mocha/\n\n\n\u251c\u2500\u2500 node_modules/\n\n\n\u251c\u2500\u2500 package.json\n\n\n\u251c\u2500\u2500 reviewers/\n\n\n\u251c\u2500\u2500 target/\n\n\n\u251c\u2500\u2500 templates/\n\n\n\u251c\u2500\u2500 tests/\n\n\n\u2514\u2500\u2500 tsconfig.json\n\n\n\n\n\nThe only required file in the \n.atomist\n directory is the\n\npackage.json\n.  The table below explains each entry.\n\n\n\n\n\n\n\n\nEntry\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuild\n\n\ncontains CI build scripts and configuration\n\n\n\n\n\n\neditors\n\n\ncontains Rug editors\n\n\n\n\n\n\ngenerators\n\n\ncontains Rug generators\n\n\n\n\n\n\nhandlers\n\n\ncontains Rug command and event handlers\n\n\n\n\n\n\nmocha\n\n\ncontains \nMocha\n unit tests\n\n\n\n\n\n\nnode_modules\n\n\ncontains source code for TypeScript typings and dependencies installed by \nNPM\n\n\n\n\n\n\npackage.json\n\n\nRug project metadata within a standard NPM \npackage.json\n file declaring the TypeScript dependencies, \nrequired\n\n\n\n\n\n\nreviewers\n\n\ncontains Rug reviewers\n\n\n\n\n\n\ntarget\n\n\ncontains files generated by the Rug CLI during building and packaging\n\n\n\n\n\n\ntemplates\n\n\ncontains templates used by Rugs\n\n\n\n\n\n\ntests\n\n\ncontains Rug tests\n\n\n\n\n\n\ntsconfig.json\n\n\nTypeScript compiler options useful for IDE TypeScript tooling\n\n\n\n\n\n\n\n\n\n\nThe \ntsconfig.json\n is \nnot\n used by the Rug CLI when compiling TypeScript.\n\n\n\n\nMetadata\n\u00b6\n\n\nThe \n.atomist/package.json\n file contains the Rug archive project\nmetadata.  The \npackage.json\n file is a\nstandard \nNPM package.json file\n.  Typical contents for\nthe \npackage.json\n will look like:\n\n\n{\n\n  \n\"name\"\n:\n \n\"@my-org/my-rug-project\"\n,\n\n  \n\"description\"\n:\n \n\"Atomist Rugs used in the end-user documentation\"\n,\n\n  \n\"version\"\n:\n \n\"0.1.0\"\n,\n\n  \n\"author\"\n:\n \n\"My Company\"\n,\n\n  \n\"repository\"\n:\n \n{\n\n    \n\"type\"\n:\n \n\"git\"\n,\n\n    \n\"url\"\n:\n \n\"https://github.com/atomist/my-rug-project.git\"\n\n  \n},\n\n  \n\"keywords\"\n:\n \n[\n\n    \n\"atomist\"\n,\n\n    \n\"rug\"\n\n  \n],\n\n  \n\"homepage\"\n:\n \n\"https://github.com/atomist/my-rug-project#readme\"\n,\n\n  \n\"bugs\"\n:\n \n{\n\n    \n\"url\"\n:\n \n\"https://github.com/atomist/my-rug-project/issues\"\n\n  \n},\n\n  \n\"dependencies\"\n:\n \n{\n\n    \n\"@atomist/rugs\"\n:\n \n\"^1.0.0-m.5\"\n\n  \n},\n\n  \n\"devDependencies\"\n:\n \n{\n\n    \n\"@types/mocha\"\n:\n \n\"^2.2.40\"\n,\n\n    \n\"@types/power-assert\"\n:\n \n\"^1.4.29\"\n,\n\n    \n\"espower-typescript\"\n:\n \n\"^8.0.0\"\n,\n\n    \n\"mocha\"\n:\n \n\"^3.2.0\"\n,\n\n    \n\"power-assert\"\n:\n \n\"^1.4.2\"\n,\n\n    \n\"tslint\"\n:\n \n\"^5.0.0\"\n,\n\n    \n\"typescript\"\n:\n \n\"2.3.2\"\n\n  \n},\n\n  \n\"directories\"\n:\n \n{\n\n    \n\"test\"\n:\n \n\"mocha\"\n\n  \n},\n\n  \n\"scripts\"\n:\n \n{\n\n    \n\"autotest\"\n:\n \n\"supervisor -q -n exit -e ts -x npm -- run mocha\"\n,\n\n    \n\"lint\"\n:\n \n\"tslint '**/*.ts' --exclude 'node_modules/**' -t verbose\"\n,\n\n    \n\"mocha\"\n:\n \n\"mocha --compilers ts:espower-typescript/guess 'mocha/**/*.ts'\"\n,\n\n    \n\"test\"\n:\n \n\"npm run mocha && rug test\"\n\n  \n},\n\n  \n\"atomist\"\n:\n \n{\n\n    \n\"requires\"\n:\n \n\"[1.0.0-m.4,2.0.0)\"\n\n  \n}\n\n\n}\n\n\n\n\n\nYou can see this is a standard NPM package.json file with the addition\nof the \n\"atomist\"\n section.  In this example, the only\nparameter in the \n\"atomist\"\n section is \n\"requires\"\n,\nwhich specifies the unique coordinates of the Rug archive: its group,\nname and version. Dependencies and extensions may also be declared:\n\n\n\n\n\n\n\n\nKey\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\"requires\"\n\n\nThe Rug runtime version this project is being developed with. Version range is allowed\n\n\n\n\n\n\n\"dependencies\"\n\n\nList of project dependencies in form group:artifact:version. Version ranges are allowed\n\n\n\n\n\n\n\"extensions\"\n\n\nList of binary dependencies, e.g., Rug Extension types. Version ranges are allowed\n\n\n\n\n\n\n\n\nDependencies\n\u00b6\n\n\nA Rug project can have four different types of dependencies:\n\n\n\n\nRug runtime dependency\n\n\nOther Rug archives\n\n\nRug extensions\n\n\nTypeScript types\n\n\n\n\nRuntime\n\u00b6\n\n\nThe Rug runtime dependency is specified using the \n.atomist.requires\n\nkey in the \npackage.json\n.  The value of the \nrequires\n key is a\nstring that specifies either an exact Rug runtime version or a version\nrange using the Maven \nversion range\n.  The following\nwould cause the Rugs in the project to only executed by Rug runtime\nversion 0.13.0.\n\n\n\"atomist\"\n:\n \n{\n\n  \n\"requires\"\n:\n \n\"0.13.0\"\n\n\n}\n\n\n\n\n\nIn contrast, the following specification could run under any version\nof the Rug runtime from 0.13.0, inclusive, up to, but not including,\nversion 1.0.0.\n\n\n\"atomist\"\n:\n \n{\n\n  \n\"requires\"\n:\n \n\"[0.13.0, 1.0.0)\"\n\n\n}\n\n\n\n\n\nWhen deciding on which version to use, the highest available version\nsatisfying the range constraints will be used.\n\n\nArchives\n\u00b6\n\n\nRugs in one project can call Rugs in other archives as long as the\ncalling Rug\u2019s project declares a dependency on the archive of the Rug\nbeing called.  Dependencies on other Rug archives are declared by\nlisting the fully-qualified name of the Rug archives containing the\nRugs being called as an entry in the object value of the\n\n.atomist.dependencies\n key.  The fully-qualified name of a Rug\narchive is archive group and artifact name joined by a colon (\n:\n).\nThe value of the dependency should be either an exact version or a\nversion range using a Maven \nversion range\n.  Here is\nan example of a dependency on a specific Rug archive version.\n\n\n\"atomist\"\n:\n \n{\n\n  \n\"dependencies\"\n:\n \n{\n\n    \n\"atomist-rugs:rug-editors\"\n:\n \n\"0.14.0\"\n\n  \n}\n\n\n}\n\n\n\n\n\nExtensions\n\u00b6\n\n\nRugs in a project can use Rug extensions not in the Rug core if they\ndeclare a dependency on the extension.  A dependency on a Rug\nextension is declared by listing the fully-qualified name of the Rug\nextension as an entry in the object value of the \n.atomist.extensions\n\nkey.  The fully-qualified name of the extension is comprised of the\ngroup ID and artifact ID joined by a colon (\n:\n).  The value of the\nextension should be either an exact version or a version range using a\nMaven \nversion range\n.  Here is an example of a\nversion-range extension dependency.\n\n\n\"atomist\"\n:\n \n{\n\n  \n\"extensions\"\n:\n \n{\n\n    \n\"com.atomist:travis-rug-extension\"\n:\n \n\"[0.17.0,0.18.0)\"\n\n  \n}\n\n\n}\n\n\n\n\n\nTypeScript types\n\u00b6\n\n\nWhile developing Rugs, and to fully benefit from the static typing\nsupport of the TypeScript language, your project should declare a\ndependency on an appropriate version of the Rug TypeScript typings in\n\n.atomist/package.json\n.  You only need to specify the \ndependencies\n\nsection to the minimum released version of the Rug language your\nproject targets.  The version value can be any \nversion expression\naccepted by NPM\n.\n\n\n\"dependencies\"\n:\n \n{\n\n  \n\"@atomist/rugs\"\n:\n \n\"^1.0.0-m.4\"\n\n\n}\n\n\n\n\n\nBasic Rug Project\n\u00b6\n\n\nA very basic Rug project can be generated using\nthe \nRug project generator\n.  Instructions running the\ngenerator using the Rug CLI can be found in the project\u2019s README.",
            "title": "Projects"
        },
        {
            "location": "/user-guide/rug/projects/#the-atomist-directory",
            "text": "A typical Rug project will have a  .atomist  directory that looks\nsomething like the following.  .atomist  \u251c\u2500\u2500 build/  \u251c\u2500\u2500 editors/  \u251c\u2500\u2500 generators/  \u251c\u2500\u2500 handlers/  \u251c\u2500\u2500 mocha/  \u251c\u2500\u2500 node_modules/  \u251c\u2500\u2500 package.json  \u251c\u2500\u2500 reviewers/  \u251c\u2500\u2500 target/  \u251c\u2500\u2500 templates/  \u251c\u2500\u2500 tests/  \u2514\u2500\u2500 tsconfig.json   The only required file in the  .atomist  directory is the package.json .  The table below explains each entry.     Entry  Description      build  contains CI build scripts and configuration    editors  contains Rug editors    generators  contains Rug generators    handlers  contains Rug command and event handlers    mocha  contains  Mocha  unit tests    node_modules  contains source code for TypeScript typings and dependencies installed by  NPM    package.json  Rug project metadata within a standard NPM  package.json  file declaring the TypeScript dependencies,  required    reviewers  contains Rug reviewers    target  contains files generated by the Rug CLI during building and packaging    templates  contains templates used by Rugs    tests  contains Rug tests    tsconfig.json  TypeScript compiler options useful for IDE TypeScript tooling      The  tsconfig.json  is  not  used by the Rug CLI when compiling TypeScript.",
            "title": "The .atomist directory"
        },
        {
            "location": "/user-guide/rug/projects/#metadata",
            "text": "The  .atomist/package.json  file contains the Rug archive project\nmetadata.  The  package.json  file is a\nstandard  NPM package.json file .  Typical contents for\nthe  package.json  will look like:  { \n   \"name\" :   \"@my-org/my-rug-project\" , \n   \"description\" :   \"Atomist Rugs used in the end-user documentation\" , \n   \"version\" :   \"0.1.0\" , \n   \"author\" :   \"My Company\" , \n   \"repository\" :   { \n     \"type\" :   \"git\" , \n     \"url\" :   \"https://github.com/atomist/my-rug-project.git\" \n   }, \n   \"keywords\" :   [ \n     \"atomist\" , \n     \"rug\" \n   ], \n   \"homepage\" :   \"https://github.com/atomist/my-rug-project#readme\" , \n   \"bugs\" :   { \n     \"url\" :   \"https://github.com/atomist/my-rug-project/issues\" \n   }, \n   \"dependencies\" :   { \n     \"@atomist/rugs\" :   \"^1.0.0-m.5\" \n   }, \n   \"devDependencies\" :   { \n     \"@types/mocha\" :   \"^2.2.40\" , \n     \"@types/power-assert\" :   \"^1.4.29\" , \n     \"espower-typescript\" :   \"^8.0.0\" , \n     \"mocha\" :   \"^3.2.0\" , \n     \"power-assert\" :   \"^1.4.2\" , \n     \"tslint\" :   \"^5.0.0\" , \n     \"typescript\" :   \"2.3.2\" \n   }, \n   \"directories\" :   { \n     \"test\" :   \"mocha\" \n   }, \n   \"scripts\" :   { \n     \"autotest\" :   \"supervisor -q -n exit -e ts -x npm -- run mocha\" , \n     \"lint\" :   \"tslint '**/*.ts' --exclude 'node_modules/**' -t verbose\" , \n     \"mocha\" :   \"mocha --compilers ts:espower-typescript/guess 'mocha/**/*.ts'\" , \n     \"test\" :   \"npm run mocha && rug test\" \n   }, \n   \"atomist\" :   { \n     \"requires\" :   \"[1.0.0-m.4,2.0.0)\" \n   }  }   You can see this is a standard NPM package.json file with the addition\nof the  \"atomist\"  section.  In this example, the only\nparameter in the  \"atomist\"  section is  \"requires\" ,\nwhich specifies the unique coordinates of the Rug archive: its group,\nname and version. Dependencies and extensions may also be declared:     Key  Description      \"requires\"  The Rug runtime version this project is being developed with. Version range is allowed    \"dependencies\"  List of project dependencies in form group:artifact:version. Version ranges are allowed    \"extensions\"  List of binary dependencies, e.g., Rug Extension types. Version ranges are allowed",
            "title": "Metadata"
        },
        {
            "location": "/user-guide/rug/projects/#dependencies",
            "text": "A Rug project can have four different types of dependencies:   Rug runtime dependency  Other Rug archives  Rug extensions  TypeScript types",
            "title": "Dependencies"
        },
        {
            "location": "/user-guide/rug/projects/#runtime",
            "text": "The Rug runtime dependency is specified using the  .atomist.requires \nkey in the  package.json .  The value of the  requires  key is a\nstring that specifies either an exact Rug runtime version or a version\nrange using the Maven  version range .  The following\nwould cause the Rugs in the project to only executed by Rug runtime\nversion 0.13.0.  \"atomist\" :   { \n   \"requires\" :   \"0.13.0\"  }   In contrast, the following specification could run under any version\nof the Rug runtime from 0.13.0, inclusive, up to, but not including,\nversion 1.0.0.  \"atomist\" :   { \n   \"requires\" :   \"[0.13.0, 1.0.0)\"  }   When deciding on which version to use, the highest available version\nsatisfying the range constraints will be used.",
            "title": "Runtime"
        },
        {
            "location": "/user-guide/rug/projects/#archives",
            "text": "Rugs in one project can call Rugs in other archives as long as the\ncalling Rug\u2019s project declares a dependency on the archive of the Rug\nbeing called.  Dependencies on other Rug archives are declared by\nlisting the fully-qualified name of the Rug archives containing the\nRugs being called as an entry in the object value of the .atomist.dependencies  key.  The fully-qualified name of a Rug\narchive is archive group and artifact name joined by a colon ( : ).\nThe value of the dependency should be either an exact version or a\nversion range using a Maven  version range .  Here is\nan example of a dependency on a specific Rug archive version.  \"atomist\" :   { \n   \"dependencies\" :   { \n     \"atomist-rugs:rug-editors\" :   \"0.14.0\" \n   }  }",
            "title": "Archives"
        },
        {
            "location": "/user-guide/rug/projects/#extensions",
            "text": "Rugs in a project can use Rug extensions not in the Rug core if they\ndeclare a dependency on the extension.  A dependency on a Rug\nextension is declared by listing the fully-qualified name of the Rug\nextension as an entry in the object value of the  .atomist.extensions \nkey.  The fully-qualified name of the extension is comprised of the\ngroup ID and artifact ID joined by a colon ( : ).  The value of the\nextension should be either an exact version or a version range using a\nMaven  version range .  Here is an example of a\nversion-range extension dependency.  \"atomist\" :   { \n   \"extensions\" :   { \n     \"com.atomist:travis-rug-extension\" :   \"[0.17.0,0.18.0)\" \n   }  }",
            "title": "Extensions"
        },
        {
            "location": "/user-guide/rug/projects/#typescript-types",
            "text": "While developing Rugs, and to fully benefit from the static typing\nsupport of the TypeScript language, your project should declare a\ndependency on an appropriate version of the Rug TypeScript typings in .atomist/package.json .  You only need to specify the  dependencies \nsection to the minimum released version of the Rug language your\nproject targets.  The version value can be any  version expression\naccepted by NPM .  \"dependencies\" :   { \n   \"@atomist/rugs\" :   \"^1.0.0-m.4\"  }",
            "title": "TypeScript types"
        },
        {
            "location": "/user-guide/rug/projects/#basic-rug-project",
            "text": "A very basic Rug project can be generated using\nthe  Rug project generator .  Instructions running the\ngenerator using the Rug CLI can be found in the project\u2019s README.",
            "title": "Basic Rug Project"
        },
        {
            "location": "/user-guide/rug/archives/",
            "text": "A Rug archive is a packaged version of a project that contains Rugs.\nRug archives are created using the \nrug install\n CLI command.  A Rug\narchive contains all of the source code from the original project, the\nnecessary parts of the project\u2019s \n.atomist\n directory, and archive\nmetadata, based on the contents of the project\u2019s\n\n.atomist/package.json\n file.  See \nRug project\n for more\ndetails on the contents of the \n.atomist\n directory and \npackage.json\n\nfile.",
            "title": "Archives"
        },
        {
            "location": "/user-guide/rug/lifecycle/",
            "text": "A Day in the Life of a Rug Project\n\u00b6\n\n\nThis page describes the nature, structure and lifecycle of a Rug\nproject.\n\n\nIf you haven\u2019t done so and you want to follow along, please \ninstall\nthe Rug CLI\n.\n\n\nInception\n\u00b6\n\n\nThe easiest way to create a new Rug project is by using the\n\nNewStarterRugProject\n generator via the Bot or CLI. Here, we\u2019ll show\nhow to do it with the CLI.\n\n\n$\n rug generate atomist:rug-rugs:NewStarterRugProject my-rug-project\n\nCreated default configuration file at /Users/dd/.atomist/cli.yml\n\n\nResolving dependencies for atomist:rug-rugs (latest\u00b7zip) completed\n\n\nReading archive structure of atomist:rug-rugs (0.31.0\u00b7zip) completed\n\n\nLoading rugs of atomist:rug-rugs (0.31.0\u00b7zip) completed\n\n\nRunning generator NewStarterRugProject of atomist:rug-rugs (0.31.0\u00b7zip) completed\n\n\n\n\u2192 Project\n\n\n  ~/develop/my-rug-project/ (28 kb in 22 files)\n\n\n\n\u2192 Changes\n\n\n  \u251c\u2500\u252c .atomist\n\n\n  | \u251c\u2500\u2500 .gitignore\n\n\n  | \u251c\u2500\u252c build\n\n\n  | | \u251c\u2500\u2500 cli.yml\n\n\n  | | \u2514\u2500\u2500 travis-build.bash\n\n\n  | \u251c\u2500\u252c editors\n\n\n  | | \u2514\u2500\u2500 MyFirstEditor.ts\n\n\n  | \u251c\u2500\u252c handlers/command\n\n\n  | | \u2514\u2500\u2500 MyFirstCommandHandler.ts\n\n\n  | \u251c\u2500\u252c handlers/event\n\n\n  | | \u2514\u2500\u2500 MyFirstEventHandler.ts\n\n\n  | \u251c\u2500\u252c mocha\n\n\n  | | \u2514\u2500\u2500 SimpleTest.ts\n\n\n  | \u251c\u2500\u2500 package.json\n\n\n  | \u251c\u2500\u252c tests/handlers/command\n\n\n  | | \u251c\u2500\u2500 MyFirstCommandHandlerSteps.ts\n\n\n  | | \u2514\u2500\u2500 MyFirstCommandHandlerTest.feature\n\n\n  | \u251c\u2500\u252c tests/handlers/event\n\n\n  | | \u251c\u2500\u2500 MyFirstEventHandlerSteps.ts\n\n\n  | | \u2514\u2500\u2500 MyFirstEventHandlerTest.feature\n\n\n  | \u251c\u2500\u252c tests/project\n\n\n  | | \u251c\u2500\u2500 MyFirstEditorSteps.ts\n\n\n  | | \u2514\u2500\u2500 MyFirstEditorTest.feature\n\n\n  | \u251c\u2500\u2500 tsconfig.json\n\n\n  | \u2514\u2500\u2500 tslint.json\n\n\n  \u251c\u2500\u2500 .atomist.yml\n\n\n  \u251c\u2500\u2500 .gitattributes\n\n\n  \u251c\u2500\u2500 CHANGELOG.md\n\n\n  \u251c\u2500\u2500 LICENSE\n\n\n  \u2514\u2500\u2500 README.md\n\n\n\nSuccessfully generated new project my-rug-project\n\n\n\n\n\nThat command created a new directory named \nmy-rug-project\n in the\ncurrent directory, \n~/develop\n in this case.  You can see from the\noutput above that the generator created a project with a \n.atomist\n\ndirectory containing a sample editor, command handler, event handler,\nand tests.\n\n\nSet up\n\u00b6\n\n\nBefore doing anything else, you need to install the project\u2019s\ndependencies.  You do this using \nNPM\n.\n\n\n$\n \ncd\n my-rug-project/.atomist\n\n$\n npm install\n\n\n\n\nThe \nnpm install\n command will download all the needed dependencies\nunder a \nnode_modules\n directory and create a \npackage-lock.json\n file\nrecording what it has done.\n\n\nRunning Tests\n\u00b6\n\n\nAfter making changes to your Rug code, you should run the tests.  The\ngenerated Rug project already has some tests.  Run the following\ncommand in the \n.atomist\n directory of the project.\n\n\nFIXME\n\n\n$\n npm \ntest\n\n\n\n>\n @atomist-contrib/my-rug-project@0.1.0 \ntest\n /Users/dd/develop/my-rug-project/.atomist\n\n>\n npm run mocha \n&&\n rug \ntest\n\n\n\n\n>\n @atomist-contrib/my-rug-project@0.1.0 mocha /Users/dd/develop/my-rug-project/.atomist\n\n>\n mocha --compilers ts:espower-typescript/guess \n'mocha/**/*.ts'\n\n\n\n\n\n  default test\n\n\n    \u2713 should be true\n\n\n\n\n  1 passing (9ms)\n\n\n\nResolving dependencies for atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nCompiling source files of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nLoading rugs of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nRunning test feature MyFirstCommandHandler handlers responds to commands\n\n\n  Running test scenario Executing a sample command handler\n\n\n  Completed test scenario Executing a sample command handler passed\n\n\nCompleted test feature MyFirstCommandHandler handlers responds to commands passed\n\n\nRunning test feature MyFirstEventHandler handler handles events\n\n\n  Running test scenario Executing a sample event handler\n\n\n  Completed test scenario Executing a sample event handler passed\n\n\nCompleted test feature MyFirstEventHandler handler handles events passed\n\n\nRunning test feature Make sure the sample TypeScript Editor has some tests\n\n\n  Running test scenario MyFirstEditor should edit a project correctly\n\n\n  Completed test scenario MyFirstEditor should edit a project correctly passed\n\n\nCompleted test feature Make sure the sample TypeScript Editor has some tests passed\n\n\nRunning tests in atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\n\nSuccessfully executed 3 of 3 tests: Test SUCCESS\n\n\n\n\n\nInstalling\n\u00b6\n\n\nTo package the Rug project up and make it available to the Rug CLI to\nrun from any directory, you must install it:\n\n\n$\n rug install\n\nResolving dependencies for atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nCompiling source files of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nLoading rugs of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nGenerating archive metadata completed\n\n\nInstalling archive into local repository completed\n\n\n\n\u2192 Archive\n\n\n  ~/develop/my-rug-project/.atomist/target/my-rug-project-0.1.0.zip (8 mb in 4240 files)\n\n\n\nSuccessfully installed archive for atomist-contrib:my-rug-project (0.1.0)\n\n\n\n\n\nThe \ninstall\n command takes the project, packages it up for\ndistribution, and installs it under \n~/.atomist/repository\n.\n\n\nThe contents of the archive can be further tuned by adding entries to\n\n.atomist/ignore\n, the packaging step considers the contents of these\nfiles when creating the archive.  Note that paths appearing in the\n\n.atomist/ignore\n file are rooted at the project root, not under the\n\n.atomist\n directory.\n\n\nPublishing\n\u00b6\n\n\nPublishing is the process of uploading an archive to a Maven\nrepository so it can be used by others.  Before publishing a Rug\narchive, you first need to configure a publishing repository in your\n\n~/.atomst/cli.yml\n.  This is typically done by using the Rug CLI\n\nlogin\n and \nconfigure repositories\n commands.\n\n\n$\n rug login\n\n$\n rug configure repositories\n\n\n\n\nOnce you have your publishing repository configured, you simply run\n\nrug publish --id=TEAMID\n, replacing \nTEAMID\n with your Slack team\nidentifier or its common name, both of which can be found in the Rug\nCLI configuration file, usually found at \n~/.atomist/cli.yml\n.  Here\u2019s\nan example \ncli.yml\n file.\n\n\nlocal_repository\n:\n\n  \npath\n:\n \n\"${user.home}/.atomist/repository\"\n\n\nremote_repositories\n:\n\n  \ncentral\n:\n\n    \npublish\n:\n \nfalse\n\n    \nurl\n:\n \n\"http://repo.maven.apache.org/maven2/\"\n\n  \nrugs\n:\n\n    \npublish\n:\n \nfalse\n\n    \nurl\n:\n \n\"https://atomist.jfrog.io/atomist/rugs\"\n\n  \nt0123abcd\n:\n\n    \nauthentication\n:\n\n      \npassword\n:\n \n\"TOKEN\"\n\n      \nusername\n:\n \n\"t0123abcd\"\n\n    \npublish\n:\n \ntrue\n\n    \nurl\n:\n \n\"https://atomist.jfrog.io/atomist/T0123ABCD\"\n\n    \nname\n:\n \n\"slackers\"\n\n\n\n\n\nUnder the \nremote_repositories\n element you can see two\nstandard read-only repositories, i.e., \npublish\n:\n \nfalse\n, and\nthen the team specific repository which has a Slack identifier \nt0123abcd\n and a common name of \nslackers\n.\n\n\nTo publish your Rug archive to your team repository, run the following\ncommand.\n\n\n$\n rug publish --id\n=\nslackers\n\nResolving dependencies for atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nCompiling source files of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nLoading rugs of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed\n\n\nGenerating archive metadata completed\n\n\nPublishing archive into remote repository\n\n\n  Uploading atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0.zip \u2192 team (9 mb) succeeded\n\n\n  Uploading atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0.pom \u2192 team (806 bytes) succeeded\n\n\n  Uploading atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0-metadata.json \u2192 team (20 kb) succeeded\n\n\n  Downloading atomist-contrib/my-rug-project/maven-metadata.xml \u2190 team (1 kb) succeeded\n\n\n  Uploading atomist-contrib/my-rug-project/maven-metadata.xml \u2192 team (1 kb) succeeded\n\n\nPublishing archive into remote repository completed\n\n\n\u2192 Archive\n\n\n  ~/build/atomist-contrib/my-rug-project/.atomist/target/my-rug-project-0.1.0.zip (9 mb in 4484 files)\n\n\n\u2192 URL\n\n\n  https://atomist.jfrog.io/atomist/T0123ABCD/atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0.zip\n\n\nSuccessfully published archive for atomist-contrib:my-rug-project (0.1.0)",
            "title": "Lifecycle"
        },
        {
            "location": "/user-guide/rug/lifecycle/#a-day-in-the-life-of-a-rug-project",
            "text": "This page describes the nature, structure and lifecycle of a Rug\nproject.  If you haven\u2019t done so and you want to follow along, please  install\nthe Rug CLI .",
            "title": "A Day in the Life of a Rug Project"
        },
        {
            "location": "/user-guide/rug/lifecycle/#inception",
            "text": "The easiest way to create a new Rug project is by using the NewStarterRugProject  generator via the Bot or CLI. Here, we\u2019ll show\nhow to do it with the CLI.  $  rug generate atomist:rug-rugs:NewStarterRugProject my-rug-project Created default configuration file at /Users/dd/.atomist/cli.yml  Resolving dependencies for atomist:rug-rugs (latest\u00b7zip) completed  Reading archive structure of atomist:rug-rugs (0.31.0\u00b7zip) completed  Loading rugs of atomist:rug-rugs (0.31.0\u00b7zip) completed  Running generator NewStarterRugProject of atomist:rug-rugs (0.31.0\u00b7zip) completed  \u2192 Project    ~/develop/my-rug-project/ (28 kb in 22 files)  \u2192 Changes    \u251c\u2500\u252c .atomist    | \u251c\u2500\u2500 .gitignore    | \u251c\u2500\u252c build    | | \u251c\u2500\u2500 cli.yml    | | \u2514\u2500\u2500 travis-build.bash    | \u251c\u2500\u252c editors    | | \u2514\u2500\u2500 MyFirstEditor.ts    | \u251c\u2500\u252c handlers/command    | | \u2514\u2500\u2500 MyFirstCommandHandler.ts    | \u251c\u2500\u252c handlers/event    | | \u2514\u2500\u2500 MyFirstEventHandler.ts    | \u251c\u2500\u252c mocha    | | \u2514\u2500\u2500 SimpleTest.ts    | \u251c\u2500\u2500 package.json    | \u251c\u2500\u252c tests/handlers/command    | | \u251c\u2500\u2500 MyFirstCommandHandlerSteps.ts    | | \u2514\u2500\u2500 MyFirstCommandHandlerTest.feature    | \u251c\u2500\u252c tests/handlers/event    | | \u251c\u2500\u2500 MyFirstEventHandlerSteps.ts    | | \u2514\u2500\u2500 MyFirstEventHandlerTest.feature    | \u251c\u2500\u252c tests/project    | | \u251c\u2500\u2500 MyFirstEditorSteps.ts    | | \u2514\u2500\u2500 MyFirstEditorTest.feature    | \u251c\u2500\u2500 tsconfig.json    | \u2514\u2500\u2500 tslint.json    \u251c\u2500\u2500 .atomist.yml    \u251c\u2500\u2500 .gitattributes    \u251c\u2500\u2500 CHANGELOG.md    \u251c\u2500\u2500 LICENSE    \u2514\u2500\u2500 README.md  Successfully generated new project my-rug-project   That command created a new directory named  my-rug-project  in the\ncurrent directory,  ~/develop  in this case.  You can see from the\noutput above that the generator created a project with a  .atomist \ndirectory containing a sample editor, command handler, event handler,\nand tests.",
            "title": "Inception"
        },
        {
            "location": "/user-guide/rug/lifecycle/#set-up",
            "text": "Before doing anything else, you need to install the project\u2019s\ndependencies.  You do this using  NPM .  $   cd  my-rug-project/.atomist $  npm install  The  npm install  command will download all the needed dependencies\nunder a  node_modules  directory and create a  package-lock.json  file\nrecording what it has done.",
            "title": "Set up"
        },
        {
            "location": "/user-guide/rug/lifecycle/#running-tests",
            "text": "After making changes to your Rug code, you should run the tests.  The\ngenerated Rug project already has some tests.  Run the following\ncommand in the  .atomist  directory of the project.  FIXME  $  npm  test  >  @atomist-contrib/my-rug-project@0.1.0  test  /Users/dd/develop/my-rug-project/.atomist >  npm run mocha  &&  rug  test  >  @atomist-contrib/my-rug-project@0.1.0 mocha /Users/dd/develop/my-rug-project/.atomist >  mocha --compilers ts:espower-typescript/guess  'mocha/**/*.ts'    default test      \u2713 should be true    1 passing (9ms)  Resolving dependencies for atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Compiling source files of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Loading rugs of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Running test feature MyFirstCommandHandler handlers responds to commands    Running test scenario Executing a sample command handler    Completed test scenario Executing a sample command handler passed  Completed test feature MyFirstCommandHandler handlers responds to commands passed  Running test feature MyFirstEventHandler handler handles events    Running test scenario Executing a sample event handler    Completed test scenario Executing a sample event handler passed  Completed test feature MyFirstEventHandler handler handles events passed  Running test feature Make sure the sample TypeScript Editor has some tests    Running test scenario MyFirstEditor should edit a project correctly    Completed test scenario MyFirstEditor should edit a project correctly passed  Completed test feature Make sure the sample TypeScript Editor has some tests passed  Running tests in atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Successfully executed 3 of 3 tests: Test SUCCESS",
            "title": "Running Tests"
        },
        {
            "location": "/user-guide/rug/lifecycle/#installing",
            "text": "To package the Rug project up and make it available to the Rug CLI to\nrun from any directory, you must install it:  $  rug install Resolving dependencies for atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Compiling source files of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Loading rugs of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Generating archive metadata completed  Installing archive into local repository completed  \u2192 Archive    ~/develop/my-rug-project/.atomist/target/my-rug-project-0.1.0.zip (8 mb in 4240 files)  Successfully installed archive for atomist-contrib:my-rug-project (0.1.0)   The  install  command takes the project, packages it up for\ndistribution, and installs it under  ~/.atomist/repository .  The contents of the archive can be further tuned by adding entries to .atomist/ignore , the packaging step considers the contents of these\nfiles when creating the archive.  Note that paths appearing in the .atomist/ignore  file are rooted at the project root, not under the .atomist  directory.",
            "title": "Installing"
        },
        {
            "location": "/user-guide/rug/lifecycle/#publishing",
            "text": "Publishing is the process of uploading an archive to a Maven\nrepository so it can be used by others.  Before publishing a Rug\narchive, you first need to configure a publishing repository in your ~/.atomst/cli.yml .  This is typically done by using the Rug CLI login  and  configure repositories  commands.  $  rug login $  rug configure repositories  Once you have your publishing repository configured, you simply run rug publish --id=TEAMID , replacing  TEAMID  with your Slack team\nidentifier or its common name, both of which can be found in the Rug\nCLI configuration file, usually found at  ~/.atomist/cli.yml .  Here\u2019s\nan example  cli.yml  file.  local_repository : \n   path :   \"${user.home}/.atomist/repository\"  remote_repositories : \n   central : \n     publish :   false \n     url :   \"http://repo.maven.apache.org/maven2/\" \n   rugs : \n     publish :   false \n     url :   \"https://atomist.jfrog.io/atomist/rugs\" \n   t0123abcd : \n     authentication : \n       password :   \"TOKEN\" \n       username :   \"t0123abcd\" \n     publish :   true \n     url :   \"https://atomist.jfrog.io/atomist/T0123ABCD\" \n     name :   \"slackers\"   Under the  remote_repositories  element you can see two\nstandard read-only repositories, i.e.,  publish :   false , and\nthen the team specific repository which has a Slack identifier  t0123abcd  and a common name of  slackers .  To publish your Rug archive to your team repository, run the following\ncommand.  $  rug publish --id = slackers Resolving dependencies for atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Compiling source files of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Loading rugs of atomist-contrib:my-rug-project (0.1.0\u00b7local) completed  Generating archive metadata completed  Publishing archive into remote repository    Uploading atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0.zip \u2192 team (9 mb) succeeded    Uploading atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0.pom \u2192 team (806 bytes) succeeded    Uploading atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0-metadata.json \u2192 team (20 kb) succeeded    Downloading atomist-contrib/my-rug-project/maven-metadata.xml \u2190 team (1 kb) succeeded    Uploading atomist-contrib/my-rug-project/maven-metadata.xml \u2192 team (1 kb) succeeded  Publishing archive into remote repository completed  \u2192 Archive    ~/build/atomist-contrib/my-rug-project/.atomist/target/my-rug-project-0.1.0.zip (9 mb in 4484 files)  \u2192 URL    https://atomist.jfrog.io/atomist/T0123ABCD/atomist-contrib/my-rug-project/0.1.0/my-rug-project-0.1.0.zip  Successfully published archive for atomist-contrib:my-rug-project (0.1.0)",
            "title": "Publishing"
        },
        {
            "location": "/user-guide/rug/runtime/",
            "text": "While the primary development language for Rugs is \nTypeScript\n,\nany language that can be compiled into JavaScript can be used to\ndevelop Rugs.  Rug code is transpiled into JavaScript and executed in\nthe \nJVM\n using \nNashorn\n.\n\n\nSince Rugs are executed in Nashorn, there are some things to keep in\nmind.\n\n\n\n\nSingle-threaded runtime\n\n\nDo not use callbacks\n\n\nDo not operate on the file system, use the \nProject\n object passed\n    in\n\n\nSome \nNode\n modules may not behave as you expect",
            "title": "Runtime"
        },
        {
            "location": "/user-guide/rug/conventions/",
            "text": "This document highlights the conventions of writing, testing and\npublishing Rugs.  These are best-practices for a smoother experience\nof writing, running, and using Rugs. The Rug toolchain will not, in\nmost cases, enforce any of those conventions.\n\n\nRug project guidelines\n\u00b6\n\n\nRug projects, i.e., projects containing Rugs in a \n.atomist\n\ndirectory, should conform to the standard layout described on\n\nRug project\n.\n\n\nREADME\n\u00b6\n\n\nRug projects ought to have a good \nREADME.md\n file, written using\nthe \nMarkdown\n format, containing the following information:\n\n\n\n\nA general description of the intent of the Rugs in the project,\n    i.e., what ties them all together, at the top of the README.\n\n\nA section named \nRugs\n that has a subsection for each Rug that\n    contains:\n\n\nAn explanation of what the Rug does, e.g., how will the\n    source code be changed after running the editor.\n\n\nA subsection named \nPrerequisites\n describing what must be in\n    place before running the Rug.\n\n\nA subsection named \nParameters\n describing the Rug\u2019s input\n    parameters, including examples of valid input values.\n\n\nA subsection named \nRunning\n describing how to run the Rug and\n    providing examples of how to run the Rug.\n\n\n\n\n\n\nA \nSupport\n section providing information on how to get help\n    with the Rugs in the project.\n\n\nA \nDevelopment\n section providing information on how one would\n    modify and test the Rugs.\n\n\n\n\nPublic Rug repositories should be automatically built, tested and\ndeployed using a continuous integration service,\nlike \nTravis CI\n.  The CI build status badge and the Slack\nbadge for the Atomist Community should be placed in the \nREADME.md\n\nbetween the page title and the general description.  Here is the\nmarkdown text to add the Slack badge:\n\n\n[\n![Slack Status\n](\nhttps://join.atomist.com/badge.svg\n)](https://join.atomist.com)\n\n\n\n\nChange log\n\u00b6\n\n\nRug repositories should have a change log in\nthe \nCHANGELOG.md\n format\n.\n\n\nProject naming\n\u00b6\n\n\nA Rug project name should be hyphenated and start with the technology\nstack being targeted, such as \nspring-boot\n, followed by what sort of\nRugs the project contains, e.g., \n-editors\n if this is a Rug project\nwith a collection of useful editors or reviewers.\n\n\nIf the main purpose of a Rug project is to be a generator, then ending\nthe name with the type of project it will generate would be most\nappropriate.  For example if your Rug projects\u2019s main purpose was to be\na generator for a Spring Boot Rest Service then\n\nspring-boot-rest-service\n or even \njava-spring-boot-rest-service\n\nwould be appropriate. If your Rug projects\u2019s main purpose was simply to\ngenerate a valid Maven project then \nmaven-project\n would be appropriate.\n\n\nMetadata\n\u00b6\n\n\nThe Rug archive project metadata stored in the \n.atomist/package.json\n\nfile should conform to the following guidelines.\n\n\n\n\nname\n: The name should be \nscoped\n under the owner of the\n    project\u2019s repository and the unqualified name should be the same\n    as the repository name.  For example, for the GitHub repository\n    \nsomeone/something\n, the name should be \n@someone/something\n.\n\n\nversion\n: The version should be a valid \nSemantic version\n.\n\n\n\n\n\n\n\nRugs\n\u00b6\n\n\nRugs are defined by the source code under the various subdirectories\nof the \n.atomist\n directory.\n\n\nNaming\n\u00b6\n\n\nRugs should have their names formatted using \nUpperCamelCase\n.\nFollowing the rule of making implicit concepts explicit, the name of\nyour Rug should correspond to a complete and specific description of\nthe purpose of the Rug.  For example, \nAddDocker\n is a good name if\nthe Rug adds Docker to anything, but \nAddDockerToMavenProjects\n is\nbetter if the intention of the Rug is to only work with projects that\nfollow Maven conventions.\n\n\nRugs within the same file are conventionally understood to be\nin support of the main and initial Rug in the file.\n\n\nThe name is set as the first argument of\nthe \nTypeScript decorator\n defining the Rug operation.\nFor instance, for an editor:\n\n\n@Editor\n(\n\"AddDockerToMavenProjects\"\n,\n \n\"adds the docker files to a Maven project\"\n)\n\n\n\n\n\nDescribing\n\u00b6\n\n\nA good Rug description states exactly what the purpose of the Rug is\n\nwithout capitalisation on the sentence\n and \nwithout a closing\nperiod\n.  The reason for avoiding sentence punctuation is that the\ndescription is often used by the Atomist Bot and the grammar of its\nusage is context-driven.  Ideally the description should be a sentence\nfragment and as short as possible while still being uniquely\ndescriptive.\n\n\nThe description is set as the second argument of the \ndecorator\n\ndefining the Rug operation. For instance, for an editor:\n\n\n@Editor\n(\n\"AddDockerToMavenProjects\"\n,\n \n\"adds the docker files to a Maven project\"\n)\n\n\n\n\n\nDiscoverability\n\u00b6\n\n\nAll Rugs should be annotated with one or more \n@Tags\n \n\ndecorators\n to optimize their discoverability. For \nexample if you were to create an Rug that alters a README file\nthen the following \n@Tags\n would be applicable:\n\n\n@Tags\n(\n\"readme\"\n,\n \n\"documentation\"\n)\n\n\n\n\n\nTag values should consist of only lower case letters, numbers, and\ndashes (\n-\n).\n\n\nIf possible, try to include at least one of the tags on your Rug maps to an image\nfor a nicer rendering.  The following tags currently have images:\n\ndocker\n,\ngithub\n, \ntravis-ci\n, \napache\n, \ngit\n, \nspring-boot\n,\n\nspring\n, \nclojure\n, \ngo\n, \njava\n, \npython\n, \nscala\n, and\n\ndocumentation\n.\n\n\nCode style\n\u00b6\n\n\nWe suggest you rely on a \nTypeScript linter\n and\n\nTypeScript format checker\n to catch common pitfalls in your code and\nkeep it readable and well-formatted.\n\n\nParameters\n\u00b6\n\n\nRug parameters should follow \nTypeScript naming guidelines\n,\ni.e., \nlowerCamelCase\n, and describe, as explicitly as\npossible, what the parameter represents.\n\n\nParameters are defined as instance variables of the class implementing\nyour Rug.  They are decorated with the \n@Parameter\n\ndecorator to declare their metadata.  The \n@Parameter\n\ndecorator takes a single argument, a JavaScript object with the\nfollowing properties:\n\n\n{\n\n  \ndisplayName?\n: \nstring\n\n  \ndescription?\n: \nstring\n\n  \npattern\n: \nstring\n\n  \nvalidInput?\n: \nstring\n\n  \nminLength?\n: \nnumber\n \n=\n \n-\n1\n\n  \nmaxLength?\n: \nnumber\n \n=\n \n-\n1\n\n  \nrequired?\n: \nboolean\n \n=\n \nfalse\n\n\n}\n\n\n\n\n\nOnly the \npattern\n property is required, but providing\ngood values for all properties is highly recommended.  If a property\nhas a default value, it is shown above to the right of the equal (\n=\n)\nsign.\n\n\nDescription and display names\n\u00b6\n\n\nAs Rug parameters are part of the public contract of Rugs it is\nrecommended that a human-readable description and display name always\nbe applied using the \ndescription\n and \ndisplayName\n properties.  A good description and display name allows\nthe Atomist user interfaces to provide the user with the information\nneeded to provide proper values.  The \ndisplayName\n field\nvalue should be three words or less and use Title Case.\n\n\nValidation\n\u00b6\n\n\nIt is recommended that all parameters should be restricted using the\nmost explicit and constraining regular expression that is appropriate\nfor the corresponding parameter via the \npattern\n\nproperty.  In addition, you should provide a meaningful value for the\n\nvalidInput\n field so, when people provide an invalid\nvalue, they are provided with a useful error message.\n\n\nThe value of the \npattern\n property must be\nan \nanchored regular expression\n, i.e., it must begin\nwith \n^\n and end with \n$\n.\n\n\n\n\nAtomist bundles a set of default anchored regular expression in the\n\nPattern\n object which can be imported as follows:\n\n\nimport\n \n{\n \nPattern\n \n}\n \nfrom\n \n\"@atomist/rug/operations/RugOperation\"\n;\n\n\n\n\n\n\n\nMandatory and optional\n\u00b6\n\n\nIf a parameter is not required, i.e., the Rug can execute sensibly\nwithout the user specifying it, set the \nrequired\n\nproperty to \nfalse\n.  In that case, it is recommended to\nsupply a valid default value to the parameter variable so that there\nis some predictability of how the Rug will function if no parameter is\nsupplied.",
            "title": "Conventions"
        },
        {
            "location": "/user-guide/rug/conventions/#rug-project-guidelines",
            "text": "Rug projects, i.e., projects containing Rugs in a  .atomist \ndirectory, should conform to the standard layout described on Rug project .",
            "title": "Rug project guidelines"
        },
        {
            "location": "/user-guide/rug/conventions/#readme",
            "text": "Rug projects ought to have a good  README.md  file, written using\nthe  Markdown  format, containing the following information:   A general description of the intent of the Rugs in the project,\n    i.e., what ties them all together, at the top of the README.  A section named  Rugs  that has a subsection for each Rug that\n    contains:  An explanation of what the Rug does, e.g., how will the\n    source code be changed after running the editor.  A subsection named  Prerequisites  describing what must be in\n    place before running the Rug.  A subsection named  Parameters  describing the Rug\u2019s input\n    parameters, including examples of valid input values.  A subsection named  Running  describing how to run the Rug and\n    providing examples of how to run the Rug.    A  Support  section providing information on how to get help\n    with the Rugs in the project.  A  Development  section providing information on how one would\n    modify and test the Rugs.   Public Rug repositories should be automatically built, tested and\ndeployed using a continuous integration service,\nlike  Travis CI .  The CI build status badge and the Slack\nbadge for the Atomist Community should be placed in the  README.md \nbetween the page title and the general description.  Here is the\nmarkdown text to add the Slack badge:  [ ![Slack Status ]( https://join.atomist.com/badge.svg )](https://join.atomist.com)",
            "title": "README"
        },
        {
            "location": "/user-guide/rug/conventions/#change-log",
            "text": "Rug repositories should have a change log in\nthe  CHANGELOG.md  format .",
            "title": "Change log"
        },
        {
            "location": "/user-guide/rug/conventions/#project-naming",
            "text": "A Rug project name should be hyphenated and start with the technology\nstack being targeted, such as  spring-boot , followed by what sort of\nRugs the project contains, e.g.,  -editors  if this is a Rug project\nwith a collection of useful editors or reviewers.  If the main purpose of a Rug project is to be a generator, then ending\nthe name with the type of project it will generate would be most\nappropriate.  For example if your Rug projects\u2019s main purpose was to be\na generator for a Spring Boot Rest Service then spring-boot-rest-service  or even  java-spring-boot-rest-service \nwould be appropriate. If your Rug projects\u2019s main purpose was simply to\ngenerate a valid Maven project then  maven-project  would be appropriate.",
            "title": "Project naming"
        },
        {
            "location": "/user-guide/rug/conventions/#metadata",
            "text": "The Rug archive project metadata stored in the  .atomist/package.json \nfile should conform to the following guidelines.   name : The name should be  scoped  under the owner of the\n    project\u2019s repository and the unqualified name should be the same\n    as the repository name.  For example, for the GitHub repository\n     someone/something , the name should be  @someone/something .  version : The version should be a valid  Semantic version .",
            "title": "Metadata"
        },
        {
            "location": "/user-guide/rug/conventions/#rugs",
            "text": "Rugs are defined by the source code under the various subdirectories\nof the  .atomist  directory.",
            "title": "Rugs"
        },
        {
            "location": "/user-guide/rug/conventions/#naming",
            "text": "Rugs should have their names formatted using  UpperCamelCase .\nFollowing the rule of making implicit concepts explicit, the name of\nyour Rug should correspond to a complete and specific description of\nthe purpose of the Rug.  For example,  AddDocker  is a good name if\nthe Rug adds Docker to anything, but  AddDockerToMavenProjects  is\nbetter if the intention of the Rug is to only work with projects that\nfollow Maven conventions.  Rugs within the same file are conventionally understood to be\nin support of the main and initial Rug in the file.  The name is set as the first argument of\nthe  TypeScript decorator  defining the Rug operation.\nFor instance, for an editor:  @Editor ( \"AddDockerToMavenProjects\" ,   \"adds the docker files to a Maven project\" )",
            "title": "Naming"
        },
        {
            "location": "/user-guide/rug/conventions/#describing",
            "text": "A good Rug description states exactly what the purpose of the Rug is without capitalisation on the sentence  and  without a closing\nperiod .  The reason for avoiding sentence punctuation is that the\ndescription is often used by the Atomist Bot and the grammar of its\nusage is context-driven.  Ideally the description should be a sentence\nfragment and as short as possible while still being uniquely\ndescriptive.  The description is set as the second argument of the  decorator \ndefining the Rug operation. For instance, for an editor:  @Editor ( \"AddDockerToMavenProjects\" ,   \"adds the docker files to a Maven project\" )",
            "title": "Describing"
        },
        {
            "location": "/user-guide/rug/conventions/#discoverability",
            "text": "All Rugs should be annotated with one or more  @Tags   decorators  to optimize their discoverability. For \nexample if you were to create an Rug that alters a README file\nthen the following  @Tags  would be applicable:  @Tags ( \"readme\" ,   \"documentation\" )   Tag values should consist of only lower case letters, numbers, and\ndashes ( - ).  If possible, try to include at least one of the tags on your Rug maps to an image\nfor a nicer rendering.  The following tags currently have images: docker , github ,  travis-ci ,  apache ,  git ,  spring-boot , spring ,  clojure ,  go ,  java ,  python ,  scala , and documentation .",
            "title": "Discoverability"
        },
        {
            "location": "/user-guide/rug/conventions/#code-style",
            "text": "We suggest you rely on a  TypeScript linter  and TypeScript format checker  to catch common pitfalls in your code and\nkeep it readable and well-formatted.",
            "title": "Code style"
        },
        {
            "location": "/user-guide/rug/conventions/#parameters",
            "text": "Rug parameters should follow  TypeScript naming guidelines ,\ni.e.,  lowerCamelCase , and describe, as explicitly as\npossible, what the parameter represents.  Parameters are defined as instance variables of the class implementing\nyour Rug.  They are decorated with the  @Parameter \ndecorator to declare their metadata.  The  @Parameter \ndecorator takes a single argument, a JavaScript object with the\nfollowing properties:  { \n   displayName? :  string \n   description? :  string \n   pattern :  string \n   validInput? :  string \n   minLength? :  number   =   - 1 \n   maxLength? :  number   =   - 1 \n   required? :  boolean   =   false  }   Only the  pattern  property is required, but providing\ngood values for all properties is highly recommended.  If a property\nhas a default value, it is shown above to the right of the equal ( = )\nsign.",
            "title": "Parameters"
        },
        {
            "location": "/user-guide/rug/conventions/#description-and-display-names",
            "text": "As Rug parameters are part of the public contract of Rugs it is\nrecommended that a human-readable description and display name always\nbe applied using the  description  and  displayName  properties.  A good description and display name allows\nthe Atomist user interfaces to provide the user with the information\nneeded to provide proper values.  The  displayName  field\nvalue should be three words or less and use Title Case.",
            "title": "Description and display names"
        },
        {
            "location": "/user-guide/rug/conventions/#validation",
            "text": "It is recommended that all parameters should be restricted using the\nmost explicit and constraining regular expression that is appropriate\nfor the corresponding parameter via the  pattern \nproperty.  In addition, you should provide a meaningful value for the validInput  field so, when people provide an invalid\nvalue, they are provided with a useful error message.  The value of the  pattern  property must be\nan  anchored regular expression , i.e., it must begin\nwith  ^  and end with  $ .   Atomist bundles a set of default anchored regular expression in the Pattern  object which can be imported as follows:  import   {   Pattern   }   from   \"@atomist/rug/operations/RugOperation\" ;",
            "title": "Validation"
        },
        {
            "location": "/user-guide/rug/conventions/#mandatory-and-optional",
            "text": "If a parameter is not required, i.e., the Rug can execute sensibly\nwithout the user specifying it, set the  required \nproperty to  false .  In that case, it is recommended to\nsupply a valid default value to the parameter variable so that there\nis some predictability of how the Rug will function if no parameter is\nsupplied.",
            "title": "Mandatory and optional"
        },
        {
            "location": "/user-guide/integrations/",
            "text": "Atomist aims to give you the best experiences across industry leading\nsoftware development collaboration tools.  These include chat\nplatforms, source code repositories, continuous integration servers,\nand runtime platforms.  Currently, the Atomist platform integrates\nwith the following third-party systems:\n\n\n\n\nSlack\n\n\nGitHub.com\n\n\nTravis CI\n\n\nJenkins\n\n\n\n\nWe are always working to improve the developer experience, including\nincreasing the number integrations we support as demand dictates.\n\nCheck back here often as we are always working on growing this\nlist.\n\n\nAdditionally, Atomist users can create custom integrations for the\ntools they use that are not natively supported by Atomist.",
            "title": "Overview"
        },
        {
            "location": "/user-guide/integrations/slack/",
            "text": "Slack\n, through its real-time messaging (RTM) API, is the\nsupported means for interacting with the Atomist Bot.  Slack messages\nare sent to Atomist where they are processed and the proper action\ntaken.\n\n\nAtomist must be \ninstalled\n in your Slack team and the\nAtomist Bot must be invited to channels where you would like to\ninteract with it.  The \nGetting Started\n guide takes\nyou through this process step by step.",
            "title": "Slack"
        },
        {
            "location": "/user-guide/integrations/github/",
            "text": "GitHub.com\n provides a central repository for source code and\nalso issue tracking.  The Atomist GitHub OAuth application must be\nauthorized into your GitHub organization.  After authorization,\nAtomist will add the Atomist webhook to your organization so it can\nbegin to collect events.  When webhook data are posted to the Atomist\nwebhook endpoint, it is ingested into the system and appropriate\nactions are taken.\n\n\nSo that Atomist may take action on behalf of a user when that user\nasks it to do something, e.g., create a repository or comment on an\nissue, the Atomist GitHub application must also be authorized for each\nuser account in the organization.  After authorization, Atomist will\ncreate a personal access token with the needed scopes.\n\n\nThe Getting Started guide takes you through the process\nof \nauthorizing Atomist\n in your GitHub organization and each\nteam member\u2019s GitHub user.",
            "title": "GitHub.com"
        },
        {
            "location": "/user-guide/integrations/travis-ci/",
            "text": "Travis CI\n provides continuous integration services for\nGitHub hosted repositories.  Atomist integrates with Travis CI using\nwebhooks configured in each source code repository\u2019s Travis CI\nconfiguration.  For every Travis CI build, the standard webhook\npayload is sent to the Atomist Travis CI webhook endpoint.  Atomist\ningests this information and takes the appropriate actions.\n\n\nThe Getting Started guide takes you through the process\nof \nconfiguring Travis CI\n to send data to the Atomist webhook\nendpoint.",
            "title": "Travis CI"
        },
        {
            "location": "/user-guide/integrations/jenkins/",
            "text": "Jenkins\n is a continuous integration solution.  Atomist\nintegrates with Jenkins using the \nNotification plugin\n.  Once\nthe plugin is installed, activated, and configured, Jenkins will send\nthe standard build data to the Atomist Jenkins webhook endpoint.\nAtomist ingests this information and takes the appropriate actions.\n\n\nThe Getting Started guide takes you through the process\nof \nconfiguring Jenkins\n to send data to the Atomist webhook\nendpoint.",
            "title": "Jenkins"
        },
        {
            "location": "/user-guide/interfaces/",
            "text": "At Atomist we believe the goal of automation is that no interface is\nrequired: everything is automated.  But, for the time before you reach\nthe point of complete automation, Atomist provides two main user\ninterfaces.\n\n\n\n\nAtomist Bot\n: interacting with Atomist in chat\n\n\nRug CLI\n: interacting with Atomist on the command line",
            "title": "Introduction"
        },
        {
            "location": "/user-guide/interfaces/bot/",
            "text": "Presently, the best introduction to interacting with the Atomist Bot\nis to watch this video.\n\n\n\n  \n\n\n\n\n\nSearch\n\u00b6\n\n\nThe Atomist Bot can be used to search for Rugs.\n\n\nTo see the list of available generators to your team, ask the bot for\nthem:\n\n\n@atomist generators\n\n\n\n\nThis will return a truncated list of generators.  You can refine your\nsearch by appending filter words to the command. For instance, to\nsearch for generators for Java and Spring:\n\n\n@atomist generators java spring\n\n\n\n\nSimilarly, you can search for available editors using the \neditors\n\ncommand\n\n\n@atomist editors\n\n\n\n\nand refine the search by appending search terms.\n\n\n@atomist editors python\n\n\n\n\nGenerators\n\u00b6\n\n\nThe Atomist Bot can run generators for you, creating new projects for\nyou in GitHub.  To have the Atomist Bot create a project for you, you\nmust first search for and find the generator you want to run.  Once\nyou have found the generator you want to run, click the \u201cGenerate\nproject\u201d button below the generator.  The bot will start a thread\ndiscussion with you asking for this generator\u2019s parameters until you\ncomplete the exchange.  Once generated, the bot will inform you of the\nURL where to find your new project.",
            "title": "Bot"
        },
        {
            "location": "/user-guide/interfaces/bot/#search",
            "text": "The Atomist Bot can be used to search for Rugs.  To see the list of available generators to your team, ask the bot for\nthem:  @atomist generators  This will return a truncated list of generators.  You can refine your\nsearch by appending filter words to the command. For instance, to\nsearch for generators for Java and Spring:  @atomist generators java spring  Similarly, you can search for available editors using the  editors \ncommand  @atomist editors  and refine the search by appending search terms.  @atomist editors python",
            "title": "Search"
        },
        {
            "location": "/user-guide/interfaces/bot/#generators",
            "text": "The Atomist Bot can run generators for you, creating new projects for\nyou in GitHub.  To have the Atomist Bot create a project for you, you\nmust first search for and find the generator you want to run.  Once\nyou have found the generator you want to run, click the \u201cGenerate\nproject\u201d button below the generator.  The bot will start a thread\ndiscussion with you asking for this generator\u2019s parameters until you\ncomplete the exchange.  Once generated, the bot will inform you of the\nURL where to find your new project.",
            "title": "Generators"
        },
        {
            "location": "/user-guide/interfaces/cli/",
            "text": "The Rug command-line interface (CLI) provides users with the ability\nto execute Rugs in their command terminal and to script the execution\nof Rug using the shell.  The CLI provides developers with the tools\nthey need to create, test, and manage Rugs.\n\n\n\n\nIf you only plan on benefiting from Atomist capabilities through\nits standard integrations in chat, you do not need the CLI.\n\n\n\n\n\n\nRug CLI installation\n\n\nRug Configuration and options\n\n\nUsing the CLI to execute Rugs\n\n\nDeveloping Rugs with the Rug CLI\n\n\nRug CLI command reference",
            "title": "Overview"
        },
        {
            "location": "/user-guide/interfaces/cli/install/",
            "text": "You can install the Rug command-line interface (CLI) using the\nstandard developer packaging tools for your platform.  We currently\nsupport installing the Rug CLI on GNU/Linux Deb and RPM distributions,\nMac OS X/macOS using \nHomebrew\n, and MS Windows\nusing \nChocolatey\n.\n\n\nInstall the Rug CLI on Mac OS X / macOS\n\u00b6\n\n\nThe easiest way to get start on a Mac is to install the Rug CLI using\nour \nHomebrew\n \ntap\n repository.\n\n\nOnce you have Homebrew installed, it is just two easy steps:\n\n\n$\n brew tap atomist/tap\n\n$\n brew install rug-cli\n\n\n\n\nIf you\u2019d like to stay on the latest, possible unstable and un-released, version of the CLI you can install HEAD from:\n\n\n$\n brew upgrade --HEAD rug-cli --fetch-HEAD\n\n\n\n\nInstall the RUG CLI on Linux\n\u00b6\n\n\nWe support installing via packages on Debian and RPM-based GNU/Linux\ndistributions.\n\n\nDebian/Ubuntu\n\u00b6\n\n\nTo install on a Debian-based distributions, follow the next instructions:\n\n\n\n\n\n\nGrab the public GPG key for the repository:\n\n\n$\n wget -qO - \n'https://atomist.jfrog.io/atomist/api/gpg/key/public'\n \n|\n sudo apt-key add -\n\n\n2.  Add a new apt source entry:\n\n\n$\n \necho\n \n\"deb https://atomist.jfrog.io/atomist/debian \n$(\nlsb_release -c -s\n)\n main\"\n \n|\n sudo tee /etc/apt/sources.list.d/atomist.list\n\n\n3.  Update the metadata:\n\n\n$\n sudo apt-get update\n\n\n4.  Install the CLI:\n\n\n$\n sudo apt-get install rug-cli\n\n\n\n\n\n\n\n\n\n\nJDK 8 Requirement\n\n\nRug and the CLI require Java 8. Until Rug CLI 0.22, the package would try\nto automatically install the appropriate JDK but different people install Java\ndifferently on their machine. Therefore, starting with Rug CLI 0.22, the package\nonly suggests to install the dependency and emits the following message when\nrunning the CLI without a proper Java 8 found:\n\n\n$\n rug\n\nJAVA_HOME not set and cannot find javac to deduce location, please set JAVA_HOME.\n\n\n\n\n\nIn that case, you must ensure you set the \nJAVA_HOME\n variable for your system\nso that it points to a valid Java 8 JDK directory. On recent, Debian/Ubuntu\ndistributions, you can simply run \nsudo apt-get install openjdk-8-jdk\n. On older\ndistributions, either install Java 8 manually and set the according variable,\nor try the following instructions:\n\n\n$\n sudo add-apt-repository ppa:openjdk-r/ppa\n\n$\n sudo apt-get update\n\n$\n sudo apt-get install openjdk-8-jdk\n\n\n\n\n\n\nRedHat/CentOS\n\u00b6\n\n\nTo install on a RedHat-based distributions, follow the next instructions:\n\n\n\n\n\n\nAdd a new yum repository:\n\n\n$\n cat <<EOF \n|\n sudo tee /etc/yum.repos.d/atomist.repo\n\n[Atomist]\n\n\nname=Atomist\n\n\nbaseurl=https://atomist.jfrog.io/atomist/yum/\n\n\nenabled=1\n\n\ngpgcheck=0\n\n\nEOF\n\n\n\n\n\n\n\n\n\nInstall the CLI:\n\n\n$\n sudo yum install rug-cli\n\n\n\n\n\n\n\n\nThe only required dependency is the JDK version 8 or later.\n\n\nInstall the RUG CLI on Windows\n\u00b6\n\n\nWe used \nNuget\n and \nChocolatey\n to package and\ndistribute the CLI on Windows systems (actually wherever .NET and\nPowershell run).\n\n\nThe following steps have been tested on Windows 10, your mileage may vary.\n\n\n\n\n\n\nInstall Chocolatey on your host as per\n    the \ndoc\n\n\n\n\n\n\nInstall the \njdk8\n\n    dependency using chocolatey as an Administrator:\n    \n(admin) C:\\ > choco install jdk8\n\n\n\n\n\n\n\n\nThen, install the CLI using Chocolatey as an administrator:\n\n\n(admin) C:\\ > choco install rug-cli -s \"'https://atomist.jfrog.io/atomist/api/nuget/nuget'\"\n\n\n\n\n\nIf you want to install a pre-release rather than the\nlatest stable version, add the \n--pre\n argument to the\ncommand:\n\n\n(admin) C:\\ > choco install rug-cli --pre -s \"'https://atomist.jfrog.io/atomist/api/nuget/nuget'\"\n\n\n\n\n\nThe CLI will be installed in\n\n%programdata%\\Chocolatey\\lib\\rug-cli\n and available to your\n\n%PATH%\n. You can now run as a normal user:\n\n\n(user) C:\\ > rug --version\n\n\nrug 0.13.0\n\n\natomist/rug-cli.git (git revision 2cde8f5: last commit 2016-12-01)\n\n\n\n\n\nNotice, you will find the \n.atomist\n directory for settings and\nartifacts in \n%USERPROFILE%\\.atomist\n\n\n\n\n\n\nYou can keep your Rug CLI up to dat by regularly upgrading:\n\n\n(admin) C:\\ > choco upgrade rug-cli -s \"'https://atomist.jfrog.io/atomist/api/nuget/nuget'\"\n\n\n\n\n\nYou can remove the Rug CLI if you no longer want it installed:\n\n\n(admin) C:\\ > choco uninstall rug-cli\n\n\n\n\n\nFiles and directories in \n%USERPROFILE%\\.atomist\n will not be\nremoved. You can safely delete that directory manually if you don\u2019t\nintend to use the CLI any longer.\n\n\nDocker installation\n\u00b6\n\n\nIf you cannot install using a system-wide approach, you can rely also on\ndownloading the CLI through a Docker image we provide.\n\n\n$\n docker pull atomist-docker.jfrog.io/rug-cli\n\n\n\n\nRunning the image as will give you the Rug shell:\n\n\n$\n docker run --rm -it atomist-docker.jfrog.io/rug-cli\n\nResolving dependencies for com.atomist:rug:0.12.0 completed\n\n\nInitializing shell for com.atomist:rug:0.12.0 completed\n\n\nPress 'Tab' to complete. Type 'help' and hit 'Return' for help, and 'exit' to quit.\n\n\nrug \u2192\n\n\n\n\n\nIf you want to run the CLI, the image expects you to call \nrug\n as its first\nargument. For instance:\n\n\n$\n docker run --rm -it atomist-docker.jfrog.io/rug-cli rug --version\n\nrug 0.23.0\n\n\nhttps://github.com/atomist/rug-cli.git (git revision e77cf5f; last commit 2017-02-14)\n\n\n\n\n\nNotice how the CLI stores its settings \ninside the container\n under\n\n/home/atomist/.atomist/cli.yml\n. All the dependencies will be downloaded into\nthe \n/home/atomist/.atomist/repository\n directory.\n\n\nYou can persist those on your host by providing the following argument to the\ndocker run command: \n-v $HOME/.atomist:/home/atomist/.atomist\n.\n\n\nTo use the CLI against a project on your host, you will also need to share your\nproject\u2019s directory with the container \n/home/atomist/project\n container\u2019s\nworking directory. For example, assuming you are currently in a Rug project:\n\n\n$\n docker run --rm -it \n\\\n\n    --user \n$UID\n:\n`\nid -g\n`\n \n\\\n\n    -v \n$HOME\n/.atomist:/home/atomist/.atomist \n\\\n\n    -v \n$PWD\n:/home/atomist/project \n\\\n\n    atomist-docker.jfrog.io/rug-cli \n\\\n\n    rug\n\n\n\n\nThe constraint here is the limit imposed by the management of permissions\nbetween your host\u2019s user and the user defined in the container.\n\n\nIn the container, the CLI is not run as \nroot\n but as a regular user that\nhopefully does not map any UID on your system. A possible workaround is\nto switch to a different user at runtime, hence the rather ugly command line\nabove. Another approach is to switch to \nuser namespace\n on your host.\n\n\nManual installation\n\u00b6\n\n\nIf you are not on a supported platform, or just prefer to install the\nRug CLI yourself, you can download the Rug CLI archive, unpack it, and\nsimply put it its \nbin\n directory in your \nPATH\n.\n\n\n\n\n\n\nMake sure you have Java 8 or later installed.  Run the following\n    command in a terminal and make sure you get an output something\n    like that shown.\n\n\n$\n java -version\n\njava version \"1.8.0_66\"\n\n\nJava(TM) SE Runtime Environment (build 1.8.0_66-b17)\n\n\nJava HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)\n\n\n\n\n\nIf that command is unsuccessful, see \nInstalling Java\n\nor \nInstalling OpenJDK\n.\n\n\n\n\n\n\nDownload either the \n.tar.gz\n or \n.zip\n archive from the\n    \nlatest Rug CLI release\n.\n\n\n\n\n\n\nUnpack the archive in an appropriate location.  Replace \nVERSION\n\n    with the version you downloaded.\n\n\n$\n mkdir \n$HOME\n/opt\n\n$\n \ncd\n \n$HOME\n/opt\n\n$\n tar -x -z -f rug-cli-VERSION-bin.tar.gz\n\n$\n ln -s rug-cli-VERSION rug-cli\n\n\n\n\nor\n\n\n$\n mkdir \n$HOME\n/opt\n\n$\n \ncd\n \n$HOME\n/opt\n\n$\n unzip rug-cli-VERSION-bin.zip\n\n$\n ln -s rug-cli-VERSION rug-cli\n\n\n\n\nOn MS Windows, download the \n.zip\n and double-click it to extract\nits contents.\n\n\n\n\n\n\nAdd the Rug CLI \nbin\n directory to your \nPATH\n.\n\n\n$\n \nexport\n \nPATH\n=\n$PATH\n:\n$HOME\n/opt/rug-cli/bin\n\n\n\n\nAdd the above command to your shell startup script to ensure you\nalways will have access to the Rug CLI.  On MS Windows,\nsee \nHow to Edit Your System Path\n, adding the \nbin\n\ndirectory of the archive you unpacked in the previous step.",
            "title": "Installation"
        },
        {
            "location": "/user-guide/interfaces/cli/install/#install-the-rug-cli-on-mac-os-x-macos",
            "text": "The easiest way to get start on a Mac is to install the Rug CLI using\nour  Homebrew   tap  repository.  Once you have Homebrew installed, it is just two easy steps:  $  brew tap atomist/tap $  brew install rug-cli  If you\u2019d like to stay on the latest, possible unstable and un-released, version of the CLI you can install HEAD from:  $  brew upgrade --HEAD rug-cli --fetch-HEAD",
            "title": "Install the Rug CLI on Mac OS X / macOS"
        },
        {
            "location": "/user-guide/interfaces/cli/install/#install-the-rug-cli-on-linux",
            "text": "We support installing via packages on Debian and RPM-based GNU/Linux\ndistributions.",
            "title": "Install the RUG CLI on Linux"
        },
        {
            "location": "/user-guide/interfaces/cli/install/#debianubuntu",
            "text": "To install on a Debian-based distributions, follow the next instructions:    Grab the public GPG key for the repository:  $  wget -qO -  'https://atomist.jfrog.io/atomist/api/gpg/key/public'   |  sudo apt-key add - \n2.  Add a new apt source entry:  $   echo   \"deb https://atomist.jfrog.io/atomist/debian  $( lsb_release -c -s )  main\"   |  sudo tee /etc/apt/sources.list.d/atomist.list \n3.  Update the metadata:  $  sudo apt-get update \n4.  Install the CLI:  $  sudo apt-get install rug-cli     JDK 8 Requirement  Rug and the CLI require Java 8. Until Rug CLI 0.22, the package would try\nto automatically install the appropriate JDK but different people install Java\ndifferently on their machine. Therefore, starting with Rug CLI 0.22, the package\nonly suggests to install the dependency and emits the following message when\nrunning the CLI without a proper Java 8 found:  $  rug JAVA_HOME not set and cannot find javac to deduce location, please set JAVA_HOME.   In that case, you must ensure you set the  JAVA_HOME  variable for your system\nso that it points to a valid Java 8 JDK directory. On recent, Debian/Ubuntu\ndistributions, you can simply run  sudo apt-get install openjdk-8-jdk . On older\ndistributions, either install Java 8 manually and set the according variable,\nor try the following instructions:  $  sudo add-apt-repository ppa:openjdk-r/ppa $  sudo apt-get update $  sudo apt-get install openjdk-8-jdk",
            "title": "Debian/Ubuntu"
        },
        {
            "location": "/user-guide/interfaces/cli/install/#redhatcentos",
            "text": "To install on a RedHat-based distributions, follow the next instructions:    Add a new yum repository:  $  cat <<EOF  |  sudo tee /etc/yum.repos.d/atomist.repo [Atomist]  name=Atomist  baseurl=https://atomist.jfrog.io/atomist/yum/  enabled=1  gpgcheck=0  EOF     Install the CLI:  $  sudo yum install rug-cli    The only required dependency is the JDK version 8 or later.",
            "title": "RedHat/CentOS"
        },
        {
            "location": "/user-guide/interfaces/cli/install/#install-the-rug-cli-on-windows",
            "text": "We used  Nuget  and  Chocolatey  to package and\ndistribute the CLI on Windows systems (actually wherever .NET and\nPowershell run).  The following steps have been tested on Windows 10, your mileage may vary.    Install Chocolatey on your host as per\n    the  doc    Install the  jdk8 \n    dependency using chocolatey as an Administrator:\n     (admin) C:\\ > choco install jdk8     Then, install the CLI using Chocolatey as an administrator:  (admin) C:\\ > choco install rug-cli -s \"'https://atomist.jfrog.io/atomist/api/nuget/nuget'\"   If you want to install a pre-release rather than the\nlatest stable version, add the  --pre  argument to the\ncommand:  (admin) C:\\ > choco install rug-cli --pre -s \"'https://atomist.jfrog.io/atomist/api/nuget/nuget'\"   The CLI will be installed in %programdata%\\Chocolatey\\lib\\rug-cli  and available to your %PATH% . You can now run as a normal user:  (user) C:\\ > rug --version  rug 0.13.0  atomist/rug-cli.git (git revision 2cde8f5: last commit 2016-12-01)   Notice, you will find the  .atomist  directory for settings and\nartifacts in  %USERPROFILE%\\.atomist    You can keep your Rug CLI up to dat by regularly upgrading:  (admin) C:\\ > choco upgrade rug-cli -s \"'https://atomist.jfrog.io/atomist/api/nuget/nuget'\"   You can remove the Rug CLI if you no longer want it installed:  (admin) C:\\ > choco uninstall rug-cli   Files and directories in  %USERPROFILE%\\.atomist  will not be\nremoved. You can safely delete that directory manually if you don\u2019t\nintend to use the CLI any longer.",
            "title": "Install the RUG CLI on Windows"
        },
        {
            "location": "/user-guide/interfaces/cli/install/#docker-installation",
            "text": "If you cannot install using a system-wide approach, you can rely also on\ndownloading the CLI through a Docker image we provide.  $  docker pull atomist-docker.jfrog.io/rug-cli  Running the image as will give you the Rug shell:  $  docker run --rm -it atomist-docker.jfrog.io/rug-cli Resolving dependencies for com.atomist:rug:0.12.0 completed  Initializing shell for com.atomist:rug:0.12.0 completed  Press 'Tab' to complete. Type 'help' and hit 'Return' for help, and 'exit' to quit.  rug \u2192   If you want to run the CLI, the image expects you to call  rug  as its first\nargument. For instance:  $  docker run --rm -it atomist-docker.jfrog.io/rug-cli rug --version rug 0.23.0  https://github.com/atomist/rug-cli.git (git revision e77cf5f; last commit 2017-02-14)   Notice how the CLI stores its settings  inside the container  under /home/atomist/.atomist/cli.yml . All the dependencies will be downloaded into\nthe  /home/atomist/.atomist/repository  directory.  You can persist those on your host by providing the following argument to the\ndocker run command:  -v $HOME/.atomist:/home/atomist/.atomist .  To use the CLI against a project on your host, you will also need to share your\nproject\u2019s directory with the container  /home/atomist/project  container\u2019s\nworking directory. For example, assuming you are currently in a Rug project:  $  docker run --rm -it  \\ \n    --user  $UID : ` id -g `   \\ \n    -v  $HOME /.atomist:/home/atomist/.atomist  \\ \n    -v  $PWD :/home/atomist/project  \\ \n    atomist-docker.jfrog.io/rug-cli  \\ \n    rug  The constraint here is the limit imposed by the management of permissions\nbetween your host\u2019s user and the user defined in the container.  In the container, the CLI is not run as  root  but as a regular user that\nhopefully does not map any UID on your system. A possible workaround is\nto switch to a different user at runtime, hence the rather ugly command line\nabove. Another approach is to switch to  user namespace  on your host.",
            "title": "Docker installation"
        },
        {
            "location": "/user-guide/interfaces/cli/install/#manual-installation",
            "text": "If you are not on a supported platform, or just prefer to install the\nRug CLI yourself, you can download the Rug CLI archive, unpack it, and\nsimply put it its  bin  directory in your  PATH .    Make sure you have Java 8 or later installed.  Run the following\n    command in a terminal and make sure you get an output something\n    like that shown.  $  java -version java version \"1.8.0_66\"  Java(TM) SE Runtime Environment (build 1.8.0_66-b17)  Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)   If that command is unsuccessful, see  Installing Java \nor  Installing OpenJDK .    Download either the  .tar.gz  or  .zip  archive from the\n     latest Rug CLI release .    Unpack the archive in an appropriate location.  Replace  VERSION \n    with the version you downloaded.  $  mkdir  $HOME /opt $   cd   $HOME /opt $  tar -x -z -f rug-cli-VERSION-bin.tar.gz $  ln -s rug-cli-VERSION rug-cli  or  $  mkdir  $HOME /opt $   cd   $HOME /opt $  unzip rug-cli-VERSION-bin.zip $  ln -s rug-cli-VERSION rug-cli  On MS Windows, download the  .zip  and double-click it to extract\nits contents.    Add the Rug CLI  bin  directory to your  PATH .  $   export   PATH = $PATH : $HOME /opt/rug-cli/bin  Add the above command to your shell startup script to ensure you\nalways will have access to the Rug CLI.  On MS Windows,\nsee  How to Edit Your System Path , adding the  bin \ndirectory of the archive you unpacked in the previous step.",
            "title": "Manual installation"
        },
        {
            "location": "/user-guide/interfaces/cli/basics/",
            "text": "Before we get to using the CLI, let\u2019s cover some information on\nconfiguration and behavior.\n\n\nConfiguring\n\u00b6\n\n\nThe default Rug CLI configuration file is located at\n\n~/.atomist/cli.yml\n.  You can override the default location using the\n\n--settings=PATH\n command-line option.  As the configuration file\nextension suggests, it is a \nYAML\n file.\n\n\nIf you are using the default configuration file and one does not\nexist, the CLI will create a default one for you with contents like\nthe following.\n\n\n# Set up the path to the local repository\n\n\nlocal-repository\n:\n\n  \npath\n:\n \n\"${user.home}/.atomist/repository\"\n\n\n\n# Set up remote repositories to query for Rug archives. Additionally one of the\n\n\n# repositories can also be enabled for publication (publish: true).\n\n\nremote-repositories\n:\n\n  \ncentral\n:\n\n    \npublish\n:\n \nfalse\n\n    \nurl\n:\n \n\"http://repo.maven.apache.org/maven2/\"\n\n  \nrugs\n:\n\n    \npublish\n:\n \nfalse\n\n    \nurl\n:\n \n\"https://atomist.jfrog.io/atomist/rugs\"\n\n\n\n\n\nYou can configure a repository directory on your local file system\nusing the \npath\n key under the \nlocal-repository\n key.  When\nspecifying your system home directory, use the portable \n${user.home}\n\nrather than system-specific \n$HOME\n or \n~\n.\n\n\nYou can specify any number of remote repositories under the\n\nremote-repositories\n key.  The value of the key should be a mapping\nwhose keys are unique identifiers for each entry and whose values\nprovide the \nurl\n and optionally whether to \npublish\n rugs to the\nrepository.  If you are publishing Rugs to the repository, you will\nlikely need to supply \nauthentication\n details for the repository.\nThe authentication details should be a mapping specifying the\n\nusername\n and \npassword\n.  A complete configuration for publishing to\na repository would look something like:\n\n\nremote-repositories\n:\n\n  \nrugs-release\n:\n\n    \npublish\n:\n \ntrue\n\n    \nurl\n:\n \n\"https://atomist.jfrog.io/atomist/rugs-release\"\n\n    \nauthentication\n:\n\n      \nusername\n:\n \n\"YOUR_USER_NAME\"\n\n      \npassword\n:\n \n\"YOUR_PASSWORD_OR_TOKEN\"\n\n\n\n\n\nDependency Resolution\n\u00b6\n\n\nThe Rug CLI will automatically resolve and download all dependencies\nit needs to perform the requested operation.  Dependencies\ninclude \nJAR\n files and Rug archives.  Dependencies will be\ndownloaded to the configured local repository, \n~/.atomist/repository\n\nby default, via \nAether\n and resolved from there.\n\n\nHelp\n\u00b6\n\n\nThe Rug CLI provides standard help output when the \n--help\n, \n-h\n, or\n\n-?\n command-line option is used.  All of these options provide the\nsame output in the same context.  You can use the help command-line\noption on the \nrug\n command itself to receive general information\nabout the Rug CLI, its options, and its subcommands.\n\n\n$\n rug --help\n\nUsage: rug [OPTION]... [COMMAND]...\n\n\nWork with Rugs like editors or generators.\n\n\n\nOptions:\n\n\n  -?,-h,--help  Print help information\n\n\n  -q,--quiet    Do not display progress messages\n\n\n  -v,--version  Print version information\n\n\n\nAvailable commands:\n\n\n  search        Search online catalog of available archives\n\n\n  list          List locally installed archives\n\n\n  describe      Print details about an archive or Rug\n\n\n\n  generate      Run a generator to create a new project\n\n\n  edit          Run an editor to modify an existing project\n\n\n  test          Run test scenarios\n\n\n  install       Create and install an archive into the local repository\n\n\n  publish       Create and publish an archive into a remote repository\n\n\n\n  tree          Evaluate a tree expression against a project\n\n\n\n  repositories  Login and configure team-scoped repositories\n\n\n  default       Set default archive\n\n\n  extension     Manage command line extensions\n\n\n\n  shell         Start a shell for the specified Rug archive\n\n\n  help          Print usage help\n\n\n\nRun 'rug COMMAND --help' for more detailed information on COMMAND.\n\n\n\nPlease report issues at https://github.com/atomist/rug-cli\n\n\n\n\n\nYou can get help on any subcommand by supplying the help command-line\noption after the subcommand.\n\n\n$\n rug search --help\n\nUsage: rug search [OPTION]... [SEARCH]\n\n\nSearch online catalog of available archives.\n\n\n\nOptions:\n\n\n  -X,--error            Print stacktraces\n\n\n  -?,-h,--help          Print help information\n\n\n  -o,--offline          Use only downloaded archives\n\n\n  -q,--quiet            Do not display progress messages\n\n\n  -r,--resolver-report  Print dependency tree\n\n\n  -s,--settings FILE    Use settings file FILE\n\n\n  -t,--timer            Print timing information\n\n\n  -u,--update           Update dependency resolution\n\n\n  -V,--verbose          Print verbose output\n\n\n\nCommand Options:\n\n\n  --operations     Show operations in search output\n\n\n  -T,--tag TAG     Specify a TAG to filter search\n\n\n  --type TYPE      Specify a TYPE to filter search based on Rug type\n\n\n\nSEARCH could be any text used to search the catalog.  TAG can be any valid tag,\n\n\neg. spring or elm.  TYPE can be either 'editor', 'generator', 'executor' or\n\n\n'reviewer'.\n\n\n\nPlease report issues at https://github.com/atomist/rug-cli\n\n\n\n\n\nVersion\n\u00b6\n\n\nThe Rug CLI supports the standard \n--version\n command-line option.  It\nwill print the canonical version information on the first line of\noutput.  The second line contains detailed information from Git.\n\n\n$\n rug --version\n\nrug 0.25.0\n\n\nhttps://github.com/atomist/rug-cli.git (git revision a7aab63; last commit 2017-03-10)\n\n\n\n\n\nDebugging\n\u00b6\n\n\nIf you want a more verbose output that includes any exceptions that\nRug command may have encountered, please add \n-X\n to your command.\nFor example:\n\n\n$\n rug \ntest\n -X",
            "title": "Basics"
        },
        {
            "location": "/user-guide/interfaces/cli/basics/#configuring",
            "text": "The default Rug CLI configuration file is located at ~/.atomist/cli.yml .  You can override the default location using the --settings=PATH  command-line option.  As the configuration file\nextension suggests, it is a  YAML  file.  If you are using the default configuration file and one does not\nexist, the CLI will create a default one for you with contents like\nthe following.  # Set up the path to the local repository  local-repository : \n   path :   \"${user.home}/.atomist/repository\"  # Set up remote repositories to query for Rug archives. Additionally one of the  # repositories can also be enabled for publication (publish: true).  remote-repositories : \n   central : \n     publish :   false \n     url :   \"http://repo.maven.apache.org/maven2/\" \n   rugs : \n     publish :   false \n     url :   \"https://atomist.jfrog.io/atomist/rugs\"   You can configure a repository directory on your local file system\nusing the  path  key under the  local-repository  key.  When\nspecifying your system home directory, use the portable  ${user.home} \nrather than system-specific  $HOME  or  ~ .  You can specify any number of remote repositories under the remote-repositories  key.  The value of the key should be a mapping\nwhose keys are unique identifiers for each entry and whose values\nprovide the  url  and optionally whether to  publish  rugs to the\nrepository.  If you are publishing Rugs to the repository, you will\nlikely need to supply  authentication  details for the repository.\nThe authentication details should be a mapping specifying the username  and  password .  A complete configuration for publishing to\na repository would look something like:  remote-repositories : \n   rugs-release : \n     publish :   true \n     url :   \"https://atomist.jfrog.io/atomist/rugs-release\" \n     authentication : \n       username :   \"YOUR_USER_NAME\" \n       password :   \"YOUR_PASSWORD_OR_TOKEN\"",
            "title": "Configuring"
        },
        {
            "location": "/user-guide/interfaces/cli/basics/#dependency-resolution",
            "text": "The Rug CLI will automatically resolve and download all dependencies\nit needs to perform the requested operation.  Dependencies\ninclude  JAR  files and Rug archives.  Dependencies will be\ndownloaded to the configured local repository,  ~/.atomist/repository \nby default, via  Aether  and resolved from there.",
            "title": "Dependency Resolution"
        },
        {
            "location": "/user-guide/interfaces/cli/basics/#help",
            "text": "The Rug CLI provides standard help output when the  --help ,  -h , or -?  command-line option is used.  All of these options provide the\nsame output in the same context.  You can use the help command-line\noption on the  rug  command itself to receive general information\nabout the Rug CLI, its options, and its subcommands.  $  rug --help Usage: rug [OPTION]... [COMMAND]...  Work with Rugs like editors or generators.  Options:    -?,-h,--help  Print help information    -q,--quiet    Do not display progress messages    -v,--version  Print version information  Available commands:    search        Search online catalog of available archives    list          List locally installed archives    describe      Print details about an archive or Rug    generate      Run a generator to create a new project    edit          Run an editor to modify an existing project    test          Run test scenarios    install       Create and install an archive into the local repository    publish       Create and publish an archive into a remote repository    tree          Evaluate a tree expression against a project    repositories  Login and configure team-scoped repositories    default       Set default archive    extension     Manage command line extensions    shell         Start a shell for the specified Rug archive    help          Print usage help  Run 'rug COMMAND --help' for more detailed information on COMMAND.  Please report issues at https://github.com/atomist/rug-cli   You can get help on any subcommand by supplying the help command-line\noption after the subcommand.  $  rug search --help Usage: rug search [OPTION]... [SEARCH]  Search online catalog of available archives.  Options:    -X,--error            Print stacktraces    -?,-h,--help          Print help information    -o,--offline          Use only downloaded archives    -q,--quiet            Do not display progress messages    -r,--resolver-report  Print dependency tree    -s,--settings FILE    Use settings file FILE    -t,--timer            Print timing information    -u,--update           Update dependency resolution    -V,--verbose          Print verbose output  Command Options:    --operations     Show operations in search output    -T,--tag TAG     Specify a TAG to filter search    --type TYPE      Specify a TYPE to filter search based on Rug type  SEARCH could be any text used to search the catalog.  TAG can be any valid tag,  eg. spring or elm.  TYPE can be either 'editor', 'generator', 'executor' or  'reviewer'.  Please report issues at https://github.com/atomist/rug-cli",
            "title": "Help"
        },
        {
            "location": "/user-guide/interfaces/cli/basics/#version",
            "text": "The Rug CLI supports the standard  --version  command-line option.  It\nwill print the canonical version information on the first line of\noutput.  The second line contains detailed information from Git.  $  rug --version rug 0.25.0  https://github.com/atomist/rug-cli.git (git revision a7aab63; last commit 2017-03-10)",
            "title": "Version"
        },
        {
            "location": "/user-guide/interfaces/cli/basics/#debugging",
            "text": "If you want a more verbose output that includes any exceptions that\nRug command may have encountered, please add  -X  to your command.\nFor example:  $  rug  test  -X",
            "title": "Debugging"
        },
        {
            "location": "/user-guide/interfaces/cli/using-rugs/",
            "text": "The Rug CLI is able to run Rugs locally against projects on your local\nfile system.\n\n\n\n\nThe command-line example below are intended to illuminate the use\nof the Rug CLI.  The Rugs referenced and sample output do not\nnecessarily reflect the current reality.\n\n\n\n\n\n\nThe \nrug CLI\n downloads the Rugs and dependencies it needs on the\nfly. There is no specific \ndownload\n command.\n\n\n\n\nSearch\n\u00b6\n\n\nTo find available generators with the CLI, run the following command.\n\n\n$\n rug search --operations --type\n=\ngenerator\n\nResolving version range for com.atomist:rug:(0.12.9,0.13.1) completed\n\n\nResolving dependencies for com.atomist:rug:0.13.0-SNAPSHOT completed\n\n\n  Searching https://api.atomist.com/catalog/operation/search\n\n\nSearching catalogs completed\n\n\n\n\u2192 Remote Archives (18 archives found)\n\n\n  atomist-rugs:flask-service [public] (0.1.2)\n\n\n    Generators\n\n\n    \u2514\u2500\u2500 NewFlaskMicroserviceProject\n\n\n  atomist-rugs:rug-project [public] (0.2.0)\n\n\n    Generators\n\n\n    \u251c\u2500\u2500 NewRugProject\n\n\n    \u2514\u2500\u2500 NewStarterRugProject\n\n\n  atomist-rugs:spring-boot-rest-service [public] (0.7.1)\n\n\n    Generators\n\n\n    \u2514\u2500\u2500 NewSpringBootRestService\n\n\n...\n\n\n\n\n\nWhen you use the \n--operations\n command-line argument, the output\nlists the name of the Rug and its Rug archive.  Providing the \n--type\nRUG_TYPE\n command-line option limits the results to Rugs of that type,\ne.g., \ngenerator\n or \neditor\n.  The \n-T\n or \n--tag\n command-line\noption can be provided to limit the search results to only those Rugs\nthat have the provided tag.  You can supply the tag command-line\noption multiple times.\n\n\n$\n rug search --operations --tag\n=\nrug --tag\n=\ntypescript\n\nResolving dependencies for atomist-rugs:rug-editors:0.15.0 \u2190 local completed\n\n\n  Searching https://api.atomist.com/catalog\n\n\nSearching catalogs completed\n\n\n\n\u2192 Remote Archives (1 archive found)\n\n\n  atomist-rugs:rug-editors [public] (0.14.0)\n\n\n    Editors\n\n\n    \u251c\u2500\u2500 AddTypeScript\n\n\n    \u251c\u2500\u2500 AddTypeScriptEditor\n\n\n    \u2514\u2500\u2500 AddTypeScriptGenerator\n\n\n\nFor more information on specific archive version, run:\n\n\n  rug describe archive ARCHIVE -a VERSION\n\n\n\n\n\nDescribe\n\u00b6\n\n\nTo get information about a Rug and list all its parameters, run the\n\nrug describe\n command.\n\n\n$\n rug describe archive atomist-rugs:spring-rest-service\n\n\n$\n rug describe editor atomist-rugs:spring-boot-rest-service:SpringBootThing \n\\\n\n    --artifact-version\n=\n1\n.0.0\n\n\n$\n rug describe generator atomist-rugs:spring-boot-rest-service:NewSpringBootThing\n\n\n\n\nProviding \n--artifact-version\n is optional and defaults to \nlatest\n\nsemantics.\n\n\nList\n\u00b6\n\n\nTo list all locally available Rug archives, run the \nrug list\n\ncommand:\n\n\n$\n rug list -f \n'version=[1.2,2.0)'\n -f \n'group=*atomist*'\n -f \n'artifact=*sp?ing*'\n\n\n\n\n\nThe local listing can be filtered by using \n-f\n filter expressions on\n\ngroup\n, \nartifact\n and \nversion\n. \ngroup\n and \nartifact\n support\nwildcards of \n*\n and \n?\n.  \nversion\n takes any version constraint.\n\n\nEdit\n\u00b6\n\n\nRun an editor as follows:\n\n\n$\n rug edit atomist-rugs:common-editors:AddReadme --artifact-version\n=\n1\n.0.0 \n\\\n\n    \nparameter1\n=\nfoo \nparameter2\n=\nbar\n\n\n$\n rug edit atomist-rugs:common-editors:AddReadme \nparameter1\n=\nfoo \nparameter2\n=\nbar\n\n\n\n\nProviding \n--artifact-version\n is optional and defaults to \nlatest\n\nsemantics.  \n--change-dir\n or \n-C\n to tell the CLI to apply the editor\nto a directory other than the current working directory.\n\n\nYou can also run editors in \ninteractive mode\n using the \n-I\n or\n\n--interactive\n command-line option.  In this mode, the CLI will\nprompt you to supply values for each editor parameter.  If you supply\na value for a parameter on the command line in this mode, the CLI will\nuse that value as the default when prompting.\n\n\n$\n rug edit --interactive atomist-rugs:rug-editors:AddTypeScriptEditor \neditor_name\n=\nMyNewEditor\n\nResolving dependencies for atomist-rugs:rug-editors:latest completed\n\n\nLoading atomist-rugs:rug-editors:0.14.0 into runtime completed\n\n\n\n\u2192 Please specify parameter values\n\n\n  Press 'Enter' to accept default or provided values. '*' indicates required parameters.\n\n\n\n  name of new editor to add to Rug archive project\n\n\n  \u2192 editor_name [MyNewEditor]*:\n\n\n\n  short description of editor to add to Rug archive project\n\n\n  \u2192 description *: an editor created interactively\n\n\n\nRunning editor AddTypeScriptEditor of atomist-rugs:rug-editors:0.14.0 completed\n\n\n...\n\n\n\n\n\nGenerators\n\u00b6\n\n\nYou can create new projects on your local machine using the CLI, for instance:\n\n\n$\n \ncd\n ~/workspace\n\n$\n rug generate atomist-rugs:rug-project:NewStarterRugProject my-new-generator\n\n\n\n\nThe first argument is always the project name.  If the generator\nrequires additional parameters, just append the \nparameter=value\n to\nthe end of the command line.\n\n\n$\n rug generate atomist-rugs:spring-boot-rest-service:NewSpringBootRestService\n\" \\\n\n\n    --artifact-version=1.0.0 my-new-project parameter1=foo parameter2=bar\n\n\n\n$\n rug generate atomist-rugs:spring-boot-rest-service:NewSpringBootRestService\n\" \\\n\n\n    my-new-project parameter1=foo parameter2=bar\n\n\n\n\n\nProviding \n--artifact-version\n is optional and defaults to \nlatest\n\nsemantics.  \n--change-dir\n or \n-C\n to tell the CLI to create the\nproject under a directory different than the current working\ndirectory.\n\n\nLike editors, you can also run generators in interactive mode and the\nCLI will prompt you for each parameter value rather than having to set\nit on the command line.",
            "title": "Using Rugs"
        },
        {
            "location": "/user-guide/interfaces/cli/using-rugs/#search",
            "text": "To find available generators with the CLI, run the following command.  $  rug search --operations --type = generator Resolving version range for com.atomist:rug:(0.12.9,0.13.1) completed  Resolving dependencies for com.atomist:rug:0.13.0-SNAPSHOT completed    Searching https://api.atomist.com/catalog/operation/search  Searching catalogs completed  \u2192 Remote Archives (18 archives found)    atomist-rugs:flask-service [public] (0.1.2)      Generators      \u2514\u2500\u2500 NewFlaskMicroserviceProject    atomist-rugs:rug-project [public] (0.2.0)      Generators      \u251c\u2500\u2500 NewRugProject      \u2514\u2500\u2500 NewStarterRugProject    atomist-rugs:spring-boot-rest-service [public] (0.7.1)      Generators      \u2514\u2500\u2500 NewSpringBootRestService  ...   When you use the  --operations  command-line argument, the output\nlists the name of the Rug and its Rug archive.  Providing the  --type\nRUG_TYPE  command-line option limits the results to Rugs of that type,\ne.g.,  generator  or  editor .  The  -T  or  --tag  command-line\noption can be provided to limit the search results to only those Rugs\nthat have the provided tag.  You can supply the tag command-line\noption multiple times.  $  rug search --operations --tag = rug --tag = typescript Resolving dependencies for atomist-rugs:rug-editors:0.15.0 \u2190 local completed    Searching https://api.atomist.com/catalog  Searching catalogs completed  \u2192 Remote Archives (1 archive found)    atomist-rugs:rug-editors [public] (0.14.0)      Editors      \u251c\u2500\u2500 AddTypeScript      \u251c\u2500\u2500 AddTypeScriptEditor      \u2514\u2500\u2500 AddTypeScriptGenerator  For more information on specific archive version, run:    rug describe archive ARCHIVE -a VERSION",
            "title": "Search"
        },
        {
            "location": "/user-guide/interfaces/cli/using-rugs/#describe",
            "text": "To get information about a Rug and list all its parameters, run the rug describe  command.  $  rug describe archive atomist-rugs:spring-rest-service $  rug describe editor atomist-rugs:spring-boot-rest-service:SpringBootThing  \\ \n    --artifact-version = 1 .0.0 $  rug describe generator atomist-rugs:spring-boot-rest-service:NewSpringBootThing  Providing  --artifact-version  is optional and defaults to  latest \nsemantics.",
            "title": "Describe"
        },
        {
            "location": "/user-guide/interfaces/cli/using-rugs/#list",
            "text": "To list all locally available Rug archives, run the  rug list \ncommand:  $  rug list -f  'version=[1.2,2.0)'  -f  'group=*atomist*'  -f  'artifact=*sp?ing*'   The local listing can be filtered by using  -f  filter expressions on group ,  artifact  and  version .  group  and  artifact  support\nwildcards of  *  and  ? .   version  takes any version constraint.",
            "title": "List"
        },
        {
            "location": "/user-guide/interfaces/cli/using-rugs/#edit",
            "text": "Run an editor as follows:  $  rug edit atomist-rugs:common-editors:AddReadme --artifact-version = 1 .0.0  \\ \n     parameter1 = foo  parameter2 = bar $  rug edit atomist-rugs:common-editors:AddReadme  parameter1 = foo  parameter2 = bar  Providing  --artifact-version  is optional and defaults to  latest \nsemantics.   --change-dir  or  -C  to tell the CLI to apply the editor\nto a directory other than the current working directory.  You can also run editors in  interactive mode  using the  -I  or --interactive  command-line option.  In this mode, the CLI will\nprompt you to supply values for each editor parameter.  If you supply\na value for a parameter on the command line in this mode, the CLI will\nuse that value as the default when prompting.  $  rug edit --interactive atomist-rugs:rug-editors:AddTypeScriptEditor  editor_name = MyNewEditor Resolving dependencies for atomist-rugs:rug-editors:latest completed  Loading atomist-rugs:rug-editors:0.14.0 into runtime completed  \u2192 Please specify parameter values    Press 'Enter' to accept default or provided values. '*' indicates required parameters.    name of new editor to add to Rug archive project    \u2192 editor_name [MyNewEditor]*:    short description of editor to add to Rug archive project    \u2192 description *: an editor created interactively  Running editor AddTypeScriptEditor of atomist-rugs:rug-editors:0.14.0 completed  ...",
            "title": "Edit"
        },
        {
            "location": "/user-guide/interfaces/cli/using-rugs/#generators",
            "text": "You can create new projects on your local machine using the CLI, for instance:  $   cd  ~/workspace $  rug generate atomist-rugs:rug-project:NewStarterRugProject my-new-generator  The first argument is always the project name.  If the generator\nrequires additional parameters, just append the  parameter=value  to\nthe end of the command line.  $  rug generate atomist-rugs:spring-boot-rest-service:NewSpringBootRestService \" \\      --artifact-version=1.0.0 my-new-project parameter1=foo parameter2=bar  $  rug generate atomist-rugs:spring-boot-rest-service:NewSpringBootRestService \" \\      my-new-project parameter1=foo parameter2=bar   Providing  --artifact-version  is optional and defaults to  latest \nsemantics.   --change-dir  or  -C  to tell the CLI to create the\nproject under a directory different than the current working\ndirectory.  Like editors, you can also run generators in interactive mode and the\nCLI will prompt you for each parameter value rather than having to set\nit on the command line.",
            "title": "Generators"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/",
            "text": "The Rug CLI gives you the tooling to develop, test, and publish your\nown Rugs.\n\n\nAdditional Dependencies\n\u00b6\n\n\nRugs are implemented in \nTypeScript\n and it is recommended you\ninstall \nnpm\n.  You should also get an \nIDE/editor\n with\ngood support for TypeScript language.\n\n\nQuick CLI Tour\n\u00b6\n\n\nGet some Rugs\n\u00b6\n\n\nTo generate and edit code with Rug automation, you should become\nfamiliar with Rug editors, generators, and reviewers.  The best way to\ndo that is to look at some examples.  Some examples of Rug editors can\nbe found in the \nrug-rugs\n repo.  You can clone that repo with the\nfollowing command.\n\n\n$\n git clone https://github.com/atomist/rug-rugs.git\n\n$\n \ncd\n rug-rugs\n\n$\n ls -1F\n\nCHANGELOG.md\n\n\nCODE_OF_CONDUCT.md\n\n\nLICENSE\n\n\nREADME.md\n\n\nsrc/\n\n\n\n\n\nYou cloned the repo, but where are the Rugs?  Rugs are always located\nin the \n.atomist\n directory at the top level of the project, i.e., the\nsame directory that has the \n.git\n directory.\n\n\n$\n ls -1F .atomist/\n\nbuild/\n\n\neditors/\n\n\npackage.json\n\n\ntarget/\n\n\ntemplates/\n\n\ntests/\n\n\n\n\n\nHere you can see the standard layout for a Rug directory.  It has a\n\npackage.json\n describing the contents of the project.  Think of this\nas the metadata for your Rugs, i.e., the name, version, dependencies,\netc.  The editors and generators are in the \neditors\n directory.  Any\ntemplates are in the \ntemplates\n directory.  Testing is integral to\nRug, so we also use a \ntests\n directory to hold all our tests.  There\nis also a \nbuild\n directory that contains the repository\u2019s CI scripts\nand configurations.\n\n\nLet\u2019s see what editors we have available.\n\n\n$\n awk \n'$1 == \"editor\" { print $2 }'\n .atomist/editors/*.rug\n\nAddApacheSoftwareLicense20\n\n\nAddChangeLog\n\n\nAddReadme\n\n\nAddScalaMavenGitIgnore\n\n\nClassRenamer\n\n\nPackageMove\n\n\nPomParameterizer\n\n\nRemoveApacheSoftwareLicense20\n\n\nRemoveChangeLog\n\n\nRemoveCodeOfConduct\n\n\n\n\n\nFeel free to look around in the \n.atomist\n directory to see what is\nthere, investigate the Rug syntax, and see what the tests look like.\n\n\nTest those Rugs\n\u00b6\n\n\nIt is a best practice to provide tests for your Rugs.  The first Rug\ncommand we are going to try will run all of the tests available in the\nrug-rugs repo.\n\n\n$\n rug \ntest\n\n\nProcessing dependencies\n\n\n  Downloading com/atomist/rug/maven-metadata.xml \u2190 rug-types (0kb) succeeded\n\n\n  Downloading com/atomist/rug-cli-root/1.0.0/rug-cli-root-1.0.0.pom \u2190 rug-types (0kb) succeeded\n\n\n  Downloading com/atomist/rug/maven-metadata.xml \u2190 rug-types (2kb) succeeded\n\n\n  Downloading com/atomist/rug/0.8.0/rug-0.8.0.pom \u2190 rug-types (13kb) succeeded\n\n\n  ... (more downloads)\n\n\n  Downloading com/atomist/rug-cli-root/1.0.0/rug-cli-root-1.0.0.jar \u2190 rug-types (1kb) succeeded\n\n\n  Downloading org/scala-lang/scala-reflect/2.11.8/scala-reflect-2.11.8.jar \u2190 maven-central (4466kb) succeeded\n\n\nResolving dependencies for atomist:rug-rugs:0.7.0 \u2190 local completed\n\n\nLoading atomist:rug-rugs:0.7.0 \u2190 local into runtime completed\n\n\nExecuting scenario AddApacheSoftwareLicense20 should add a new LICENSE file according to a provided template...\n\n\n  Testing assertion fileExists(SimpleLiteral(LICENSE))\n\n\n  Testing assertion fileContains(SimpleLiteral(LICENSE),SimpleLiteral(Version 2.0, January 2004))\n\n\nExecuting scenario AddChangeLog should add CHANGELOG.md...\n\n\n  Testing assertion fileExists(IdentifierFunctionArg(changelog,None))\n\n\n  Testing assertion fileContains(IdentifierFunctionArg(changelog,None),IdentifierFunctionArg(repo_slug,None))\n\n\nExecuting scenario AddChangeLog should overwrite CHANGELOG.md...\n\n\n  Testing assertion fileExists(IdentifierFunctionArg(changelog,None))\n\n\n  Testing assertion fileContains(IdentifierFunctionArg(changelog,None),IdentifierFunctionArg(repo_slug,None))\n\n\n  Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileContains(changelog, \"common-editor\") ))\n\n\nExecuting scenario AddChangeLog should reject invalid repo_slug...\n\n\nExecuting scenario AddChangeLog should reject missing parameter...\n\n\nExecuting scenario AddScalaMavenGitIgnore should add a new .gitignore file according to a provided template...\n\n\n  Testing assertion fileExists(SimpleLiteral(.gitignore))\n\n\n  Testing assertion fileContains(SimpleLiteral(.gitignore),SimpleLiteral(# Created by Atomist))\n\n\nExecuting scenario AddScalaMavenGitIgnore should overwrite an existing .gitignore file according to a provided template...\n\n\n  Testing assertion fileExists(SimpleLiteral(.gitignore))\n\n\n  Testing assertion fileContains(SimpleLiteral(.gitignore),SimpleLiteral(# Created by Atomist))\n\n\nExecuting scenario AddScalaMavenGitIgnore should add a new .gitignore to a subdirectory...\n\n\n  Testing assertion fileExists(SimpleLiteral(other/.gitignore))\n\n\n  Testing assertion fileContains(SimpleLiteral(other/.gitignore),SimpleLiteral(# Created by Atomist))\n\n\nExecuting scenario AddReadme should add README.md...\n\n\n  Testing assertion fileExists(IdentifierFunctionArg(readme,None))\n\n\n  Testing assertion fileContains(IdentifierFunctionArg(readme,None),IdentifierFunctionArg(newName,None))\n\n\n  Testing assertion fileContains(IdentifierFunctionArg(readme,None),IdentifierFunctionArg(newDescription,None))\n\n\nExecuting scenario AddReadme should reject invalid value name parameter...\n\n\nExecuting scenario AddReadme should reject missing parameter...\n\n\nExecuting scenario ClassRenamer should rename simple class...\n\n\n  Testing assertion EqualsExpression(fileCount(),SimpleLiteral(1))\n\n\n  Testing assertion fileContains(SimpleLiteral(src/main/java/Cat.java),SimpleLiteral(class Cat))\n\n\nExecuting scenario ClassRenamer should rename class and leave no references to old name...\n\n\n  Testing assertion fileExists(SimpleLiteral(src/main/java/com/atomist/springrest/WeirdAndWonderful.java))\n\n\n  Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.anyFileContains(\".java\", oldclass) ))\n\n\nExecuting scenario ClassRenamer should rename class but leave any additional characters on the class name...\n\n\n  Testing assertion fileExists(SimpleLiteral(src/main/java/com/atomist/springrest/WeirdAndWonderfulConfiguration.java))\n\n\n  Testing assertion fileExists(SimpleLiteral(src/main/java/com/atomist/springrest/WeirdAndWonderfulApplication.java))\n\n\n  Testing assertion fileExists(SimpleLiteral(src/test/java/com/atomist/springrest/WeirdAndWonderfulApplicationTests.java))\n\n\n  Testing assertion fileExists(SimpleLiteral(src/test/java/com/atomist/springrest/WeirdAndWonderfulOutOfContainerIntegrationTests.java))\n\n\n  Testing assertion fileExists(SimpleLiteral(src/test/java/com/atomist/springrest/WeirdAndWonderfulWebIntegrationTests.java))\n\n\n  Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.anyFileContains(\".java\", \"SpringRest\") ))\n\n\nExecuting scenario PackageMove should move base package and leave no references to old packages...\n\n\n  Testing assertion fileExists(SimpleLiteral(src/main/java/com/foo/bar/SpringRestConfiguration.java))\n\n\n  Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.anyFileContains(\".java\", oldpack) ))\n\n\nExecuting scenario PomParameterizer should establish a new project's valid pom.xml...\n\n\n  Testing assertion fileExists(SimpleLiteral(pom.xml))\n\n\n  Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<artifactId>mynewproject</artifactId>))\n\n\n  Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<groupId>mygroup</groupId>))\n\n\n  Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<version>0.0.1-SNAPSHOT</version>))\n\n\n  Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<description>My project description</description>))\n\n\nExecuting scenario RemoveApacheSoftwareLicense20 should remove Apache license...\n\n\n  Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileExists(\"LICENSE\") ))\n\n\nExecuting scenario RemoveApacheSoftwareLicense20 should not remove other license...\n\n\nExecuting scenario RemoveChangeLog should remove CHANGELOG...\n\n\n  Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileExists(\"CHANGELOG.md\") ))\n\n\nExecuting scenario RemoveApacheSoftwareLicense20 silently do nothing if no CHANGELOG present...\n\n\nExecuting scenario RemoveCodeOfConduct should remove CODE_OF_CONDUCT...\n\n\n  Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileExists(\"CODE_OF_CONDUCT.md\") ))\n\n\nExecuting scenario RemoveCodeOfConduct silently do nothing if no CODE_OF_CONDUCT present...\n\n\nRunning test scenarios in atomist:rug-rugs:0.7.0 \u2190 local completed\n\n\n\nSuccessfully executed 22 of 22 scenarios: Test SUCCESS\n\n\n\n\n\nThe above command will download all the dependencies needed to run the\neditors defined in the rug-rugs repo.  Depending on the speed of\nyour network connection, this may take some time.  Each dependency\nonly need be downloaded once, so subsequent executions of \nrug\n will\nbe faster.\n\n\nAs you can see from the last line of output, all of the test scenarios\npassed.\n\n\nTo run a specific named test:\n\n\n$\n rug \ntest\n \n\"Whatever Test Secanrio\"\n\n\n\n\n\nTo run all scenarios from a single test file:\n\n\n$\n rug \ntest\n MyRugTestFilename\n\n\n\n\nMake your Rugs Available\n\u00b6\n\n\nThe next step is to create a Rug archive and install it locally so you\ncan use it on local projects.  This is accomplished with the \ninstall\n\ncommand.\n\n\n$\n rug install\n\nResolving dependencies for atomist:rug-rugs:0.7.0 \u2190 local completed\n\n\nLoading atomist:rug-rugs:0.7.0 \u2190 local into runtime completed\n\n\n  Generated META-INF/maven/atomist/rug-rugs/pom.xml\n\n\n  Generated .atomist/metadata.json\n\n\nGenerating archive metadata completed\n\n\n  Installed atomist/rug-rugs/0.7.0/rug-rugs-0.7.0.zip \u2192 /Users/dd/.atomist/repository\n\n\n  Installed atomist/rug-rugs/0.7.0/rug-rugs-0.7.0.pom \u2192 /Users/dd/.atomist/repository\n\n\n  Installed atomist/rug-rugs/0.7.0/rug-rugs-0.7.0-metadata.json \u2192 /Users/dd/.atomist/repository\n\n\nInstalling archive into local repository completed\n\n\n\n\u2192 Archive\n\n\n  ~/develop/atomist/rug-rugs/.atomist/target/rug-rugs-0.7.0.zip (39kb in 43 files)\n\n\n\n\u2192 Contents\n\n\n  \u251c\u2500\u252c .atomist\n\n\n...\n\n\n\nSuccessfully installed archive for atomist:rug-rugs:0.7.0\n\n\n\n\n\nThis command packages up all of the Rugs in the \n.atomist\n directory\nand installs them in your local repository, typically\n\n~/.atomist/repository\n.\n\n\nList the installed Editors\n\u00b6\n\n\nRemember above when we ran that arcane \nawk\n command to list the\neditors?  There is a better way!  Now that we some editors installed\nlocally, we can list our local editors.\n\n\n$\n rug list\n\nResolving dependencies for com.atomist:rug:0.8.0 completed\n\n\nListing local archives completed\n\n\n\n\u2192 Local Archives\n\n\n  atomist:rug-rugs (0.7.0)\n\n\n\nFor more information on specific archive version, run:\n\n\n  rug describe archive ARCHIVE -a VERSION\n\n\n\n\n\nLooks like the Rug Archive we installed is indeed installed.  That\nlast line of the output tells us how we can get more information.\nLet\u2019s try that command.  Since we only have one version available, we\ncan omit the \n-a\n command-line option.  When it is not provided, the\nlatest version is used.\n\n\n$\n rug describe archive atomist:rug-rugs\n\nProcessing dependencies\n\n\n  Downloading atomist/rug-rugs/maven-metadata.xml \u2190 rugs (0kb) succeeded\n\n\nResolving dependencies for atomist:rug-rugs:latest completed\n\n\nLoading atomist:rug-rugs:0.7.0 into runtime completed\n\n\n\natomist:rug-rugs:0.7.0\n\n\n\n\u2192 Origin\n\n\n  atomist/rug-rugs.git#master (622ed10)\n\n\n\u2192 Archive\n\n\n  ~/.atomist/repository/atomist/rug-rugs/0.7.0/rug-rugs-0.7.0.zip (39kb in 43 files)\n\n\n\n\u2192 Editors\n\n\n  AddApacheSoftwareLicense20 (add the Apache Software License version 2.0 file)\n\n\n  AddChangeLog (adds a new CHANGELOG)\n\n\n  AddReadme (adds a project specific README)\n\n\n  AddScalaMavenGitIgnore (adds a .gitignore suitable for Scala Maven projects)\n\n\n  ClassRenamer (renames a Java class, replacing one literal pattern with another)\n\n\n  PackageMove (renames a Java package)\n\n\n  PomParameterizer (updates a Maven pom to a new group, artifact, version and description)\n\n\n  RemoveApacheSoftwareLicense20 (removes an Apache Software License version 2.0 file if present)\n\n\n  RemoveChangeLog (removes CHANGELOG file if present)\n\n\n  RemoveCodeOfConduct (removes CODE_OF_CONDUCT file if present)\n\n\n\n\u2192 Requires\n\n\n  [0.8.0,1.0.0)\n\n\n\nTo get more information on any of the Rugs listed above, run:\n\n\n  rug describe editor|generator|executor|reviewer ARTIFACT\n\n\n\n\n\nThat list of editors looks familiar, we must be doing something right!\nAgain, the last line of the output tells us how we can get more\ninformation.  Let\u2019s try it.\n\n\n$\n rug describe editor AddApacheSoftwareLicense20\n\n\nNo valid ARTIFACT provided, no default artifact defined and not in local mode.\n\n\n\nRun the following command for usage help:\n\n\n  rug describe --help.\n\n\n\n\n\nHmm, looks like something went wrong.  Fortunately the error tells us\nwe either need to define a default artifact or run in local mode.  How\ndo we run in local mode?  The above output tells us to run \nrug\ndescribe --help\n for usage help.  Let\u2019s do it.\n\n\n$\n rug describe --help\n\nUsage: rug describe [OPTION]... TYPE ARTIFACT\n\n\nPrint details about an archive or Rug.\n\n\n\nOptions:\n\n\n  -?,-h,--help          Print help information\n\n\n  -X,--error            Print verbose error messages\n\n\n  -o,--offline          Use only downloaded archives\n\n\n  -q,--quiet            Do not display progress messages\n\n\n  -r,--resolver-report  Print dependency tree\n\n\n  -s,--settings FILE    Use settings file FILE\n\n\n  -t,--timer            Print timing information\n\n\n  -u,--update           Update dependency resolution\n\n\n\nCommand Options:\n\n\n  -a,--archive-version AV  Use archive version AV\n\n\n  -l,--local               Use local working directory as archive\n\n\n\nTYPE should be 'editor', 'generator', 'executor', 'reviewer' or\n\n\n'archive' and ARTIFACT should be the full name of an artifact, e.g.,\n\n\n\"atomist:spring-service:Spring Microservice\".  If the name of the\n\n\nartifact has spaces in it, you need to put quotes around it.\n\n\n\nPlease report issues at https://github.com/atomist/rug-cli\n\n\n\n\n\nThe help output provides two pieces of information useful to us.\nFirst, it says the \nARTIFACT\n should be the full name of the artifact.\nWe only provided the editor name.  Perhaps we needed to prepend the\narchive name.  Second, the \n-l\n or \n--local\n command-line option tells\nthe CLI to use the current directory as an archive.  In other words,\nit tries to find an \n.atomist\n directory and use the Rugs in it.\nSince we are in a directory that has the \n.atomist\n directory with the\neditor we want to run, that seems promising.\n\n\n$\n rug describe -l editor AddApacheSoftwareLicense20\n\nResolving dependencies for atomist:rug-rugs:0.7.0 \u2190 local completed\n\n\nLoading atomist:rug-rugs:0.7.0 \u2190 local into runtime completed\n\n\n\nAddApacheSoftwareLicense20\n\n\natomist:rug-rugs:0.7.0\n\n\nadd the Apache Software License version 2.0 file\n\n\n\n\u2192 Tags\n\n\n  apache (apache)\n\n\n  license (license)\n\n\n  documentation (documentation)\n\n\n\u2192 Parameters\n\n\n  no parameters needed\n\n\n\nTo invoke the AddApacheSoftwareLicense20 editor, run:\n\n\n  rug edit \"atomist:rug-rugs:AddApacheSoftwareLicense20\" -a 0.7.0 -l\n\n\n\n\n\nSuccess!  The output from that command also tells us what the full\nname of the editor is,\n\natomist:rug-rugs:AddApacheSoftwareLicense20\n.  We could\nhave guessed that.  Since we previously installed the editor, we could\nhave run the following command and gotten the same result.\n\n\n$\n rug describe editor atomist:rug-rugs:AddApacheSoftwareLicense20\n\n\n\n\nThe \ndescribe editor\n output includes several pieces of useful\ninformation.  The description, \u201cadds the Apache Software License\nversion 2.0 file\u201d, provides a slightly more verbose description than\nthe already descriptive editor name.  We can see that this editor has\nthree tags, \nlicense\n, \napache\n, and \ndocumentation\n, and it takes no\nparameters.\n\n\nAdding the Apache license seems like a good thing to do.  The last\nline of the output once again gives us the information we need: how to\nrun this editor.  Let\u2019s try it.\n\n\nRun an Editor\n\u00b6\n\n\nWe will just run the command we were provided above.  We remove the\n\n-l\n since, having installed the archive, we do not need to run it\nfrom the local directory, we can run it from the installed archive.\n\n\n$\n rug edit atomist:rug-rugs:AddApacheSoftwareLicense20 -a \n0\n.7.0\n\nResolving dependencies for atomist:rug-rugs:latest completed\n\n\nLoading atomist:rug-rugs:0.7.0 into runtime completed\n\n\nRunning editor AddApacheSoftwareLicense20 of atomist:rug-rugs:0.7.0 completed\n\n\n\n\u2192 Project\n\n\n  ~/develop/atomist/rug-rugs/ (282kb in 302 files)\n\n\n\n\u2192 Changes\n\n\n  \u251c\u2500\u2500 LICENSE created 11kb\n\n\n  \u2514\u2500\u2500 .atomist.yml created 3kb\n\n\n\nSuccessfully edited project rug-rugs\n\n\n\n\n\nLooks like two files were edited in the local repository.\n\n\n$\n git status\n\nOn branch master\n\n\nYour branch is up-to-date with 'origin/master'.\n\n\nChanges not staged for commit:\n\n\n  (use \"git add <file>...\" to update what will be committed)\n\n\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\n\n    modified:   .atomist.yml\n\n\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\n\n\n\nHmm, git shows only one file has been modified.  Why?  Well, the\ncontents of the \nLICENSE\n file were set to be the Apache Software\nLicense, but that is what the contents already were.  Git is smart.\nWhat is that \natomist.yml\n file?\n\n\n$\n cat .atomist.yml\n\n---\n\n\nkind: \"operation\"\n\n\nclient: \"rug-cli 0.20.0\"\n\n\neditor:\n\n\n  name: \"atomist.rug-rugs.AddApacheSoftwareLicense20\"\n\n\n  group: \"atomist\"\n\n\n  artifact: \"rug-rugs\"\n\n\n  version: \"0.7.0\"\n\n\n  origin:\n\n\n    repo: \"atomist/rug-rugs.git\"\n\n\n    branch: \"master\"\n\n\n    sha: \"622ed10\"\n\n\n\n\n\nLooks like it is a record of what we have done, nice!\n\n\nI suppose we should have guessed the editor would act on the local\ndirectory, but we don\u2019t really want to edit the current project.\nLet\u2019s create another project to edit.  We run the same command as\nabove, except we\u2019ll remove the archive version command-line option.\nIf you do not provide the \n-a\n option, the CLI will use the latest\ninstalled version, 0.7.0 in our case.\n\n\n$\n \ncd\n ..\n\n$\n mkdir atomist-test\n\n$\n \ncd\n !$\n\n$\n git init\n\n$\n rug edit atomist:rug-rugs:AddApacheSoftwareLicense20\n\n$\n rug edit atomist:rug-rugs:AddApacheSoftwareLicense20\n\nResolving dependencies for atomist:rug-rugs:latest completed\n\n\nLoading atomist:rug-rugs:0.7.0 into runtime completed\n\n\nRunning editor AddApacheSoftwareLicense20 of atomist:rug-rugs:0.7.0 completed\n\n\n\n\u2192 Project\n\n\n  ~/develop/atomist/atomist-test/ (15 kb in 16 files)\n\n\n\n\u2192 Changes\n\n\n  \u251c\u2500\u2500 LICENSE created 11 kb\n\n\n  \u2514\u2500\u2500 .atomist.yml created 287 bytes\n\n\n\nSuccessfully edited project atomist-test\n\n\n$\n git status\n\nOn branch master\n\n\n\nInitial commit\n\n\n\nUntracked files:\n\n\n  (use \"git add <file>...\" to include in what will be committed)\n\n\n\n    .atomist.yml\n\n\n    LICENSE\n\n\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\n\n\n\n\nThat\u2019s more like it!  What if we decide we do not want the Apache\nSoftware License?  There\u2019s an editor for that!\n\n\n$\n rug edit atomist:rug-rugs:RemoveApacheSoftwareLicense20\n\nResolving dependencies for atomist:rug-rugs:latest completed\n\n\nLoading atomist:rug-rugs:0.7.0 into runtime completed\n\n\nRunning editor RemoveApacheSoftwareLicense20 of atomist:rug-rugs:0.7.0 completed\n\n\n\n\u2192 Project\n\n\n  ~/develop/atomist/atomist-test/ (26 kb in 15 files)\n\n\n\n\u2192 Changes\n\n\n  \u251c\u2500\u2500 LICENSE deleted 15 kb\n\n\n  \u2514\u2500\u2500 .atomist.yml created 577 bytes\n\n\n\nSuccessfully edited project atomist-test\n\n\n$\n git status\n\nOn branch master\n\n\n\nInitial commit\n\n\n\nUntracked files:\n\n\n  (use \"git add <file>...\" to include in what will be committed)\n\n\n\n    .atomist.yml\n\n\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\n\n\n\n\nWe see the \nLICENSE\n file is gone.  If we inspect the contents of the\n\n.atomist.yml\n file, we see a complete record of what Rug has done.\n\n\n$\n cat .atomist.yml\n\n---\n\n\nkind: \"operation\"\n\n\nclient: \"rug-cli 0.20.0\"\n\n\neditor:\n\n\n  name: \"atomist.rug-rugs.AddApacheSoftwareLicense20\"\n\n\n  group: \"atomist\"\n\n\n  artifact: \"rug-rugs\"\n\n\n  version: \"0.7.0\"\n\n\n  origin:\n\n\n    repo: \"atomist/rug-rugs.git\"\n\n\n    branch: \"master\"\n\n\n    sha: \"622ed10\"\n\n\n\n---\n\n\nkind: \"operation\"\n\n\nclient: \"rug-cli 0.20.0\"\n\n\neditor:\n\n\n  name: \"atomist.rug-rugs.RemoveApacheSoftwareLicense20\"\n\n\n  group: \"atomist\"\n\n\n  artifact: \"rug-rugs\"\n\n\n  version: \"0.7.0\"\n\n\n  origin:\n\n\n    repo: \"atomist/rug-rugs.git\"\n\n\n    branch: \"master\"\n\n\n    sha: \"622ed10\"",
            "title": "Developing Rugs"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/#additional-dependencies",
            "text": "Rugs are implemented in  TypeScript  and it is recommended you\ninstall  npm .  You should also get an  IDE/editor  with\ngood support for TypeScript language.",
            "title": "Additional Dependencies"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/#quick-cli-tour",
            "text": "",
            "title": "Quick CLI Tour"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/#get-some-rugs",
            "text": "To generate and edit code with Rug automation, you should become\nfamiliar with Rug editors, generators, and reviewers.  The best way to\ndo that is to look at some examples.  Some examples of Rug editors can\nbe found in the  rug-rugs  repo.  You can clone that repo with the\nfollowing command.  $  git clone https://github.com/atomist/rug-rugs.git $   cd  rug-rugs $  ls -1F CHANGELOG.md  CODE_OF_CONDUCT.md  LICENSE  README.md  src/   You cloned the repo, but where are the Rugs?  Rugs are always located\nin the  .atomist  directory at the top level of the project, i.e., the\nsame directory that has the  .git  directory.  $  ls -1F .atomist/ build/  editors/  package.json  target/  templates/  tests/   Here you can see the standard layout for a Rug directory.  It has a package.json  describing the contents of the project.  Think of this\nas the metadata for your Rugs, i.e., the name, version, dependencies,\netc.  The editors and generators are in the  editors  directory.  Any\ntemplates are in the  templates  directory.  Testing is integral to\nRug, so we also use a  tests  directory to hold all our tests.  There\nis also a  build  directory that contains the repository\u2019s CI scripts\nand configurations.  Let\u2019s see what editors we have available.  $  awk  '$1 == \"editor\" { print $2 }'  .atomist/editors/*.rug AddApacheSoftwareLicense20  AddChangeLog  AddReadme  AddScalaMavenGitIgnore  ClassRenamer  PackageMove  PomParameterizer  RemoveApacheSoftwareLicense20  RemoveChangeLog  RemoveCodeOfConduct   Feel free to look around in the  .atomist  directory to see what is\nthere, investigate the Rug syntax, and see what the tests look like.",
            "title": "Get some Rugs"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/#test-those-rugs",
            "text": "It is a best practice to provide tests for your Rugs.  The first Rug\ncommand we are going to try will run all of the tests available in the\nrug-rugs repo.  $  rug  test  Processing dependencies    Downloading com/atomist/rug/maven-metadata.xml \u2190 rug-types (0kb) succeeded    Downloading com/atomist/rug-cli-root/1.0.0/rug-cli-root-1.0.0.pom \u2190 rug-types (0kb) succeeded    Downloading com/atomist/rug/maven-metadata.xml \u2190 rug-types (2kb) succeeded    Downloading com/atomist/rug/0.8.0/rug-0.8.0.pom \u2190 rug-types (13kb) succeeded    ... (more downloads)    Downloading com/atomist/rug-cli-root/1.0.0/rug-cli-root-1.0.0.jar \u2190 rug-types (1kb) succeeded    Downloading org/scala-lang/scala-reflect/2.11.8/scala-reflect-2.11.8.jar \u2190 maven-central (4466kb) succeeded  Resolving dependencies for atomist:rug-rugs:0.7.0 \u2190 local completed  Loading atomist:rug-rugs:0.7.0 \u2190 local into runtime completed  Executing scenario AddApacheSoftwareLicense20 should add a new LICENSE file according to a provided template...    Testing assertion fileExists(SimpleLiteral(LICENSE))    Testing assertion fileContains(SimpleLiteral(LICENSE),SimpleLiteral(Version 2.0, January 2004))  Executing scenario AddChangeLog should add CHANGELOG.md...    Testing assertion fileExists(IdentifierFunctionArg(changelog,None))    Testing assertion fileContains(IdentifierFunctionArg(changelog,None),IdentifierFunctionArg(repo_slug,None))  Executing scenario AddChangeLog should overwrite CHANGELOG.md...    Testing assertion fileExists(IdentifierFunctionArg(changelog,None))    Testing assertion fileContains(IdentifierFunctionArg(changelog,None),IdentifierFunctionArg(repo_slug,None))    Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileContains(changelog, \"common-editor\") ))  Executing scenario AddChangeLog should reject invalid repo_slug...  Executing scenario AddChangeLog should reject missing parameter...  Executing scenario AddScalaMavenGitIgnore should add a new .gitignore file according to a provided template...    Testing assertion fileExists(SimpleLiteral(.gitignore))    Testing assertion fileContains(SimpleLiteral(.gitignore),SimpleLiteral(# Created by Atomist))  Executing scenario AddScalaMavenGitIgnore should overwrite an existing .gitignore file according to a provided template...    Testing assertion fileExists(SimpleLiteral(.gitignore))    Testing assertion fileContains(SimpleLiteral(.gitignore),SimpleLiteral(# Created by Atomist))  Executing scenario AddScalaMavenGitIgnore should add a new .gitignore to a subdirectory...    Testing assertion fileExists(SimpleLiteral(other/.gitignore))    Testing assertion fileContains(SimpleLiteral(other/.gitignore),SimpleLiteral(# Created by Atomist))  Executing scenario AddReadme should add README.md...    Testing assertion fileExists(IdentifierFunctionArg(readme,None))    Testing assertion fileContains(IdentifierFunctionArg(readme,None),IdentifierFunctionArg(newName,None))    Testing assertion fileContains(IdentifierFunctionArg(readme,None),IdentifierFunctionArg(newDescription,None))  Executing scenario AddReadme should reject invalid value name parameter...  Executing scenario AddReadme should reject missing parameter...  Executing scenario ClassRenamer should rename simple class...    Testing assertion EqualsExpression(fileCount(),SimpleLiteral(1))    Testing assertion fileContains(SimpleLiteral(src/main/java/Cat.java),SimpleLiteral(class Cat))  Executing scenario ClassRenamer should rename class and leave no references to old name...    Testing assertion fileExists(SimpleLiteral(src/main/java/com/atomist/springrest/WeirdAndWonderful.java))    Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.anyFileContains(\".java\", oldclass) ))  Executing scenario ClassRenamer should rename class but leave any additional characters on the class name...    Testing assertion fileExists(SimpleLiteral(src/main/java/com/atomist/springrest/WeirdAndWonderfulConfiguration.java))    Testing assertion fileExists(SimpleLiteral(src/main/java/com/atomist/springrest/WeirdAndWonderfulApplication.java))    Testing assertion fileExists(SimpleLiteral(src/test/java/com/atomist/springrest/WeirdAndWonderfulApplicationTests.java))    Testing assertion fileExists(SimpleLiteral(src/test/java/com/atomist/springrest/WeirdAndWonderfulOutOfContainerIntegrationTests.java))    Testing assertion fileExists(SimpleLiteral(src/test/java/com/atomist/springrest/WeirdAndWonderfulWebIntegrationTests.java))    Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.anyFileContains(\".java\", \"SpringRest\") ))  Executing scenario PackageMove should move base package and leave no references to old packages...    Testing assertion fileExists(SimpleLiteral(src/main/java/com/foo/bar/SpringRestConfiguration.java))    Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.anyFileContains(\".java\", oldpack) ))  Executing scenario PomParameterizer should establish a new project's valid pom.xml...    Testing assertion fileExists(SimpleLiteral(pom.xml))    Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<artifactId>mynewproject</artifactId>))    Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<groupId>mygroup</groupId>))    Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<version>0.0.1-SNAPSHOT</version>))    Testing assertion fileContains(SimpleLiteral(pom.xml),SimpleLiteral(<description>My project description</description>))  Executing scenario RemoveApacheSoftwareLicense20 should remove Apache license...    Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileExists(\"LICENSE\") ))  Executing scenario RemoveApacheSoftwareLicense20 should not remove other license...  Executing scenario RemoveChangeLog should remove CHANGELOG...    Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileExists(\"CHANGELOG.md\") ))  Executing scenario RemoveApacheSoftwareLicense20 silently do nothing if no CHANGELOG present...  Executing scenario RemoveCodeOfConduct should remove CODE_OF_CONDUCT...    Testing assertion ParsedJavaScriptFunction(JavaScriptBlock( !result.fileExists(\"CODE_OF_CONDUCT.md\") ))  Executing scenario RemoveCodeOfConduct silently do nothing if no CODE_OF_CONDUCT present...  Running test scenarios in atomist:rug-rugs:0.7.0 \u2190 local completed  Successfully executed 22 of 22 scenarios: Test SUCCESS   The above command will download all the dependencies needed to run the\neditors defined in the rug-rugs repo.  Depending on the speed of\nyour network connection, this may take some time.  Each dependency\nonly need be downloaded once, so subsequent executions of  rug  will\nbe faster.  As you can see from the last line of output, all of the test scenarios\npassed.  To run a specific named test:  $  rug  test   \"Whatever Test Secanrio\"   To run all scenarios from a single test file:  $  rug  test  MyRugTestFilename",
            "title": "Test those Rugs"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/#make-your-rugs-available",
            "text": "The next step is to create a Rug archive and install it locally so you\ncan use it on local projects.  This is accomplished with the  install \ncommand.  $  rug install Resolving dependencies for atomist:rug-rugs:0.7.0 \u2190 local completed  Loading atomist:rug-rugs:0.7.0 \u2190 local into runtime completed    Generated META-INF/maven/atomist/rug-rugs/pom.xml    Generated .atomist/metadata.json  Generating archive metadata completed    Installed atomist/rug-rugs/0.7.0/rug-rugs-0.7.0.zip \u2192 /Users/dd/.atomist/repository    Installed atomist/rug-rugs/0.7.0/rug-rugs-0.7.0.pom \u2192 /Users/dd/.atomist/repository    Installed atomist/rug-rugs/0.7.0/rug-rugs-0.7.0-metadata.json \u2192 /Users/dd/.atomist/repository  Installing archive into local repository completed  \u2192 Archive    ~/develop/atomist/rug-rugs/.atomist/target/rug-rugs-0.7.0.zip (39kb in 43 files)  \u2192 Contents    \u251c\u2500\u252c .atomist  ...  Successfully installed archive for atomist:rug-rugs:0.7.0   This command packages up all of the Rugs in the  .atomist  directory\nand installs them in your local repository, typically ~/.atomist/repository .",
            "title": "Make your Rugs Available"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/#list-the-installed-editors",
            "text": "Remember above when we ran that arcane  awk  command to list the\neditors?  There is a better way!  Now that we some editors installed\nlocally, we can list our local editors.  $  rug list Resolving dependencies for com.atomist:rug:0.8.0 completed  Listing local archives completed  \u2192 Local Archives    atomist:rug-rugs (0.7.0)  For more information on specific archive version, run:    rug describe archive ARCHIVE -a VERSION   Looks like the Rug Archive we installed is indeed installed.  That\nlast line of the output tells us how we can get more information.\nLet\u2019s try that command.  Since we only have one version available, we\ncan omit the  -a  command-line option.  When it is not provided, the\nlatest version is used.  $  rug describe archive atomist:rug-rugs Processing dependencies    Downloading atomist/rug-rugs/maven-metadata.xml \u2190 rugs (0kb) succeeded  Resolving dependencies for atomist:rug-rugs:latest completed  Loading atomist:rug-rugs:0.7.0 into runtime completed  atomist:rug-rugs:0.7.0  \u2192 Origin    atomist/rug-rugs.git#master (622ed10)  \u2192 Archive    ~/.atomist/repository/atomist/rug-rugs/0.7.0/rug-rugs-0.7.0.zip (39kb in 43 files)  \u2192 Editors    AddApacheSoftwareLicense20 (add the Apache Software License version 2.0 file)    AddChangeLog (adds a new CHANGELOG)    AddReadme (adds a project specific README)    AddScalaMavenGitIgnore (adds a .gitignore suitable for Scala Maven projects)    ClassRenamer (renames a Java class, replacing one literal pattern with another)    PackageMove (renames a Java package)    PomParameterizer (updates a Maven pom to a new group, artifact, version and description)    RemoveApacheSoftwareLicense20 (removes an Apache Software License version 2.0 file if present)    RemoveChangeLog (removes CHANGELOG file if present)    RemoveCodeOfConduct (removes CODE_OF_CONDUCT file if present)  \u2192 Requires    [0.8.0,1.0.0)  To get more information on any of the Rugs listed above, run:    rug describe editor|generator|executor|reviewer ARTIFACT   That list of editors looks familiar, we must be doing something right!\nAgain, the last line of the output tells us how we can get more\ninformation.  Let\u2019s try it.  $  rug describe editor AddApacheSoftwareLicense20 No valid ARTIFACT provided, no default artifact defined and not in local mode.  Run the following command for usage help:    rug describe --help.   Hmm, looks like something went wrong.  Fortunately the error tells us\nwe either need to define a default artifact or run in local mode.  How\ndo we run in local mode?  The above output tells us to run  rug\ndescribe --help  for usage help.  Let\u2019s do it.  $  rug describe --help Usage: rug describe [OPTION]... TYPE ARTIFACT  Print details about an archive or Rug.  Options:    -?,-h,--help          Print help information    -X,--error            Print verbose error messages    -o,--offline          Use only downloaded archives    -q,--quiet            Do not display progress messages    -r,--resolver-report  Print dependency tree    -s,--settings FILE    Use settings file FILE    -t,--timer            Print timing information    -u,--update           Update dependency resolution  Command Options:    -a,--archive-version AV  Use archive version AV    -l,--local               Use local working directory as archive  TYPE should be 'editor', 'generator', 'executor', 'reviewer' or  'archive' and ARTIFACT should be the full name of an artifact, e.g.,  \"atomist:spring-service:Spring Microservice\".  If the name of the  artifact has spaces in it, you need to put quotes around it.  Please report issues at https://github.com/atomist/rug-cli   The help output provides two pieces of information useful to us.\nFirst, it says the  ARTIFACT  should be the full name of the artifact.\nWe only provided the editor name.  Perhaps we needed to prepend the\narchive name.  Second, the  -l  or  --local  command-line option tells\nthe CLI to use the current directory as an archive.  In other words,\nit tries to find an  .atomist  directory and use the Rugs in it.\nSince we are in a directory that has the  .atomist  directory with the\neditor we want to run, that seems promising.  $  rug describe -l editor AddApacheSoftwareLicense20 Resolving dependencies for atomist:rug-rugs:0.7.0 \u2190 local completed  Loading atomist:rug-rugs:0.7.0 \u2190 local into runtime completed  AddApacheSoftwareLicense20  atomist:rug-rugs:0.7.0  add the Apache Software License version 2.0 file  \u2192 Tags    apache (apache)    license (license)    documentation (documentation)  \u2192 Parameters    no parameters needed  To invoke the AddApacheSoftwareLicense20 editor, run:    rug edit \"atomist:rug-rugs:AddApacheSoftwareLicense20\" -a 0.7.0 -l   Success!  The output from that command also tells us what the full\nname of the editor is, atomist:rug-rugs:AddApacheSoftwareLicense20 .  We could\nhave guessed that.  Since we previously installed the editor, we could\nhave run the following command and gotten the same result.  $  rug describe editor atomist:rug-rugs:AddApacheSoftwareLicense20  The  describe editor  output includes several pieces of useful\ninformation.  The description, \u201cadds the Apache Software License\nversion 2.0 file\u201d, provides a slightly more verbose description than\nthe already descriptive editor name.  We can see that this editor has\nthree tags,  license ,  apache , and  documentation , and it takes no\nparameters.  Adding the Apache license seems like a good thing to do.  The last\nline of the output once again gives us the information we need: how to\nrun this editor.  Let\u2019s try it.",
            "title": "List the installed Editors"
        },
        {
            "location": "/user-guide/interfaces/cli/developing-rugs/#run-an-editor",
            "text": "We will just run the command we were provided above.  We remove the -l  since, having installed the archive, we do not need to run it\nfrom the local directory, we can run it from the installed archive.  $  rug edit atomist:rug-rugs:AddApacheSoftwareLicense20 -a  0 .7.0 Resolving dependencies for atomist:rug-rugs:latest completed  Loading atomist:rug-rugs:0.7.0 into runtime completed  Running editor AddApacheSoftwareLicense20 of atomist:rug-rugs:0.7.0 completed  \u2192 Project    ~/develop/atomist/rug-rugs/ (282kb in 302 files)  \u2192 Changes    \u251c\u2500\u2500 LICENSE created 11kb    \u2514\u2500\u2500 .atomist.yml created 3kb  Successfully edited project rug-rugs   Looks like two files were edited in the local repository.  $  git status On branch master  Your branch is up-to-date with 'origin/master'.  Changes not staged for commit:    (use \"git add <file>...\" to update what will be committed)    (use \"git checkout -- <file>...\" to discard changes in working directory)      modified:   .atomist.yml  no changes added to commit (use \"git add\" and/or \"git commit -a\")   Hmm, git shows only one file has been modified.  Why?  Well, the\ncontents of the  LICENSE  file were set to be the Apache Software\nLicense, but that is what the contents already were.  Git is smart.\nWhat is that  atomist.yml  file?  $  cat .atomist.yml ---  kind: \"operation\"  client: \"rug-cli 0.20.0\"  editor:    name: \"atomist.rug-rugs.AddApacheSoftwareLicense20\"    group: \"atomist\"    artifact: \"rug-rugs\"    version: \"0.7.0\"    origin:      repo: \"atomist/rug-rugs.git\"      branch: \"master\"      sha: \"622ed10\"   Looks like it is a record of what we have done, nice!  I suppose we should have guessed the editor would act on the local\ndirectory, but we don\u2019t really want to edit the current project.\nLet\u2019s create another project to edit.  We run the same command as\nabove, except we\u2019ll remove the archive version command-line option.\nIf you do not provide the  -a  option, the CLI will use the latest\ninstalled version, 0.7.0 in our case.  $   cd  .. $  mkdir atomist-test $   cd  !$ $  git init $  rug edit atomist:rug-rugs:AddApacheSoftwareLicense20 $  rug edit atomist:rug-rugs:AddApacheSoftwareLicense20 Resolving dependencies for atomist:rug-rugs:latest completed  Loading atomist:rug-rugs:0.7.0 into runtime completed  Running editor AddApacheSoftwareLicense20 of atomist:rug-rugs:0.7.0 completed  \u2192 Project    ~/develop/atomist/atomist-test/ (15 kb in 16 files)  \u2192 Changes    \u251c\u2500\u2500 LICENSE created 11 kb    \u2514\u2500\u2500 .atomist.yml created 287 bytes  Successfully edited project atomist-test  $  git status On branch master  Initial commit  Untracked files:    (use \"git add <file>...\" to include in what will be committed)      .atomist.yml      LICENSE  nothing added to commit but untracked files present (use \"git add\" to track)   That\u2019s more like it!  What if we decide we do not want the Apache\nSoftware License?  There\u2019s an editor for that!  $  rug edit atomist:rug-rugs:RemoveApacheSoftwareLicense20 Resolving dependencies for atomist:rug-rugs:latest completed  Loading atomist:rug-rugs:0.7.0 into runtime completed  Running editor RemoveApacheSoftwareLicense20 of atomist:rug-rugs:0.7.0 completed  \u2192 Project    ~/develop/atomist/atomist-test/ (26 kb in 15 files)  \u2192 Changes    \u251c\u2500\u2500 LICENSE deleted 15 kb    \u2514\u2500\u2500 .atomist.yml created 577 bytes  Successfully edited project atomist-test  $  git status On branch master  Initial commit  Untracked files:    (use \"git add <file>...\" to include in what will be committed)      .atomist.yml  nothing added to commit but untracked files present (use \"git add\" to track)   We see the  LICENSE  file is gone.  If we inspect the contents of the .atomist.yml  file, we see a complete record of what Rug has done.  $  cat .atomist.yml ---  kind: \"operation\"  client: \"rug-cli 0.20.0\"  editor:    name: \"atomist.rug-rugs.AddApacheSoftwareLicense20\"    group: \"atomist\"    artifact: \"rug-rugs\"    version: \"0.7.0\"    origin:      repo: \"atomist/rug-rugs.git\"      branch: \"master\"      sha: \"622ed10\"  ---  kind: \"operation\"  client: \"rug-cli 0.20.0\"  editor:    name: \"atomist.rug-rugs.RemoveApacheSoftwareLicense20\"    group: \"atomist\"    artifact: \"rug-rugs\"    version: \"0.7.0\"    origin:      repo: \"atomist/rug-rugs.git\"      branch: \"master\"      sha: \"622ed10\"",
            "title": "Run an Editor"
        },
        {
            "location": "/user-guide/fingerprints/",
            "text": "Fingerprints detect important changes to code and configuration. They ensure that critical, potentially breaking changes don\u2019t slip by unnoticed and cause outages or other problems.\n\n\nFingerprints are calculated by extracting specific, logically related fragments of code, normalizing and sorting them in a deterministic order, and then computing a SHA. Fingerprints are computed on the difference or impact between the commit and its parent commit. The fingerprints are calculated on each commit. If a change from previous version is detected, Atomist alerts you in Slack and in some cases sets the GitHub build status to blocked.\n\n\nAvailable Fingerprints\n\u00b6\n\n\nAtomist offers the fingerprints listed in the table below.\n\n\n\n\n\n\n\n\nEntry\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuild\n\n\nBuild file (Travis and CircleCI)\n\n\n\n\n\n\ndocker\n\n\nDockerfile base image\n\n\n\n\n\n\nprops\n\n\nApplication property and YAML files used by Spring Boot\n\n\n\n\n\n\nrest\n\n\nSpring MVC REST endpoints\n\n\n\n\n\n\nplugins\n\n\nMaven plugins\n\n\n\n\n\n\nplugsMgt\n\n\nMaven plugin management\n\n\n\n\n\n\ndeps\n\n\nMaven dependencies\n\n\n\n\n\n\ndepsMgt\n\n\nMaven dependency management\n\n\n\n\n\n\n\n\nAppearance\n\u00b6\n\n\nBelow is an example fingerprint rendering in Slack. It shows that both the build configuration and the configured plugins changed. Notice that the fingerprint has done its job here: the fingerprint detected a change to the build file that the commit message neglected to mention.\n\n\n\n\nConfiguration\n\u00b6\n\n\nThe fingerprint configuration file is located in the atomist-config repo:\n\n\nhttps://<your-repo>/atomist-config/blob/master/fingerprints.json",
            "title": "Fingerprints"
        },
        {
            "location": "/user-guide/fingerprints/#available-fingerprints",
            "text": "Atomist offers the fingerprints listed in the table below.     Entry  Description      build  Build file (Travis and CircleCI)    docker  Dockerfile base image    props  Application property and YAML files used by Spring Boot    rest  Spring MVC REST endpoints    plugins  Maven plugins    plugsMgt  Maven plugin management    deps  Maven dependencies    depsMgt  Maven dependency management",
            "title": "Available Fingerprints"
        },
        {
            "location": "/user-guide/fingerprints/#appearance",
            "text": "Below is an example fingerprint rendering in Slack. It shows that both the build configuration and the configured plugins changed. Notice that the fingerprint has done its job here: the fingerprint detected a change to the build file that the commit message neglected to mention.",
            "title": "Appearance"
        },
        {
            "location": "/user-guide/fingerprints/#configuration",
            "text": "The fingerprint configuration file is located in the atomist-config repo:  https://<your-repo>/atomist-config/blob/master/fingerprints.json",
            "title": "Configuration"
        },
        {
            "location": "/user-guide/seeds/",
            "text": "Seeds are a special type of Atomist project that is used to generate other projects. Changes you make to the seed\u2019s GitHub repo will be reflected in new projects that you generate using the seed.\n\n\nGetting Started\n\u00b6\n\n\nBefore you can use seeds, you or someone in your team needs to create at least one. To check for seeds, run \n@atomist generators seed\n in any channel where the bot is present or dm the bot. \n\n\nIf no seeds are available, you can create one by running \n@atomist create seed\n. \n\n\nUsing Seeds\n\u00b6\n\n\nOnce your seed is created, customize it using your preferred tools and check into GitHub as usual.  When you have the master branch how you want it, generate a new project by running \n@atomist create project\n. \n\n\nThe specific setup steps vary as determined by the seed project, so follow the bot prompts. When setup is complete, the bot links you to the newly created repo and Slack channel.\n\n\nAvailable Seeds\n\u00b6\n\n\nAtomist offers the seeds in the table below. You can also create your own. An organization can have more than one seed project, for example, to support multiple different basic service types. \n\n\n\n\n\n\n\n\nEntry\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nspring-rest-seed\n\n\nSpring MVC REST Service\n\n\n\n\n\n\n\n\nTo see all available seeds in your organization, run \n@atomist generators seed\n. \n\n\nNaming\n\u00b6\n\n\nSeed names must end in \u201c-seed\u201d.",
            "title": "Seeds"
        },
        {
            "location": "/user-guide/seeds/#getting-started",
            "text": "Before you can use seeds, you or someone in your team needs to create at least one. To check for seeds, run  @atomist generators seed  in any channel where the bot is present or dm the bot.   If no seeds are available, you can create one by running  @atomist create seed .",
            "title": "Getting Started"
        },
        {
            "location": "/user-guide/seeds/#using-seeds",
            "text": "Once your seed is created, customize it using your preferred tools and check into GitHub as usual.  When you have the master branch how you want it, generate a new project by running  @atomist create project .   The specific setup steps vary as determined by the seed project, so follow the bot prompts. When setup is complete, the bot links you to the newly created repo and Slack channel.",
            "title": "Using Seeds"
        },
        {
            "location": "/user-guide/seeds/#available-seeds",
            "text": "Atomist offers the seeds in the table below. You can also create your own. An organization can have more than one seed project, for example, to support multiple different basic service types.      Entry  Description      spring-rest-seed  Spring MVC REST Service     To see all available seeds in your organization, run  @atomist generators seed .",
            "title": "Available Seeds"
        },
        {
            "location": "/user-guide/seeds/#naming",
            "text": "Seed names must end in \u201c-seed\u201d.",
            "title": "Naming"
        },
        {
            "location": "/user-guide/spring-agent/",
            "text": "The Atomist Spring Agent sends runtime notifications to Atomist about your \nSpring Boot\n application instances so that you can see this information in Slack.\n\n\n\n\nPrerequisites\n\u00b6\n\n\nTo use the Atomist Spring Agent you need to:\n\n\n\n\nAuthorize the Atomist Bot on Slack and GitHub as described in \ngetting-started\n.\n\n\nBe working on a Maven-based Spring Boot application.\n\n\n\n\nAdding the Spring Agent\n\u00b6\n\n\nYou can install the agent in a project either using the Atomist bot (recommended) or manually.\n\n\nAdding the Spring Agent using the Bot\n\u00b6\n\n\nStart in a Slack channel that\u2019s linked to the GitHub repository you want to add the agent to. You can check the association between Slack channel and GitHub repo by running the \n@atomist repos\n command.\n\n\nIn that channel, ask Atomist to add the agent:\n\n\n@atomist add spring agent\n\n\n\n\nThis results in the bot creating a branch and PR on your repository that contains changes to the \npom.xml\n and the \napplication.yml\n.\n\n\nIf configured, a build of the branch is triggered with appropriate checks. When the checks complete, the bot prompts you to merge this branch into your project\u2019s \nmaster\n branch. Be sure to merge the changes to complete installation.\n\n\n\n\nWhen you first enable the agent, Atomist adds the \nspring-boot-agent\n dependency to your project\u2019s \npom.xml\n:\n\n\n<dependency>\n\n    \n<groupId>\ncom.atomist\n</groupId>\n\n    \n<artifactId>\nspring-boot-agent\n</artifactId>\n\n    \n<version>\n0.1.2\n</version>\n\n\n</dependency>\n\n\n\n\n\nIf not already present, the \npublic-atomist-release\n repository is added to the \nrepositories\n block in your \npom.xml\n so that the \nspring-boot-agent\n dependency can be resolved:\n\n\n<repositories>\n\n    \n<repository>\n\n        \n<id>\npublic-atomist-release\n</id>\n\n        \n<name>\nAtomist Release\n</name>\n\n        \n<url>\nhttps://atomist.jfrog.io/atomist/libs-release\n</url>\n\n        \n<snapshots>\n\n            \n<enabled>\nfalse\n</enabled>\n\n        \n</snapshots>\n\n    \n</repository>\n\n\n</repositories>\n\n\n\n\n\nFinally Atomist adds a few properties to your project\u2019s \nsrc/main/resources/application.yml\n file that identify and describe the application  when runtime information is sent to your project\u2019s Slack channel:\n\n\natomist:\n  enabled: true\n  debug: true\n  url: 'https://webhook.atomist.com/atomist/application/teams/T5P5H18V9'\n  environment:\n    domain: '${DOMAIN:development}'\n    pod: '${HOSTNAME:${random.value}}'\n\n\n\n\nYou can customise these properties using the usual [Spring Boot mechanisms][spring-boot-props].\n\n\nAdding the Spring Agent Manually\n\u00b6\n\n\nIf you prefer, you can add the agent to your application manually. \n\n\nAdd the following to your \npom.xml\n:\n\n\n<dependency>\n\n    \n<groupId>\ncom.atomist\n</groupId>\n\n    \n<artifactId>\nspring-boot-agent\n</artifactId>\n\n    \n<version>\n0.1.2\n</version>\n\n\n</dependency>\n\n\n\n\n\nBecause the agent is not available from Maven Central you must add the following Maven repository:\n\n\n<repositories>\n\n    \n<repository>\n\n        \n<id>\npublic-atomist-release\n</id>\n\n        \n<name>\nAtomist Release\n</name>\n\n        \n<url>\nhttps://atomist.jfrog.io/atomist/libs-release\n</url>\n\n        \n<snapshots>\n\n            \n<enabled>\nfalse\n</enabled>\n\n        \n</snapshots>\n\n    \n</repository>\n\n\n</repositories>\n\n\n\n\n\nFinally add the following default properties to configure the agent:\n\n\natomist:\n  enabled: true\n  debug: true\n  url: 'https://webhook.atomist.com/atomist/application/teams/T5P5H18V9'\n  environment:\n    domain: '${DOMAIN:development}'\n    pod: '${HOSTNAME:${random.value}}'\n\n\n\n\nConfiguring the Spring Agent\n\u00b6\n\n\nThe agent can be configured from the Spring Boot \napplication.yml\n or \n\napplication.properties\n using the following settings:\n\n\natomist:\n\n  # enable or disable the agent\n  enabled: true\n\n  # enable trace output; this allows you to review the event messages the agent sends\n  debug: true\n\n  # configure the endpoint; {id} should be replaced by your Slack team id\n  url: 'https://webhook.atomist.com/atomist/application/teams/T5P5H18V9' \n\n  environment: \n\n    # use the following keys to send some information about your environment to Atomist\n    domain: '${DOMAIN:development}'\n    pod: '${HOSTNAME:${random.value}}'\n\n\n\n\nTesting the Spring Agent\n\u00b6\n\n\nOnce you have merged the new branch into your project\u2019s \nmaster\n you can clone the project locally to test the agent by running the application locally using the standard \nSpring Boot Maven Plugin support\n:\n\n\n> mvn spring-boot:run\n\n\n\n\nIf everything is configured correctly you will see application instance lifecycle messages for your Spring Boot application in your project\u2019s Slack channel:\n\n\n\n\nWhat information is shared by the Spring Agent?\n\u00b6\n\n\nOnce the agent is installed and the application is running, the information that the agent sends Atomist appears in your applications \nDEBUG\n logging:\n\n\n09:46:11.317 [eventTaskExecutor-1] DEBUG c.a.s.a.AgentEventSender - Atomist event about to be sent:\n{\n  \"git\" : {\n    \"sha\" : \"1818b54e396979fb422f24ede1d3373415a4282e\",\n    \"branch\" : \"master\",\n    \"url\" : \"git@github.com:democritus-team/demo1.git\"\n  },\n  \"pod\" : \"36a2d083d2eb9c5c16e66a79a3bb5ed1\",\n  \"domain\" : \"development\",\n  \"host\" : \"Bertrand.local\",\n  \"id\" : \"application:8080-46799-Bertrand.local\",\n  \"state\" : \"started\",\n  \"ts\" : 1499935571272\n}\n\n\n\n\nRemoving the Spring Agent\n\u00b6\n\n\nRemove the agent from your project at any time by deleting the \nspring-boot-agent\n dependency from your project\u2019s \npom.xml\n and deleting the \natomist\n properties from your \nsrc/main/resources/application.yml\n file.",
            "title": "Spring Agent"
        },
        {
            "location": "/user-guide/spring-agent/#prerequisites",
            "text": "To use the Atomist Spring Agent you need to:   Authorize the Atomist Bot on Slack and GitHub as described in  getting-started .  Be working on a Maven-based Spring Boot application.",
            "title": "Prerequisites"
        },
        {
            "location": "/user-guide/spring-agent/#adding-the-spring-agent",
            "text": "You can install the agent in a project either using the Atomist bot (recommended) or manually.",
            "title": "Adding the Spring Agent"
        },
        {
            "location": "/user-guide/spring-agent/#adding-the-spring-agent-using-the-bot",
            "text": "Start in a Slack channel that\u2019s linked to the GitHub repository you want to add the agent to. You can check the association between Slack channel and GitHub repo by running the  @atomist repos  command.  In that channel, ask Atomist to add the agent:  @atomist add spring agent  This results in the bot creating a branch and PR on your repository that contains changes to the  pom.xml  and the  application.yml .  If configured, a build of the branch is triggered with appropriate checks. When the checks complete, the bot prompts you to merge this branch into your project\u2019s  master  branch. Be sure to merge the changes to complete installation.   When you first enable the agent, Atomist adds the  spring-boot-agent  dependency to your project\u2019s  pom.xml :  <dependency> \n     <groupId> com.atomist </groupId> \n     <artifactId> spring-boot-agent </artifactId> \n     <version> 0.1.2 </version>  </dependency>   If not already present, the  public-atomist-release  repository is added to the  repositories  block in your  pom.xml  so that the  spring-boot-agent  dependency can be resolved:  <repositories> \n     <repository> \n         <id> public-atomist-release </id> \n         <name> Atomist Release </name> \n         <url> https://atomist.jfrog.io/atomist/libs-release </url> \n         <snapshots> \n             <enabled> false </enabled> \n         </snapshots> \n     </repository>  </repositories>   Finally Atomist adds a few properties to your project\u2019s  src/main/resources/application.yml  file that identify and describe the application  when runtime information is sent to your project\u2019s Slack channel:  atomist:\n  enabled: true\n  debug: true\n  url: 'https://webhook.atomist.com/atomist/application/teams/T5P5H18V9'\n  environment:\n    domain: '${DOMAIN:development}'\n    pod: '${HOSTNAME:${random.value}}'  You can customise these properties using the usual [Spring Boot mechanisms][spring-boot-props].",
            "title": "Adding the Spring Agent using the Bot"
        },
        {
            "location": "/user-guide/spring-agent/#adding-the-spring-agent-manually",
            "text": "If you prefer, you can add the agent to your application manually.   Add the following to your  pom.xml :  <dependency> \n     <groupId> com.atomist </groupId> \n     <artifactId> spring-boot-agent </artifactId> \n     <version> 0.1.2 </version>  </dependency>   Because the agent is not available from Maven Central you must add the following Maven repository:  <repositories> \n     <repository> \n         <id> public-atomist-release </id> \n         <name> Atomist Release </name> \n         <url> https://atomist.jfrog.io/atomist/libs-release </url> \n         <snapshots> \n             <enabled> false </enabled> \n         </snapshots> \n     </repository>  </repositories>   Finally add the following default properties to configure the agent:  atomist:\n  enabled: true\n  debug: true\n  url: 'https://webhook.atomist.com/atomist/application/teams/T5P5H18V9'\n  environment:\n    domain: '${DOMAIN:development}'\n    pod: '${HOSTNAME:${random.value}}'",
            "title": "Adding the Spring Agent Manually"
        },
        {
            "location": "/user-guide/spring-agent/#configuring-the-spring-agent",
            "text": "The agent can be configured from the Spring Boot  application.yml  or  application.properties  using the following settings:  atomist:\n\n  # enable or disable the agent\n  enabled: true\n\n  # enable trace output; this allows you to review the event messages the agent sends\n  debug: true\n\n  # configure the endpoint; {id} should be replaced by your Slack team id\n  url: 'https://webhook.atomist.com/atomist/application/teams/T5P5H18V9' \n\n  environment: \n\n    # use the following keys to send some information about your environment to Atomist\n    domain: '${DOMAIN:development}'\n    pod: '${HOSTNAME:${random.value}}'",
            "title": "Configuring the Spring Agent"
        },
        {
            "location": "/user-guide/spring-agent/#testing-the-spring-agent",
            "text": "Once you have merged the new branch into your project\u2019s  master  you can clone the project locally to test the agent by running the application locally using the standard  Spring Boot Maven Plugin support :  > mvn spring-boot:run  If everything is configured correctly you will see application instance lifecycle messages for your Spring Boot application in your project\u2019s Slack channel:",
            "title": "Testing the Spring Agent"
        },
        {
            "location": "/user-guide/spring-agent/#what-information-is-shared-by-the-spring-agent",
            "text": "Once the agent is installed and the application is running, the information that the agent sends Atomist appears in your applications  DEBUG  logging:  09:46:11.317 [eventTaskExecutor-1] DEBUG c.a.s.a.AgentEventSender - Atomist event about to be sent:\n{\n  \"git\" : {\n    \"sha\" : \"1818b54e396979fb422f24ede1d3373415a4282e\",\n    \"branch\" : \"master\",\n    \"url\" : \"git@github.com:democritus-team/demo1.git\"\n  },\n  \"pod\" : \"36a2d083d2eb9c5c16e66a79a3bb5ed1\",\n  \"domain\" : \"development\",\n  \"host\" : \"Bertrand.local\",\n  \"id\" : \"application:8080-46799-Bertrand.local\",\n  \"state\" : \"started\",\n  \"ts\" : 1499935571272\n}",
            "title": "What information is shared by the Spring Agent?"
        },
        {
            "location": "/user-guide/spring-agent/#removing-the-spring-agent",
            "text": "Remove the agent from your project at any time by deleting the  spring-boot-agent  dependency from your project\u2019s  pom.xml  and deleting the  atomist  properties from your  src/main/resources/application.yml  file.",
            "title": "Removing the Spring Agent"
        },
        {
            "location": "/user-guide/permissions/",
            "text": "Atomist integrates with and automates activities over various tools\nand services in your development tool chain.  To do so, certain\npermissions are needed.  Atomist only asks for permissions required to\naccomplish its work.\n\n\nPlease see the individual sections for specifics on the permissions\nrequested by Atomist.\n\n\n\n\nSlack OAuth Scopes\n\n\nGitHub OAuth Scopes\n\n\n\n\nIf you still have questions about permissions, please contact us in\nour \nAtomist Community slack team\n or email\nus at \nsupport@atomist.com\n.",
            "title": "Overview"
        },
        {
            "location": "/user-guide/permissions/slack/",
            "text": "Atomist acts as a bot in your Slack team, and can take these actions:\n\n\n\n\nListen for messages and commands directed at the bot\n\n\nSend notifications in channels that the bot has been invited to\n\n\nSend notifications via direct message\n\n\n\n\nWhen you authorize the Atomist Slack app, it requests the following\npermissions.  For the bot to operate properly, all of these scopes\nmust be granted.\n\n\n\n\n\n\n\n\nSlack Scope\n\n\nHow Atomist Uses It\n\n\n\n\n\n\n\n\n\n\nbot\n\n\nEnables the bot to hear and respond to channel activity, such as bot commands and events.\n\n\n\n\n\n\nidentify\n\n\nUsed to confirm your identity and test the authentication.\n\n\n\n\n\n\nchannels:read\n\n\nAllows the bot to list channels in the team.\n\n\n\n\n\n\nchannels:write\n\n\nEnables the bot to create channels and write messages to channels.  For example, when you create a new project with Atomist, the bot can create a channel that will be associated with the project\u2019s repository.\n\n\n\n\n\n\nim:read\n\n\nAllows the bot to list its direct message channels.  Sometimes Atomist communicates with users via direct message.\n\n\n\n\n\n\nim:write\n\n\nSend direct messages to other users in the Slack team.\n\n\n\n\n\n\nteam:read\n\n\nLets Atomist know basic information about the Slack team, like its ID, name, and domain.\n\n\n\n\n\n\n\n\nFor more information, see the \nSlack bot users\n documentation.",
            "title": "Slack Scopes"
        },
        {
            "location": "/user-guide/permissions/github/",
            "text": "Atomist automates activities like project creation and code changes\nthat operate on code in GitHub repositories.  Atomist also makes it\neasy to get relevant, actionable notifications of GitHub activity like\nnew commits or issues. To enable this, the Atomist GitHub integration\nrequests the following permissions:\n\n\n\n\n\n\n\n\nGitHub Scope\n\n\nHow Atomist Uses It\n\n\n\n\n\n\n\n\n\n\nrepo\n\n\nEnables Atomist to read and write code in your repositories, and get activity notifications for commits.\n\n\n\n\n\n\nread:org\n\n\nRead information about the GitHub organization, like teams and members of the organization.\n\n\n\n\n\n\nadmin:repo_hook\n\n\nAllows Atomist to configure a webhook on a single repository and start receiving activity alerts.\n\n\n\n\n\n\nadmin:org_hook\n\n\nAllows Atomist to configure an organization webhook so it may receive activity alerts for all repositories in an organization.\n\n\n\n\n\n\n\n\nFor more information, see \nGitHub OAuth Scopes\n documentation.",
            "title": "GitHub Scopes"
        },
        {
            "location": "/reference/",
            "text": "The Atomist Reference Documentation contains detailed information on\nvarious aspects of the Atomist development system.  This is the home\nof auto-generated Atomist documentation.\n\n\n\n\nRug Reference Documentation\n\n\nRug CLI Reference Documentation",
            "title": "Overview"
        },
        {
            "location": "/reference/rug/",
            "text": "The Rug Reference Documentation provides detailed information on Rug,\nthe various types of Rugs, Rug extensions, and Rug internals.\n\n\nRugs\n\u00b6\n\n\n\n\n\nWhen writing Rugs, several other concepts and features of Rug will be\nuseful.\n\n\n\n\nExtensions\n: Interfaces for languages and services\n\n\nPath Expressions\n: Select specific events and elements of projects, files, and code\n\n\n\n\n\n\n\n\n\n\n\nRug\n\u00b6\n\n\nIf you are interested in extending the capabilities of Rug runtime,\nthe following topics may be of interest.\n\n\n\n\nRug API documentation\n\n\nExtensions",
            "title": "Overview"
        },
        {
            "location": "/reference/rug/#rugs",
            "text": "When writing Rugs, several other concepts and features of Rug will be\nuseful.   Extensions : Interfaces for languages and services  Path Expressions : Select specific events and elements of projects, files, and code",
            "title": "Rugs"
        },
        {
            "location": "/reference/rug/#rug",
            "text": "If you are interested in extending the capabilities of Rug runtime,\nthe following topics may be of interest.   Rug API documentation  Extensions",
            "title": "Rug"
        },
        {
            "location": "/reference/rug/extensions/",
            "text": "Rug extensions represent different types of source code, events, and\nsystems which Rug can understand and interact with.  Each Rug\nextension defines a set of operations you can use to get and\nmodify the system or language it represents.\n\n\nRug ships with a number of extensions for basic concepts around\nprojects, file systems, and common languages, making it \nmuch\n simpler\nto begin writing your Rugs.  More information on the various\nextensions that ship with Rug and the methods they make available can\nbe found in the extension reference documentation\nfor \nprojects\n and \nhandlers\n.  Here\nare some of extensions that ship with Rug that are useful when working\nwith projects:\n\n\nYou can also write your own Rug extensions.",
            "title": "Extensions"
        },
        {
            "location": "/reference/rug/path-expressions/",
            "text": "Rug Path Expression Version 0.1\n\u00b6\n\n\n\n\nNot all of the specification below is implemented.  In particular,\nexecution of functions is not fully implemented.\n\n\n\n\nIntroduction\n\u00b6\n\n\nRug Path Expressions are used to obtain tree nodes from structured\ndata, including:\n\n\n\n\nProjects\n\n\nFiles (going into AST or other internal structure if understood)\n\n\nStructured parameters, such as JSON or other file formats\n\n\nThe Atomist service model representing project data such as\n    builds, commits and chat teams\n\n\nExisting trees\n\n\n\n\nAll data sources are viewed as trees, and results are always tree\nnodes.  All tree nodes have a \nnode type\n, \nname\n, and \nobject type\n.\nUnlike XML elements, tree nodes also may have methods.  Rug tree\nexpressions add a rich set of \nobject types\n from the underlying typed\nmodel they traverse.  Types that are globally searchable\nuse \nUpperCamelCase\n.  Private types, i.e., those only accessible\nunder a global type, use \nlowerCamelCase\n.\n\n\nThe syntax is inspired by sources including \nXPath 1.0\n (the\nprimary influence) and \nJSONPath\n (which shows how the same\ncore ideas can be applied to non XML data structures).\n\n\nA path expression navigates a series of nodes and relationships in a\ngraph.  Each path element in a path element acts on results returned\nby the previous path element.  Think of it as a \u201c\nflatMap\n\u201d\noperation on a collection in a functional language: it returns a new\ncollection.\n\n\nBeause of the close relationship to XPath, the remainder of this\ndocument mirrors the organization of\nthe \nXPath Version 1.0 specification\n.\nAn \nANTLR grammar\n for XPath 1.0 is available.\n\n\nLocation Paths\n\u00b6\n\n\nRug Path Expressions are location paths consisting of one or more\nsequential \nLocation Steps\n.  A location path is one or\nmore \nlocation steps\n separated by forward slashes,\n(\n/\n).\n\n\nAll location paths should be absolute, i.e., begin with a forward\nslash (\n/\n).  The actual root context for location paths\ndiffers depending on where the path location is being used:\n\n\n\n\n\n\n\n\nRug\n\n\nRoot Context\n\n\nContext Object Type\n\n\n\n\n\n\n\n\n\n\nEditor/Reviewer\n\n\nProject\n\n\nFile\n\n\n\n\n\n\nExecutor\n\n\nService\n\n\nService\n\n\n\n\n\n\nHandler\n\n\nobject passed to Handler\n\n\nobject passed to handler type\n\n\n\n\n\n\n\n\nThis is analogous to the root context of an XPath location path being\nthe root of the document it is acting on.\n\n\nThe context object type is the implicit object type that the initial\nlocation step has.  For example, in an Editor the root context is a\nProject and the context object type of the path step under the root\ncontext is File, allowing one to traverse the project\u2019s file system\nhierarchy from the project root using directory and file names as in\n\n/src/main/java\n or \n/LICENSE\n.\n\n\nLocation Steps\n\u00b6\n\n\nA location step has three parts:\n\n\n\n\nan \naxis\n, which specifies the tree relationship between the nodes\n    selected by the location step and the context node,\n\n\na \nnode test\n, which specifies the node object type and name of\n    the nodes selected by the location step, and\n\n\nzero or more \npredicates\n, which use arbitrary expressions to\n    further refine the set of nodes selected by the location step.\n\n\n\n\nThe syntax for a location step is the axis name and node test\nseparated by a double colon, followed by zero or more expressions each\nin square brackets. For example, in \nchild::comment[position()=1]\n,\n\nchild\n is the name of the axis, \ncomment\n is the node test and\n\n[position()=1]\n is a predicate.\n\n\nThe node-set selected by the location step is the node-set that\nresults from generating an initial node-set from the axis and\nnode-test, and then filtering that node-set by each of the predicates\nin turn.\n\n\nThe initial node-set consists of the nodes having the relationship to\nthe context node specified by the axis, and having the node object\ntype and name specified by the node test.  For example, a location\nstep \nraisedBy::GitHubUserID()\n selects the GitHub user ID that has a\nraisedBy relationship with the context node: \nraisedBy\n, the axis,\nspecifies the relationship with the context node; \nGitHubUserID()\n\nspecifies that each node in the initial node-set must be an object of\ntype \nGitHubUserID\n.  The available axes are described\nin \nAxes\n. The available node tests are described\nin \nNode Tests\n. The meaning of some node tests is\ndependent on the axis.\n\n\nThe initial node-set is filtered by the first predicate to generate a\nnew node-set; this new node-set is then filtered using the second\npredicate, and so on. The final node-set is the node-set selected by\nthe location step. The axis affects how the expression in each\npredicate is evaluated and so the semantics of a predicate is defined\nwith respect to an axis. See \nPredicates\n.\n\n\nAxes\n\u00b6\n\n\nAxes define the relationship between a location step and the previous\nlocation step, i.e., its node context.  Axes available in all contexts\nare:\n\n\n\n\n\n\nthe \nchild\n axis contains the children of the context node,\n    which are all nodes with a direct relationship in the graph\n    to the context node\n\n\n\n\n\n\nthe \nproperty\n axis contains the properties of the context node;\n    the axis will be empty unless the context node is an object\n\n\n\n\n\n\nthe \nself\n axis contains just the context node itself\n\n\n\n\n\n\nthe \ndescendant\n axis contains the descendants of the context\n    node; a descendant is a child or a child of a child and so on;\n    thus the descendant axis never contains property or namespace\n    nodes\n\n\n\n\n\n\nCertain object types have relationships with other object types.  Some\nexamples are shown in the table below.  When the previous step\ncontains the type in the left column, the axis in the middle column\ncan be used prior to a node test for the type in the right column.\nThis is not an exhaustive list of relationships in the model graph.\n\n\n\n\n\n\n\n\nContext Object Type\n\n\nAxis\n\n\nNode-set Object Type\n\n\n\n\n\n\n\n\n\n\nBuild\n\n\non\n\n\nRepo\n\n\n\n\n\n\nCommit\n\n\non\n\n\nRepo\n\n\n\n\n\n\nIssue\n\n\nbelongsTo\n\n\nRepo\n\n\n\n\n\n\nPush\n\n\nhasBuild\n\n\nBuild\n\n\n\n\n\n\nPush\n\n\ncontains\n\n\nCommit\n\n\n\n\n\n\nPush\n\n\nafter\n\n\nCommit\n\n\n\n\n\n\nChatId\n\n\nmemberOf\n\n\nChatChannel\n\n\n\n\n\n\nIssue\n\n\nresolvedBy\n\n\nCommit\n\n\n\n\n\n\nCommit\n\n\nauthor\n\n\nGitHubId\n\n\n\n\n\n\nPerson\n\n\nhasChatIdentity\n\n\nSlackId\n\n\n\n\n\n\nPerson\n\n\nhasGithubIdentity\n\n\nGitHubId\n\n\n\n\n\n\nSlackTeam\n\n\nhasChannel\n\n\nChannel\n\n\n\n\n\n\nRepo\n\n\nchannel\n\n\nChannel\n\n\n\n\n\n\nSlackId\n\n\nmemberOf\n\n\nSlackTeam\n\n\n\n\n\n\n\n\nNode Tests\n\u00b6\n\n\nEvery axis has a principal node type, which is different than the\nnode\u2019s object type.  The node type is directly analogous to XPath node\ntypes.  If an axis can contain objects, then the principal node type\nis object; otherwise, it is the type of the nodes that the axis can\ncontain.  Thus,\n\n\n\n\nFor the property axis, the principal node type is property.\n\n\nFor other axes, the principal node type is object.\n\n\n\n\nA node test that is a \nstuff\n, called a node name test, will select\nall object nodes with the name \u201cstuff\u201d of the principal node type.\nFor example, \nchild::src\n will select the object node named \u201csrc\u201d that\nis a child of the context node.  Node name tests can only contain\nalphanumeric, underscore (\n_\n), dash (\n-\n), period (\n.\n), asterisk\n(\n*\n), and question mark (\n?\n) characters.  The asterisk and question\nmark have the same special meaning they have in shell globbing\npatterns, asterisk matches zero of more characters and question mark\nmatches any single character.  To select nodes with names having other\ncharacters, use the \n@name\n attribute in a predicate, e.g.,\n\n/*[@name='c\u00f8mP\u2113\u20ac\u00d7']\n.\n\n\nA node test \n*\n is true for any node of the principal node type. For\nexample, \nchild::*\n will select all object children of the context\nnode, and \nproperty::*\n will select all properties of the context\nnode.\n\n\nA node test of the form \nKind()\n will select all object nodes with\nthe object type \u201cKind\u201d, \neffectively switching the default node object\ntype for the current and subsequent location steps to \u201cKind\u201d\n.  For\nexample, \nbelongsTo::Issue()\n will select all object nodes of object\ntype \u201cIssue\u201d belonging to the context node.  Note that not all object\ntypes are related to all other types.  In this example, if the context\nnode is a GitHub repository, a relationship exists.  If the context\nnode is a Slack channel, there is no direct relationship to type\nIssue.\n\n\nPredicates\n\u00b6\n\n\nA predicate filters a node-set with respect to an axis to produce a\nnew node-set. For each node in the node-set to be filtered, the\nPredicateExpr is evaluated with that node as the context node, with\nthe number of nodes in the node-set as the context size, and with the\nproximity position of the node in the node-set with respect to the\naxis as the context position; if PredicateExpr evaluates to true for\nthat node, the node is included in the new node-set; otherwise, it is\nnot included.\n\n\nA predicate expression is evaluated by evaluating the expression and\nconverting the result to a boolean. If the result is a number, the\nresult will be converted to true if the number is equal to the context\nposition and will be converted to false otherwise; if the result is\nnot a number, then the result will be converted as if by a call to the\nboolean function. Thus a location path \npara[3]\n is equivalent to\n\npara[position()=3]\n.\n\n\nPredicates are optional.  If no predicate is provided, no filtering is\ndone.\n\n\nAbbreviated Syntax\n\u00b6\n\n\nHere are some examples of location paths using abbreviated syntax:\n\n\n\n\n\n\n\n\nSyntax\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nselects the \nsrc\n object children of the context node\n\n\n\n\n\n\n*[@name='c\u00f8mP\u2113\u20ac\u00d7']\n\n\nselects the \nc\u00f8mP\u2113\u20ac\u00d7\n object children of the context node\n\n\n\n\n\n\n*\n\n\nselects all object children of the context node\n\n\n\n\n\n\nPerson()\n\n\nselects all node children of object type \nPerson\n of the context node and switches the context object type to \nPerson\n\n\n\n\n\n\n@name\n\n\nselects the name property of the context node\n\n\n\n\n\n\n@*\n\n\nselects all the property of the context node\n\n\n\n\n\n\nIssue()[1]\n\n\nselects the first child of object type \nIssue\n of the context node\n\n\n\n\n\n\n//foo\n\n\nselects all \nfoo\n descendants of the context node\n\n\n\n\n\n\n//*.py\n\n\nselects all descendants of the context node whose name ends in \n.py\n\n\n\n\n\n\nFile()/src/main/resources//*.md\n\n\nselects all the files ending in \n.md\n under the \n/src/main/resources\n directory; if you are using this in an editor where \nFile()\n is implicit, you do not need the leading \nFile()\n\n\n\n\n\n\nRepo()/@name\n\n\nselects the names of all repositories\n\n\n\n\n\n\nIssue()[@state=\"open\"]/belongsTo::Repo()[@name=\"rug-cli\"]\n\n\nselects all open issues in the repository named \u201crug-cli\u201d\n\n\n\n\n\n\n\n\nExpressions\n\u00b6\n\n\nBasics\n\u00b6\n\n\nExpressions are used in predicates.  Expressions can be:\n\n\n\n\na number\n\n\na string\n\n\na boolean\n\n\na function call\n\n\nlogically \nand\ned and \nor\ned\n\n\ngrouped together by parentheses\n\n\n\n\nRug path expressions do not support variables and variable references.\n\n\nFunction Calls\n\u00b6\n\n\nA FunctionCall expression is evaluated by using the FunctionName to\nidentify a function in the expression evaluation context function\nlibrary, evaluating each of the Arguments, converting each argument to\nthe type required by the function, and finally calling the function,\npassing it the converted arguments. It is an error if the number of\narguments is wrong or if an argument cannot be converted to the\nrequired type. The result of the FunctionCall expression is the result\nreturned by the function.\n\n\nAn argument is converted to type string as if by calling the string\nfunction. An argument is converted to type number as if by calling the\nnumber function. An argument is converted to type boolean as if by\ncalling the boolean function. An argument that is not of type node-set\ncannot be converted to a node-set.\n\n\nNode-sets\n\u00b6\n\n\nA location path can be used as an expression. The expression returns\nthe set of nodes selected by the path.\n\n\nThe \n|\n operator computes the union of its operands, which must be\nnode-sets.\n\n\nPredicates are used to filter expressions in the same way that they\nare used in location paths. It is an error if the expression to be\nfiltered does not evaluate to a node-set. The Predicate filters the\nnode-set with respect to the child axis.\n\n\nBooleans\n\u00b6\n\n\nAn object of type boolean can have one of two values, true and false.\n\n\nAn \nor\n expression is evaluated by evaluating each operand and\nconverting its value to a boolean as if by a call to the boolean\nfunction. The result is true if either value is true and false\notherwise. The right operand is not evaluated if the left operand\nevaluates to true.\n\n\nAn \nand\n expression is evaluated by evaluating each operand and\nconverting its value to a boolean as if by a call to the boolean\nfunction. The result is true if both values are true and false\notherwise. The right operand is not evaluated if the left operand\nevaluates to false.\n\n\nEquality operators, \n=\n, \n!=\n, \n<=\n, \n<\n, \n>=\n, and \n>\n, are only\nsupported for string and number types.  \n=\n and \n!=\n are supported on\nboolean types.  Rug path expressions do not support comparing\nnode-sets to each other or other types.\n\n\nNumbers\n\u00b6\n\n\nA number represents a positive integer number.\n\n\nStrings\n\u00b6\n\n\nStrings consist of a sequence of zero or more Unicode characters.\n\n\nLexical Structure\n\u00b6\n\n\nWhen tokenizing, the longest possible token is always returned.\n\n\nFor readability, whitespace may be used in expressions even though not\nexplicitly allowed by the grammar\n\n\nCore Function Library\n\u00b6\n\n\nThis section describes functions that Rug path expression\nimplementations must always include in the function library that is\nused to evaluate expressions.\n\n\nEach function in the function library is specified using a function\nprototype, which gives the return type, the name of the function, and\nthe type of the arguments. If an argument type is followed by a\nquestion mark, then the argument is optional; otherwise, the argument\nis required.\n\n\nNode Set Functions\n\u00b6\n\n\nFunction:\n \nnumber\n \nlast()\n\n\nThe last function returns a number equal to the context size from the\nexpression evaluation context.\n\n\nFunction:\n \nnumber\n \nposition()\n\n\nThe position function returns a number equal to the context position\nfrom the expression evaluation context.\n\n\nFunction:\n \nnumber\n **count(\nnode-set\n)**\n\n\nThe count function returns the number of nodes in the argument\nnode-set.\n\n\nFunction:\n \nstring\n **name(\nnode-set?\n)**\n\n\nThe name function returns a string representing the name of the node\nin the argument node-set that is first in document order.\n\n\nString Functions\n\u00b6\n\n\nFunction:\n \nstring\n \nstring(\nobject?\n)\n\n\nThe string function converts an object to a string as follows:\n\n\n\n\n\n\nA node-set is converted to a string by returning the string-value\n    of the node in the node-set that is first in document order. If\n    the node-set is empty, an empty string is returned.\n\n\n\n\n\n\nA number is converted to a string as follows\n\n\n\n\n\n\nNaN is converted to the string NaN\n\n\n\n\n\n\npositive zero is converted to the string 0\n\n\n\n\n\n\nnegative zero is converted to the string 0\n\n\n\n\n\n\npositive infinity is converted to the string Infinity\n\n\n\n\n\n\nnegative infinity is converted to the string -Infinity\n\n\n\n\n\n\na number is represented in decimal form as a Number with no\n    decimal point and no leading zeros, preceded by a minus sign\n    (-) if the number is negative\n\n\n\n\n\n\n\n\n\n\nThe boolean false value is converted to the string false. The\n    boolean true value is converted to the string true.\n\n\n\n\n\n\nAn object of a type other than the four basic types is converted\n    to a string in a way that is dependent on that type.\n\n\n\n\n\n\nIf the argument is omitted, it defaults to a node-set with the context\nnode as its only member.\n\n\nFunction:\n \nstring\n **concat(\nstring, string, string*\n)**\n\n\nThe concat function returns the concatenation of its arguments.\n\n\nFunction:\n \nboolean\n \nstarts-with(\nstring, string\n)\n\n\nThe starts-with function returns true if the first argument string\nstarts with the second argument string, and otherwise returns false.\n\n\nFunction:\n \nboolean\n \ncontains(\nstring, string\n)\n\n\nThe contains function returns true if the first argument string\ncontains the second argument string, and otherwise returns false.\n\n\nFunction:\n \nstring\n \nsubstring-before(\nstring, string\n)\n\n\nThe substring-before function returns the substring of the first\nargument string that precedes the first occurrence of the second\nargument string in the first argument string, or the empty string if\nthe first argument string does not contain the second argument\nstring. For example, substring-before(\u201c1999/04/01\u201d,\u201d/\u201d) returns 1999.\n\n\nFunction:\n \nstring\n \nsubstring-after(\nstring, string\n)\n\n\nThe substring-after function returns the substring of the first\nargument string that follows the first occurrence of the second\nargument string in the first argument string, or the empty string if\nthe first argument string does not contain the second argument\nstring. For example, substring-after(\u201c1999/04/01\u201d,\u201d/\u201d) returns 04/01,\nand substring-after(\u201c1999/04/01\u201d,\u201d19\u201d) returns 99/04/01.\n\n\nFunction:\n \nstring\n \nsubstring(\nstring, number, number?\n)\n\n\nThe substring function returns the substring of the first argument\nstarting at the position specified in the second argument with length\nspecified in the third argument. For example, substring(\u201c12345\u201d,1,3)\nreturns \u201c234\u201d. If the third argument is not specified, it returns the\nsubstring starting at the position specified in the second argument\nand continuing to the end of the string. For example,\nsubstring(\u201c12345\u201d,1) returns \u201c2345\u201d.\n\n\nMore precisely, each character in the string is considered to have a\nnumeric position: the position of the first character is 0, the\nposition of the second character is 1 and so on.\n\n\nNOTE:\n This differs from XPath and is in line with Java and\nECMAScript, in which the String.substring method treats the position\nof the first character as 0.\n\n\nFunction:\n \nnumber\n \nstring-length(\nstring?\n)\n\n\nThe string-length returns the number of characters in the string. If\nthe argument is omitted, it defaults to the context node converted to\na string, in other words the string-value of the context node.\n\n\nFunction:\n \nstring\n \ntrim-space(\nstring?\n)\n\n\nThe normalize-space function returns the argument string with\nwhitespace normalized by stripping leading and trailing whitespace.\n\n\nBoolean Functions\n\u00b6\n\n\nFunction:\n \nboolean\n \nboolean(\nobject\n)\n\n\nThe boolean function converts its argument to a boolean as follows:\n\n\n\n\na number is true if and only if it is neither positive or negative\n    zero nor NaN\n\n\na node-set is true if and only if it is non-empty\n\n\na string is true if and only if its length is non-zero\n\n\nan object of a type other than the four basic types is converted\n    to a boolean in a way that is dependent on that type\n\n\n\n\nFunction:\n \nboolean\n \nnot(\nboolean\n)\n\n\nThe not function returns true if its argument is false, and false\notherwise.\n\n\nFunction:\n \nboolean\n \ntrue()\n\n\nThe true function returns true.\n\n\nFunction:\n \nboolean\n \nfalse()\n\n\nThe false function returns false.\n\n\nNumber Functions\n\u00b6\n\n\nFunction: number number(object?)\n\n\nThe number function converts its argument to a number as follows:\n\n\n\n\n\n\na string that consists of optional whitespace followed by an\n    optional minus sign followed by a Number followed by whitespace is\n    converted to the IEEE 754 number that is nearest (according to the\n    IEEE 754 round-to-nearest rule) to the mathematical value\n    represented by the string; any other string is converted to NaN\n\n\n\n\n\n\nboolean true is converted to 1; boolean false is converted to 0\n\n\n\n\n\n\na node-set is first converted to a string as if by a call to the\n    string function and then converted in the same way as a string\n    argument\n\n\n\n\n\n\nan object of a type other than the four basic types is converted\n    to a number in a way that is dependent on that type\n\n\n\n\n\n\nIf the argument is omitted, it defaults to a node-set with the context\nnode as its only member.\n\n\nObject Function\n\u00b6\n\n\nCertain object types will provide functions that can be called on them\nthat are type dependent.  Those functions that return values that can\nbe converted to boolean values can be used.  The implementation of\neach object type should document functions valid to use in Rug path\nexpressions.  These functions can be called in predicates and must be\npreceded with a dot (\n.\n).\n\n\nData Model\n\u00b6\n\n\nRug path expressions operate on objects as a tree. This section\ndescribes how Rug path expressions model objects as a tree. This model is\nconceptual only and does not mandate any particular\nimplementation.\n\n\nThe tree contains nodes.  Each node has a node type and an object\ntype.  The object types are extensible, but there are only three node\ntypes:\n\n\n\n\nroot nodes\n\n\nobject nodes\n\n\nproperty nodes\n\n\n\n\nFor every type of node, there is a way of determining a string-value\nfor a node of that type. For some types of node, the string-value is\npart of the node; for other types of node, the string-value is\ncomputed from the string-value of descendant nodes.\n\n\nThere is an ordering of nodes, dependent on the type of node.  File\nnodes are lexically ordered, Issue nodes are ordered by issue number,\netc.  The property nodes of an object occur before the children of\nthe object.  The relative order of property nodes is\nimplementation-dependent.  Reverse object order is the reverse of\nobject order.\n\n\nRoot nodes and object nodes have an ordered list of child nodes.\nSince Rug path expressions navigate a graph of relationships, it is\npossible to visit a node on the graph multiple times and therefore\nreceives the same objects at multiple depths.\n\n\nRoot Node\n\u00b6\n\n\nThe root node is the root of the tree. A root node does not occur\nexcept as the root of the tree.  The type of a root node is dependent\non the context in which the path expression is evaluated.\n\n\nObject Nodes\n\u00b6\n\n\nThere is an object node for every object in the graph.\n\n\nThe children of an object node are the object nodes with a direct\nrelationship to it.\n\n\nProperty Nodes\n\u00b6\n\n\nEach object node has an associated set of property nodes; the\nobject is the parent of each of these property nodes; however, an\nproperty node is not a child of its parent object.\n\n\nObjects never share property nodes: if one object node is not the\nsame node as another object node, then none of the property nodes of\nthe one object node will be the same node as the property nodes of\nanother object node.\n\n\nAll object nodes will have an property named \nname\n that provides\nthe name of the object node.\n\n\nNamespace Nodes\n\u00b6\n\n\nNamespaces are not supported.\n\n\nProcessing Instruction Nodes\n\u00b6\n\n\nProcessing instruction nodes are not supported.\n\n\nComment Nodes\n\u00b6\n\n\nComment nodes are not supported.\n\n\nText Nodes\n\u00b6\n\n\nText nodes are not supported.\n\n\nConformance\n\u00b6\n\n\nNo conformance information.\n\n\n\n\nAppendix\n\u00b6\n\n\nDifferences with XPath\n\u00b6\n\n\nBelow is a brief summary of differences between Rug path expressions\nand XPath aimed at getting those who know XPath a fast track to using\nRug path expressions.\n\n\n\n\n\n\nRug path expressions distinguish between a node type, which are\n    analogous to XPath node types (e.g., root, element, and\n    attribute), and the node\u2019s object type, which map to the types of\n    objects in the model being traversed (e.g., Project, File, Issue,\n    and Repo).\n\n\n\n\n\n\nRug path expressions have a different set of axis specifiers,\n    eschewing ancestor-related axes, simplifying self/descendant axes,\n    and introducing relationship axes between nodes in the graph.\n\n\n\n\n\n\nString indices start with zero (0).\n\n\n\n\n\n\nRug path expressions do not support comparison of node sets.\n\n\n\n\n\n\nTree nodes have an expanded set of type-specific functions that\n    can be called in predicates.\n\n\n\n\n\n\nNamespaces are not supported.\n\n\n\n\n\n\nProcessing instructions are not relevant.\n\n\n\n\n\n\nLegacy Content\n\u00b6\n\n\nExposure in TypeScript\n\u00b6\n\n\nTreeNode hierarchy\n\n\nPossible Futures\n\u00b6\n\n\nXPath things we may add in future",
            "title": "Path Expressions"
        },
        {
            "location": "/reference/rug/path-expressions/#rug-path-expression-version-01",
            "text": "Not all of the specification below is implemented.  In particular,\nexecution of functions is not fully implemented.",
            "title": "Rug Path Expression Version 0.1"
        },
        {
            "location": "/reference/rug/path-expressions/#introduction",
            "text": "Rug Path Expressions are used to obtain tree nodes from structured\ndata, including:   Projects  Files (going into AST or other internal structure if understood)  Structured parameters, such as JSON or other file formats  The Atomist service model representing project data such as\n    builds, commits and chat teams  Existing trees   All data sources are viewed as trees, and results are always tree\nnodes.  All tree nodes have a  node type ,  name , and  object type .\nUnlike XML elements, tree nodes also may have methods.  Rug tree\nexpressions add a rich set of  object types  from the underlying typed\nmodel they traverse.  Types that are globally searchable\nuse  UpperCamelCase .  Private types, i.e., those only accessible\nunder a global type, use  lowerCamelCase .  The syntax is inspired by sources including  XPath 1.0  (the\nprimary influence) and  JSONPath  (which shows how the same\ncore ideas can be applied to non XML data structures).  A path expression navigates a series of nodes and relationships in a\ngraph.  Each path element in a path element acts on results returned\nby the previous path element.  Think of it as a \u201c flatMap \u201d\noperation on a collection in a functional language: it returns a new\ncollection.  Beause of the close relationship to XPath, the remainder of this\ndocument mirrors the organization of\nthe  XPath Version 1.0 specification .\nAn  ANTLR grammar  for XPath 1.0 is available.",
            "title": "Introduction"
        },
        {
            "location": "/reference/rug/path-expressions/#location-paths",
            "text": "Rug Path Expressions are location paths consisting of one or more\nsequential  Location Steps .  A location path is one or\nmore  location steps  separated by forward slashes,\n( / ).  All location paths should be absolute, i.e., begin with a forward\nslash ( / ).  The actual root context for location paths\ndiffers depending on where the path location is being used:     Rug  Root Context  Context Object Type      Editor/Reviewer  Project  File    Executor  Service  Service    Handler  object passed to Handler  object passed to handler type     This is analogous to the root context of an XPath location path being\nthe root of the document it is acting on.  The context object type is the implicit object type that the initial\nlocation step has.  For example, in an Editor the root context is a\nProject and the context object type of the path step under the root\ncontext is File, allowing one to traverse the project\u2019s file system\nhierarchy from the project root using directory and file names as in /src/main/java  or  /LICENSE .",
            "title": "Location Paths"
        },
        {
            "location": "/reference/rug/path-expressions/#location-steps",
            "text": "A location step has three parts:   an  axis , which specifies the tree relationship between the nodes\n    selected by the location step and the context node,  a  node test , which specifies the node object type and name of\n    the nodes selected by the location step, and  zero or more  predicates , which use arbitrary expressions to\n    further refine the set of nodes selected by the location step.   The syntax for a location step is the axis name and node test\nseparated by a double colon, followed by zero or more expressions each\nin square brackets. For example, in  child::comment[position()=1] , child  is the name of the axis,  comment  is the node test and [position()=1]  is a predicate.  The node-set selected by the location step is the node-set that\nresults from generating an initial node-set from the axis and\nnode-test, and then filtering that node-set by each of the predicates\nin turn.  The initial node-set consists of the nodes having the relationship to\nthe context node specified by the axis, and having the node object\ntype and name specified by the node test.  For example, a location\nstep  raisedBy::GitHubUserID()  selects the GitHub user ID that has a\nraisedBy relationship with the context node:  raisedBy , the axis,\nspecifies the relationship with the context node;  GitHubUserID() \nspecifies that each node in the initial node-set must be an object of\ntype  GitHubUserID .  The available axes are described\nin  Axes . The available node tests are described\nin  Node Tests . The meaning of some node tests is\ndependent on the axis.  The initial node-set is filtered by the first predicate to generate a\nnew node-set; this new node-set is then filtered using the second\npredicate, and so on. The final node-set is the node-set selected by\nthe location step. The axis affects how the expression in each\npredicate is evaluated and so the semantics of a predicate is defined\nwith respect to an axis. See  Predicates .",
            "title": "Location Steps"
        },
        {
            "location": "/reference/rug/path-expressions/#axes",
            "text": "Axes define the relationship between a location step and the previous\nlocation step, i.e., its node context.  Axes available in all contexts\nare:    the  child  axis contains the children of the context node,\n    which are all nodes with a direct relationship in the graph\n    to the context node    the  property  axis contains the properties of the context node;\n    the axis will be empty unless the context node is an object    the  self  axis contains just the context node itself    the  descendant  axis contains the descendants of the context\n    node; a descendant is a child or a child of a child and so on;\n    thus the descendant axis never contains property or namespace\n    nodes    Certain object types have relationships with other object types.  Some\nexamples are shown in the table below.  When the previous step\ncontains the type in the left column, the axis in the middle column\ncan be used prior to a node test for the type in the right column.\nThis is not an exhaustive list of relationships in the model graph.     Context Object Type  Axis  Node-set Object Type      Build  on  Repo    Commit  on  Repo    Issue  belongsTo  Repo    Push  hasBuild  Build    Push  contains  Commit    Push  after  Commit    ChatId  memberOf  ChatChannel    Issue  resolvedBy  Commit    Commit  author  GitHubId    Person  hasChatIdentity  SlackId    Person  hasGithubIdentity  GitHubId    SlackTeam  hasChannel  Channel    Repo  channel  Channel    SlackId  memberOf  SlackTeam",
            "title": "Axes"
        },
        {
            "location": "/reference/rug/path-expressions/#node-tests",
            "text": "Every axis has a principal node type, which is different than the\nnode\u2019s object type.  The node type is directly analogous to XPath node\ntypes.  If an axis can contain objects, then the principal node type\nis object; otherwise, it is the type of the nodes that the axis can\ncontain.  Thus,   For the property axis, the principal node type is property.  For other axes, the principal node type is object.   A node test that is a  stuff , called a node name test, will select\nall object nodes with the name \u201cstuff\u201d of the principal node type.\nFor example,  child::src  will select the object node named \u201csrc\u201d that\nis a child of the context node.  Node name tests can only contain\nalphanumeric, underscore ( _ ), dash ( - ), period ( . ), asterisk\n( * ), and question mark ( ? ) characters.  The asterisk and question\nmark have the same special meaning they have in shell globbing\npatterns, asterisk matches zero of more characters and question mark\nmatches any single character.  To select nodes with names having other\ncharacters, use the  @name  attribute in a predicate, e.g., /*[@name='c\u00f8mP\u2113\u20ac\u00d7'] .  A node test  *  is true for any node of the principal node type. For\nexample,  child::*  will select all object children of the context\nnode, and  property::*  will select all properties of the context\nnode.  A node test of the form  Kind()  will select all object nodes with\nthe object type \u201cKind\u201d,  effectively switching the default node object\ntype for the current and subsequent location steps to \u201cKind\u201d .  For\nexample,  belongsTo::Issue()  will select all object nodes of object\ntype \u201cIssue\u201d belonging to the context node.  Note that not all object\ntypes are related to all other types.  In this example, if the context\nnode is a GitHub repository, a relationship exists.  If the context\nnode is a Slack channel, there is no direct relationship to type\nIssue.",
            "title": "Node Tests"
        },
        {
            "location": "/reference/rug/path-expressions/#predicates",
            "text": "A predicate filters a node-set with respect to an axis to produce a\nnew node-set. For each node in the node-set to be filtered, the\nPredicateExpr is evaluated with that node as the context node, with\nthe number of nodes in the node-set as the context size, and with the\nproximity position of the node in the node-set with respect to the\naxis as the context position; if PredicateExpr evaluates to true for\nthat node, the node is included in the new node-set; otherwise, it is\nnot included.  A predicate expression is evaluated by evaluating the expression and\nconverting the result to a boolean. If the result is a number, the\nresult will be converted to true if the number is equal to the context\nposition and will be converted to false otherwise; if the result is\nnot a number, then the result will be converted as if by a call to the\nboolean function. Thus a location path  para[3]  is equivalent to para[position()=3] .  Predicates are optional.  If no predicate is provided, no filtering is\ndone.",
            "title": "Predicates"
        },
        {
            "location": "/reference/rug/path-expressions/#abbreviated-syntax",
            "text": "Here are some examples of location paths using abbreviated syntax:     Syntax  Description      src  selects the  src  object children of the context node    *[@name='c\u00f8mP\u2113\u20ac\u00d7']  selects the  c\u00f8mP\u2113\u20ac\u00d7  object children of the context node    *  selects all object children of the context node    Person()  selects all node children of object type  Person  of the context node and switches the context object type to  Person    @name  selects the name property of the context node    @*  selects all the property of the context node    Issue()[1]  selects the first child of object type  Issue  of the context node    //foo  selects all  foo  descendants of the context node    //*.py  selects all descendants of the context node whose name ends in  .py    File()/src/main/resources//*.md  selects all the files ending in  .md  under the  /src/main/resources  directory; if you are using this in an editor where  File()  is implicit, you do not need the leading  File()    Repo()/@name  selects the names of all repositories    Issue()[@state=\"open\"]/belongsTo::Repo()[@name=\"rug-cli\"]  selects all open issues in the repository named \u201crug-cli\u201d",
            "title": "Abbreviated Syntax"
        },
        {
            "location": "/reference/rug/path-expressions/#expressions",
            "text": "",
            "title": "Expressions"
        },
        {
            "location": "/reference/rug/path-expressions/#basics",
            "text": "Expressions are used in predicates.  Expressions can be:   a number  a string  a boolean  a function call  logically  and ed and  or ed  grouped together by parentheses   Rug path expressions do not support variables and variable references.",
            "title": "Basics"
        },
        {
            "location": "/reference/rug/path-expressions/#function-calls",
            "text": "A FunctionCall expression is evaluated by using the FunctionName to\nidentify a function in the expression evaluation context function\nlibrary, evaluating each of the Arguments, converting each argument to\nthe type required by the function, and finally calling the function,\npassing it the converted arguments. It is an error if the number of\narguments is wrong or if an argument cannot be converted to the\nrequired type. The result of the FunctionCall expression is the result\nreturned by the function.  An argument is converted to type string as if by calling the string\nfunction. An argument is converted to type number as if by calling the\nnumber function. An argument is converted to type boolean as if by\ncalling the boolean function. An argument that is not of type node-set\ncannot be converted to a node-set.",
            "title": "Function Calls"
        },
        {
            "location": "/reference/rug/path-expressions/#node-sets",
            "text": "A location path can be used as an expression. The expression returns\nthe set of nodes selected by the path.  The  |  operator computes the union of its operands, which must be\nnode-sets.  Predicates are used to filter expressions in the same way that they\nare used in location paths. It is an error if the expression to be\nfiltered does not evaluate to a node-set. The Predicate filters the\nnode-set with respect to the child axis.",
            "title": "Node-sets"
        },
        {
            "location": "/reference/rug/path-expressions/#booleans",
            "text": "An object of type boolean can have one of two values, true and false.  An  or  expression is evaluated by evaluating each operand and\nconverting its value to a boolean as if by a call to the boolean\nfunction. The result is true if either value is true and false\notherwise. The right operand is not evaluated if the left operand\nevaluates to true.  An  and  expression is evaluated by evaluating each operand and\nconverting its value to a boolean as if by a call to the boolean\nfunction. The result is true if both values are true and false\notherwise. The right operand is not evaluated if the left operand\nevaluates to false.  Equality operators,  = ,  != ,  <= ,  < ,  >= , and  > , are only\nsupported for string and number types.   =  and  !=  are supported on\nboolean types.  Rug path expressions do not support comparing\nnode-sets to each other or other types.",
            "title": "Booleans"
        },
        {
            "location": "/reference/rug/path-expressions/#numbers",
            "text": "A number represents a positive integer number.",
            "title": "Numbers"
        },
        {
            "location": "/reference/rug/path-expressions/#strings",
            "text": "Strings consist of a sequence of zero or more Unicode characters.",
            "title": "Strings"
        },
        {
            "location": "/reference/rug/path-expressions/#lexical-structure",
            "text": "When tokenizing, the longest possible token is always returned.  For readability, whitespace may be used in expressions even though not\nexplicitly allowed by the grammar",
            "title": "Lexical Structure"
        },
        {
            "location": "/reference/rug/path-expressions/#core-function-library",
            "text": "This section describes functions that Rug path expression\nimplementations must always include in the function library that is\nused to evaluate expressions.  Each function in the function library is specified using a function\nprototype, which gives the return type, the name of the function, and\nthe type of the arguments. If an argument type is followed by a\nquestion mark, then the argument is optional; otherwise, the argument\nis required.",
            "title": "Core Function Library"
        },
        {
            "location": "/reference/rug/path-expressions/#node-set-functions",
            "text": "Function:   number   last()  The last function returns a number equal to the context size from the\nexpression evaluation context.  Function:   number   position()  The position function returns a number equal to the context position\nfrom the expression evaluation context.  Function:   number  **count( node-set )**  The count function returns the number of nodes in the argument\nnode-set.  Function:   string  **name( node-set? )**  The name function returns a string representing the name of the node\nin the argument node-set that is first in document order.",
            "title": "Node Set Functions"
        },
        {
            "location": "/reference/rug/path-expressions/#string-functions",
            "text": "Function:   string   string( object? )  The string function converts an object to a string as follows:    A node-set is converted to a string by returning the string-value\n    of the node in the node-set that is first in document order. If\n    the node-set is empty, an empty string is returned.    A number is converted to a string as follows    NaN is converted to the string NaN    positive zero is converted to the string 0    negative zero is converted to the string 0    positive infinity is converted to the string Infinity    negative infinity is converted to the string -Infinity    a number is represented in decimal form as a Number with no\n    decimal point and no leading zeros, preceded by a minus sign\n    (-) if the number is negative      The boolean false value is converted to the string false. The\n    boolean true value is converted to the string true.    An object of a type other than the four basic types is converted\n    to a string in a way that is dependent on that type.    If the argument is omitted, it defaults to a node-set with the context\nnode as its only member.  Function:   string  **concat( string, string, string* )**  The concat function returns the concatenation of its arguments.  Function:   boolean   starts-with( string, string )  The starts-with function returns true if the first argument string\nstarts with the second argument string, and otherwise returns false.  Function:   boolean   contains( string, string )  The contains function returns true if the first argument string\ncontains the second argument string, and otherwise returns false.  Function:   string   substring-before( string, string )  The substring-before function returns the substring of the first\nargument string that precedes the first occurrence of the second\nargument string in the first argument string, or the empty string if\nthe first argument string does not contain the second argument\nstring. For example, substring-before(\u201c1999/04/01\u201d,\u201d/\u201d) returns 1999.  Function:   string   substring-after( string, string )  The substring-after function returns the substring of the first\nargument string that follows the first occurrence of the second\nargument string in the first argument string, or the empty string if\nthe first argument string does not contain the second argument\nstring. For example, substring-after(\u201c1999/04/01\u201d,\u201d/\u201d) returns 04/01,\nand substring-after(\u201c1999/04/01\u201d,\u201d19\u201d) returns 99/04/01.  Function:   string   substring( string, number, number? )  The substring function returns the substring of the first argument\nstarting at the position specified in the second argument with length\nspecified in the third argument. For example, substring(\u201c12345\u201d,1,3)\nreturns \u201c234\u201d. If the third argument is not specified, it returns the\nsubstring starting at the position specified in the second argument\nand continuing to the end of the string. For example,\nsubstring(\u201c12345\u201d,1) returns \u201c2345\u201d.  More precisely, each character in the string is considered to have a\nnumeric position: the position of the first character is 0, the\nposition of the second character is 1 and so on.  NOTE:  This differs from XPath and is in line with Java and\nECMAScript, in which the String.substring method treats the position\nof the first character as 0.  Function:   number   string-length( string? )  The string-length returns the number of characters in the string. If\nthe argument is omitted, it defaults to the context node converted to\na string, in other words the string-value of the context node.  Function:   string   trim-space( string? )  The normalize-space function returns the argument string with\nwhitespace normalized by stripping leading and trailing whitespace.",
            "title": "String Functions"
        },
        {
            "location": "/reference/rug/path-expressions/#boolean-functions",
            "text": "Function:   boolean   boolean( object )  The boolean function converts its argument to a boolean as follows:   a number is true if and only if it is neither positive or negative\n    zero nor NaN  a node-set is true if and only if it is non-empty  a string is true if and only if its length is non-zero  an object of a type other than the four basic types is converted\n    to a boolean in a way that is dependent on that type   Function:   boolean   not( boolean )  The not function returns true if its argument is false, and false\notherwise.  Function:   boolean   true()  The true function returns true.  Function:   boolean   false()  The false function returns false.",
            "title": "Boolean Functions"
        },
        {
            "location": "/reference/rug/path-expressions/#number-functions",
            "text": "Function: number number(object?)  The number function converts its argument to a number as follows:    a string that consists of optional whitespace followed by an\n    optional minus sign followed by a Number followed by whitespace is\n    converted to the IEEE 754 number that is nearest (according to the\n    IEEE 754 round-to-nearest rule) to the mathematical value\n    represented by the string; any other string is converted to NaN    boolean true is converted to 1; boolean false is converted to 0    a node-set is first converted to a string as if by a call to the\n    string function and then converted in the same way as a string\n    argument    an object of a type other than the four basic types is converted\n    to a number in a way that is dependent on that type    If the argument is omitted, it defaults to a node-set with the context\nnode as its only member.",
            "title": "Number Functions"
        },
        {
            "location": "/reference/rug/path-expressions/#object-function",
            "text": "Certain object types will provide functions that can be called on them\nthat are type dependent.  Those functions that return values that can\nbe converted to boolean values can be used.  The implementation of\neach object type should document functions valid to use in Rug path\nexpressions.  These functions can be called in predicates and must be\npreceded with a dot ( . ).",
            "title": "Object Function"
        },
        {
            "location": "/reference/rug/path-expressions/#data-model",
            "text": "Rug path expressions operate on objects as a tree. This section\ndescribes how Rug path expressions model objects as a tree. This model is\nconceptual only and does not mandate any particular\nimplementation.  The tree contains nodes.  Each node has a node type and an object\ntype.  The object types are extensible, but there are only three node\ntypes:   root nodes  object nodes  property nodes   For every type of node, there is a way of determining a string-value\nfor a node of that type. For some types of node, the string-value is\npart of the node; for other types of node, the string-value is\ncomputed from the string-value of descendant nodes.  There is an ordering of nodes, dependent on the type of node.  File\nnodes are lexically ordered, Issue nodes are ordered by issue number,\netc.  The property nodes of an object occur before the children of\nthe object.  The relative order of property nodes is\nimplementation-dependent.  Reverse object order is the reverse of\nobject order.  Root nodes and object nodes have an ordered list of child nodes.\nSince Rug path expressions navigate a graph of relationships, it is\npossible to visit a node on the graph multiple times and therefore\nreceives the same objects at multiple depths.",
            "title": "Data Model"
        },
        {
            "location": "/reference/rug/path-expressions/#root-node",
            "text": "The root node is the root of the tree. A root node does not occur\nexcept as the root of the tree.  The type of a root node is dependent\non the context in which the path expression is evaluated.",
            "title": "Root Node"
        },
        {
            "location": "/reference/rug/path-expressions/#object-nodes",
            "text": "There is an object node for every object in the graph.  The children of an object node are the object nodes with a direct\nrelationship to it.",
            "title": "Object Nodes"
        },
        {
            "location": "/reference/rug/path-expressions/#property-nodes",
            "text": "Each object node has an associated set of property nodes; the\nobject is the parent of each of these property nodes; however, an\nproperty node is not a child of its parent object.  Objects never share property nodes: if one object node is not the\nsame node as another object node, then none of the property nodes of\nthe one object node will be the same node as the property nodes of\nanother object node.  All object nodes will have an property named  name  that provides\nthe name of the object node.",
            "title": "Property Nodes"
        },
        {
            "location": "/reference/rug/path-expressions/#namespace-nodes",
            "text": "Namespaces are not supported.",
            "title": "Namespace Nodes"
        },
        {
            "location": "/reference/rug/path-expressions/#processing-instruction-nodes",
            "text": "Processing instruction nodes are not supported.",
            "title": "Processing Instruction Nodes"
        },
        {
            "location": "/reference/rug/path-expressions/#comment-nodes",
            "text": "Comment nodes are not supported.",
            "title": "Comment Nodes"
        },
        {
            "location": "/reference/rug/path-expressions/#text-nodes",
            "text": "Text nodes are not supported.",
            "title": "Text Nodes"
        },
        {
            "location": "/reference/rug/path-expressions/#conformance",
            "text": "No conformance information.",
            "title": "Conformance"
        },
        {
            "location": "/reference/rug/path-expressions/#appendix",
            "text": "",
            "title": "Appendix"
        },
        {
            "location": "/reference/rug/path-expressions/#differences-with-xpath",
            "text": "Below is a brief summary of differences between Rug path expressions\nand XPath aimed at getting those who know XPath a fast track to using\nRug path expressions.    Rug path expressions distinguish between a node type, which are\n    analogous to XPath node types (e.g., root, element, and\n    attribute), and the node\u2019s object type, which map to the types of\n    objects in the model being traversed (e.g., Project, File, Issue,\n    and Repo).    Rug path expressions have a different set of axis specifiers,\n    eschewing ancestor-related axes, simplifying self/descendant axes,\n    and introducing relationship axes between nodes in the graph.    String indices start with zero (0).    Rug path expressions do not support comparison of node sets.    Tree nodes have an expanded set of type-specific functions that\n    can be called in predicates.    Namespaces are not supported.    Processing instructions are not relevant.",
            "title": "Differences with XPath"
        },
        {
            "location": "/reference/rug/path-expressions/#legacy-content",
            "text": "",
            "title": "Legacy Content"
        },
        {
            "location": "/reference/rug/path-expressions/#exposure-in-typescript",
            "text": "TreeNode hierarchy",
            "title": "Exposure in TypeScript"
        },
        {
            "location": "/reference/rug/path-expressions/#possible-futures",
            "text": "XPath things we may add in future",
            "title": "Possible Futures"
        },
        {
            "location": "/reference/rug-cli/",
            "text": "Below is the complete list of options and commands for the Rug CLI.\n\n\nGlobal command-line options\n\u00b6\n\n\n\n\n--disable-verification\n\n\nDisable verification of extensions (Use with Caution)\n\n\n--disable-version-check\n\n\nDisable version compatibility check (Use with Caution)\n\n\n-?\n, \n--help\n\n\nPrint usage help\n\n\n-h\n, \n--help\n\n\nPrint usage help\n\n\n-n\n, \n--noisy\n\n\nDisplay more progress messages\n\n\n-o\n, \n--offline\n\n\nUse only downloaded archives\n\n\n-q\n, \n--quiet\n\n\nDo not display progress messages\n\n\n--requires=RUG_VERSION\n\n\nOverwrite the Rug version to RUG_VERSION (Use with Caution)\n\n\n-r\n, \n--resolver-report\n\n\nPrint dependency tree\n\n\n-s FILE\n, \n--settings=FILE\n\n\nUse settings file FILE\n\n\n-t\n, \n--timer\n\n\nPrint timing information\n\n\n-u\n, \n--update\n\n\nUpdate dependency resolution\n\n\n-V\n, \n--verbose\n\n\nPrint verbose output\n\n\n-X\n, \n--error\n\n\nPrint stacktraces\n\n\n\n\nCommands\n\u00b6\n\n\nclean\n\u00b6\n\n\nClean up project\n\n\nUsage:\n\n\n$\n rug clean \n[\nOPTION\n]\n...\n\n\n\n\nClean up all temporarily created files and directories from the project.\n\n\nconfigure\n\u00b6\n\n\nChange/manage configuration settings\n\n\nUsage:\n\n\n$\n rug configure \n[\nOPTION\n]\n... SUBCOMMAND \n[\nARCHIVE\n]\n\n\n\n\n\nSUBCOMMAND can either be \u2018default archive\u2019 or \u2018repositories\u2019.  The \u2018repositories\u2019 command uses your GitHub authentication to configure all of your private Rug archive repositories and enables them for publication with the publish command.  Please execute the login command before configuring repositories.  The \u2018default archive\u2019 command sets a global or project specific Rug archive so that Rugs can be invoked without a fully qualified coordinate.  ARCHIVE should be a valid archive coordinate of form GROUP:ARTIFACT or just GROUP.  At any time those defaults can be overriden by specifying GROUP:ARTIFACT and -a from the command line.\n\n\nCommand aliases:\n \nconfig\n, \nconf\n\n\nSubcommands:\n \ndefault archive\n, \nrepositories\n\n\nCommand options:\n\n\n\n\n-a AV\n, \n--archive-version=AV\n\n\nSet default archive version to AV\n\n\n-D\n, \n--delete\n\n\nRemove default archive\n\n\n-g\n, \n--global\n\n\nSet global or project default archive\n\n\n-S\n, \n--save\n\n\nSet default archive\n\n\n\n\ndescribe\n\u00b6\n\n\nPrint details about an archive or Rug\n\n\nUsage:\n\n\n$\n rug describe \n[\nOPTION\n]\n... TYPE ARTIFACT\n\n\n\n\nTYPE should be \u2018editor\u2019, \u2018generator\u2019, \u2018command-handler\u2019, \u2018event-handler\u2019, \u2018response-handler\u2019, \u2018function\u2019, \u2018dependencies\u2019 or \u2018archive\u2019 and ARTIFACT should be the full name of an artifact, e.g., \u201catomist:spring-service:Spring Microservice\u201d.  If the name of the artifact has spaces in it, you need to put quotes around it.  FORMAT can be \u2018json\u2019 or \u2018yaml\u2019 and is only valid when describing an archive.\n\n\nCommand aliases:\n \ndesc\n\n\nSubcommands:\n \neditor\n, \ngenerator\n, \narchive\n, \ncommand-handler\n, \nevent-handler\n, \nresponse-handler\n, \nintegration-test\n, \nfunction\n, \ndependencies\n\n\nCommand options:\n\n\n\n\n-a AV\n, \n--archive-version=AV\n\n\nUse archive version AV\n\n\n-l\n, \n--local\n\n\nUse local working directory as archive\n\n\n-O\n, \n--operations\n\n\nList operations\n\n\n--output=FORMAT\n\n\nSpecify output FORMAT\n\n\n\n\nedit\n\u00b6\n\n\nRun an editor to modify an existing project\n\n\nUsage:\n\n\n$\n rug edit \n[\nOPTION\n]\n... EDITOR \n[\nPARAMETER\n]\n...\n\n\n\n\nEDITOR is a Rug editor, e.g., \u201catomist:common-editors:AddReadme\u201d.  If the name of the editor has spaces in it, you need to put quotes around it.  To pass parameters to the editor you can specify multiple PARAMETERs in  form of \u201cNAME=VALUE\u201d.\n\n\nCommand aliases:\n \ned\n\n\nCommand options:\n\n\n\n\n-a AV\n, \n--archive-version=AV\n\n\nUse archive version AV\n\n\n-C DIR\n, \n--change-dir=DIR\n\n\nRun editor in directory DIR, default is \u2018.\u2019\n\n\n-d\n, \n--dry-run\n\n\nDo not persist changes, print diffs\n\n\n-I\n, \n--interactive\n\n\nInteractive mode for specifying parameter values\n\n\n-l\n, \n--local\n\n\nUse local working directory as archive\n\n\n-R\n, \n--repo\n\n\nCommit files to local git repository\n\n\n\n\nexit\n\u00b6\n\n\nExit a shell session\n\n\nUsage:\n\n\n$\n rug \nexit\n \n[\nOPTION\n]\n...\n\n\n\n\nCommand aliases:\n \nquit\n, \nq\n\n\nextension\n\u00b6\n\n\nManage command line extensions\n\n\nUsage:\n\n\n$\n rug extension SUBCOMMAND \n[\nOPTION\n]\n... \n[\nEXTENSION\n]\n\n\n\n\n\nSUBCOMMAND is either \u2018install\u2019, \u2018uninstall\u2019 or \u2018list\u2019.  EXTENSION should be a valid extension identifier of form GROUP:ARTIFACT.  If no version EV is provided with -a, the latest version of the extension is installed.\n\n\nCommand aliases:\n \next\n\n\nSubcommands:\n \nlist\n, \ninstall\n, \nuninstall\n\n\nCommand options:\n\n\n\n\n-a EV\n, \n--extension-version=EV\n\n\nVersion EV of extension to install\n\n\n\n\ngenerate\n\u00b6\n\n\nRun a generator to create a new project\n\n\nUsage:\n\n\n$\n rug generate \n[\nOPTION\n]\n... GENERATOR PROJECT_NAME \n[\nPARAMETER\n]\n...\n\n\n\n\nGENERATOR is a Rug generator, e.g., \u201catomist:spring-service:Spring Microservice\u201d.  If the name of the generator has spaces in it, you need to put quotes around it.  PROJECT_NAME specifies the required name of the generated project.  To pass parameters to the generator you can specify multiple PARAMETERs in form \u201cNAME=VALUE\u201d.\n\n\nCommand aliases:\n \ngen\n\n\nCommand options:\n\n\n\n\n-a AV\n, \n--archive-version=AV\n\n\nUse archive version AV\n\n\n-C DIR\n, \n--change-dir=DIR\n\n\nCreate project in directory DIR, default is \u2018.\u2019\n\n\n-F\n, \n--force\n\n\nForce overwrite if target directory already exists\n\n\n-I\n, \n--interactive\n\n\nInteractive mode for specifying parameter values\n\n\n-l\n, \n--local\n\n\nUse local working directory as archive\n\n\n-R\n, \n--repo\n\n\nInitialize and commit files to a new git repository\n\n\n\n\nhelp\n\u00b6\n\n\nPrint usage help\n\n\nUsage:\n\n\n$\n rug \nhelp\n\n\n\n\n\nPrints this usage help.\n\n\nCommand aliases:\n \nh\n, \n?\n\n\ninstall\n\u00b6\n\n\nCreate and install an archive into the local repository\n\n\nUsage:\n\n\n$\n rug install \n[\nOPTION\n]\n...\n\n\n\n\nCreate and install an archive from the current project in the local repository.\n\n\nCommand options:\n\n\n\n\n-a AV\n, \n--archive-version=AV\n\n\nOverride archive version with AV\n\n\n\n\nlist\n\u00b6\n\n\nList locally installed archives\n\n\nUsage:\n\n\n$\n rug list \n[\nOPTION\n]\n...\n\n\n\n\nFILTER could be any of group, artifact or version.  VALUE should be a valid filter expression: for group and artifact ? and * are supported as wildcards;  the version filter can be any valid version or version range.\n\n\nCommand aliases:\n \nls\n\n\nCommand options:\n\n\n\n\n-f FILTER=VALUE\n, \n--filter=FILTER=VALUE\n\n\nSpecify filter of type FILTER with VALUE\n\n\n\n\nlogin\n\u00b6\n\n\nLogin using GitHub authentication\n\n\nUsage:\n\n\n$\n rug login \n[\nOPTION\n]\n...\n\n\n\n\nThe Rug CLI uses your GitHub token to verify your membership in GitHub organizations and Slack teams that have the Atomist Bot enrolled.  Those teams have acccess to additional features, eg. team private Rug archives.  Once you used the \u2018login\u2019 command, you can run \u2018configure repositories\u2019 to configure access to your team\u2019s artifact repositories.\n\n\nCommand aliases:\n \nlg\n\n\nCommand options:\n\n\n\n\n--mfa-code=MFA_CODE\n\n\nGitHub MFA code (only required if MFA is enabled)\n\n\n--username=USERNAME\n\n\nGitHub username\n\n\n\n\npath\n\u00b6\n\n\nEvaluate a path expression against a project\n\n\nUsage:\n\n\n$\n rug path \n[\nOPTION\n]\n... \n[\nEXPRESSION\n]\n\n\n\n\n\nEXPRESSION can be any valid Rug path expression.  Depending on your expression you might need to put it in quotes.  Use \u2018\u2013values\u2019 to display values of tree nodes; caution as this option might lead to a lot of data being printed.\n\n\nCommand aliases:\n \ntree\n\n\nCommand options:\n\n\n\n\n-C DIR\n, \n--change-dir=DIR\n\n\nEvaluate expression against project in directory DIR, default is \u2018.\u2019\n\n\n-v\n, \n--values\n\n\nDisplays tree node values\n\n\n\n\npublish\n\u00b6\n\n\nCreate and publish an archive into a remote repository\n\n\nUsage:\n\n\n$\n rug publish \n[\nOPTION\n]\n...\n\n\n\n\nCreate a Rug archive from the current repo and publish it into a remote repository.  Use -i to specify what repository configuration should be used to publish.  ID should refer to a repository name in cli.yml\n\n\nCommand options:\n\n\n\n\n--archive-artifact=AA\n\n\nOverride archive artifact with AA\n\n\n--archive-group=AG\n\n\nOverride archive group with AG\n\n\n-a AV\n, \n--archive-version=AV\n\n\nOverride archive version with AV\n\n\n-F\n, \n--force\n\n\nForce publish if working tree isn\u2019t clean\n\n\n-i ID\n, \n--id=ID\n\n\nID identifying the repository to publish into\n\n\n-P\n, \n--publish-all\n\n\nPublish archive into all repositories it exists\n\n\n\n\nsearch\n\u00b6\n\n\nSearch online catalog of available archives\n\n\nUsage:\n\n\n$\n rug search \n[\nOPTION\n]\n... \n[\nSEARCH\n]\n\n\n\n\n\nSEARCH could be any text used to search the catalog.  TAG can be any valid tag, eg. spring or elm.  TYPE can be either \u2018editor\u2019, \u2018generator\u2019, \u2018command_handler\u2019, \u2018event_handler\u2019 or \u2018response_handler\u2019.\n\n\nCommand options:\n\n\n\n\n-K TYPE\n, \n--type=TYPE\n\n\nSpecify a TYPE to filter search based on Rug type\n\n\n-O\n, \n--operations\n\n\nList operations\n\n\n-T TAG\n, \n--tag=TAG\n\n\nSpecify a TAG to filter search\n\n\n\n\nshell\n\u00b6\n\n\nStart a shell for a specified Rug archive\n\n\nUsage:\n\n\n$\n rug shell \n[\nOPTION\n]\n... ARCHIVE\n\n\n\n\nARCHIVE should be a full name of an Rug archive, e.g., \u201catomist:spring-service\u201d.\n\n\nCommand aliases:\n \nrepl\n, \nload\n\n\nCommand options:\n\n\n\n\n-a AV\n, \n--archive-version=AV\n\n\nUse archive version AV\n\n\n-l\n, \n--local\n\n\nUse local working directory as archive\n\n\n\n\ntest\n\u00b6\n\n\nRun test scenarios\n\n\nUsage:\n\n\n$\n rug \ntest\n \n[\nOPTION\n]\n... \n[\nTEST\n]\n\n\n\n\n\nTEST is the name of a test feature or feature file.  If no TEST is specified, all scenarios will run.\n\n\nCommand options:\n\n\n\n\n--disable-console-log\n\n\nDisable console logging\n\n\n\n\nto path\n\u00b6\n\n\nDisplay path expression to a point in a file within a project\n\n\nUsage:\n\n\n$\n rug to-path \n[\nOPTION\n]\n... PATH\n\n\n\n\nPATH must be a valid path within the project at DIR or \u2018.\u2019.  \n\n\nCommand options:\n\n\n\n\n-C DIR\n, \n--change-dir=DIR\n\n\nEvaluate expression against project in directory DIR, default is \u2018.\u2019\n\n\n--column=COLUMN\n\n\nColumn within file at LINE\n\n\n--kind=KIND\n\n\nRug Extension kind, eg. \u2018ScalaFile\u2019 or \u2018Pom\u2019\n\n\n--line=LINE\n\n\nLine within the file",
            "title": "Rug CLI"
        },
        {
            "location": "/reference/rug-cli/#global-command-line-options",
            "text": "--disable-verification  Disable verification of extensions (Use with Caution)  --disable-version-check  Disable version compatibility check (Use with Caution)  -? ,  --help  Print usage help  -h ,  --help  Print usage help  -n ,  --noisy  Display more progress messages  -o ,  --offline  Use only downloaded archives  -q ,  --quiet  Do not display progress messages  --requires=RUG_VERSION  Overwrite the Rug version to RUG_VERSION (Use with Caution)  -r ,  --resolver-report  Print dependency tree  -s FILE ,  --settings=FILE  Use settings file FILE  -t ,  --timer  Print timing information  -u ,  --update  Update dependency resolution  -V ,  --verbose  Print verbose output  -X ,  --error  Print stacktraces",
            "title": "Global command-line options"
        },
        {
            "location": "/reference/rug-cli/#commands",
            "text": "",
            "title": "Commands"
        },
        {
            "location": "/reference/rug-cli/#clean",
            "text": "Clean up project  Usage:  $  rug clean  [ OPTION ] ...  Clean up all temporarily created files and directories from the project.",
            "title": "clean"
        },
        {
            "location": "/reference/rug-cli/#configure",
            "text": "Change/manage configuration settings  Usage:  $  rug configure  [ OPTION ] ... SUBCOMMAND  [ ARCHIVE ]   SUBCOMMAND can either be \u2018default archive\u2019 or \u2018repositories\u2019.  The \u2018repositories\u2019 command uses your GitHub authentication to configure all of your private Rug archive repositories and enables them for publication with the publish command.  Please execute the login command before configuring repositories.  The \u2018default archive\u2019 command sets a global or project specific Rug archive so that Rugs can be invoked without a fully qualified coordinate.  ARCHIVE should be a valid archive coordinate of form GROUP:ARTIFACT or just GROUP.  At any time those defaults can be overriden by specifying GROUP:ARTIFACT and -a from the command line.  Command aliases:   config ,  conf  Subcommands:   default archive ,  repositories  Command options:   -a AV ,  --archive-version=AV  Set default archive version to AV  -D ,  --delete  Remove default archive  -g ,  --global  Set global or project default archive  -S ,  --save  Set default archive",
            "title": "configure"
        },
        {
            "location": "/reference/rug-cli/#describe",
            "text": "Print details about an archive or Rug  Usage:  $  rug describe  [ OPTION ] ... TYPE ARTIFACT  TYPE should be \u2018editor\u2019, \u2018generator\u2019, \u2018command-handler\u2019, \u2018event-handler\u2019, \u2018response-handler\u2019, \u2018function\u2019, \u2018dependencies\u2019 or \u2018archive\u2019 and ARTIFACT should be the full name of an artifact, e.g., \u201catomist:spring-service:Spring Microservice\u201d.  If the name of the artifact has spaces in it, you need to put quotes around it.  FORMAT can be \u2018json\u2019 or \u2018yaml\u2019 and is only valid when describing an archive.  Command aliases:   desc  Subcommands:   editor ,  generator ,  archive ,  command-handler ,  event-handler ,  response-handler ,  integration-test ,  function ,  dependencies  Command options:   -a AV ,  --archive-version=AV  Use archive version AV  -l ,  --local  Use local working directory as archive  -O ,  --operations  List operations  --output=FORMAT  Specify output FORMAT",
            "title": "describe"
        },
        {
            "location": "/reference/rug-cli/#edit",
            "text": "Run an editor to modify an existing project  Usage:  $  rug edit  [ OPTION ] ... EDITOR  [ PARAMETER ] ...  EDITOR is a Rug editor, e.g., \u201catomist:common-editors:AddReadme\u201d.  If the name of the editor has spaces in it, you need to put quotes around it.  To pass parameters to the editor you can specify multiple PARAMETERs in  form of \u201cNAME=VALUE\u201d.  Command aliases:   ed  Command options:   -a AV ,  --archive-version=AV  Use archive version AV  -C DIR ,  --change-dir=DIR  Run editor in directory DIR, default is \u2018.\u2019  -d ,  --dry-run  Do not persist changes, print diffs  -I ,  --interactive  Interactive mode for specifying parameter values  -l ,  --local  Use local working directory as archive  -R ,  --repo  Commit files to local git repository",
            "title": "edit"
        },
        {
            "location": "/reference/rug-cli/#exit",
            "text": "Exit a shell session  Usage:  $  rug  exit   [ OPTION ] ...  Command aliases:   quit ,  q",
            "title": "exit"
        },
        {
            "location": "/reference/rug-cli/#extension",
            "text": "Manage command line extensions  Usage:  $  rug extension SUBCOMMAND  [ OPTION ] ...  [ EXTENSION ]   SUBCOMMAND is either \u2018install\u2019, \u2018uninstall\u2019 or \u2018list\u2019.  EXTENSION should be a valid extension identifier of form GROUP:ARTIFACT.  If no version EV is provided with -a, the latest version of the extension is installed.  Command aliases:   ext  Subcommands:   list ,  install ,  uninstall  Command options:   -a EV ,  --extension-version=EV  Version EV of extension to install",
            "title": "extension"
        },
        {
            "location": "/reference/rug-cli/#generate",
            "text": "Run a generator to create a new project  Usage:  $  rug generate  [ OPTION ] ... GENERATOR PROJECT_NAME  [ PARAMETER ] ...  GENERATOR is a Rug generator, e.g., \u201catomist:spring-service:Spring Microservice\u201d.  If the name of the generator has spaces in it, you need to put quotes around it.  PROJECT_NAME specifies the required name of the generated project.  To pass parameters to the generator you can specify multiple PARAMETERs in form \u201cNAME=VALUE\u201d.  Command aliases:   gen  Command options:   -a AV ,  --archive-version=AV  Use archive version AV  -C DIR ,  --change-dir=DIR  Create project in directory DIR, default is \u2018.\u2019  -F ,  --force  Force overwrite if target directory already exists  -I ,  --interactive  Interactive mode for specifying parameter values  -l ,  --local  Use local working directory as archive  -R ,  --repo  Initialize and commit files to a new git repository",
            "title": "generate"
        },
        {
            "location": "/reference/rug-cli/#help",
            "text": "Print usage help  Usage:  $  rug  help   Prints this usage help.  Command aliases:   h ,  ?",
            "title": "help"
        },
        {
            "location": "/reference/rug-cli/#install",
            "text": "Create and install an archive into the local repository  Usage:  $  rug install  [ OPTION ] ...  Create and install an archive from the current project in the local repository.  Command options:   -a AV ,  --archive-version=AV  Override archive version with AV",
            "title": "install"
        },
        {
            "location": "/reference/rug-cli/#list",
            "text": "List locally installed archives  Usage:  $  rug list  [ OPTION ] ...  FILTER could be any of group, artifact or version.  VALUE should be a valid filter expression: for group and artifact ? and * are supported as wildcards;  the version filter can be any valid version or version range.  Command aliases:   ls  Command options:   -f FILTER=VALUE ,  --filter=FILTER=VALUE  Specify filter of type FILTER with VALUE",
            "title": "list"
        },
        {
            "location": "/reference/rug-cli/#login",
            "text": "Login using GitHub authentication  Usage:  $  rug login  [ OPTION ] ...  The Rug CLI uses your GitHub token to verify your membership in GitHub organizations and Slack teams that have the Atomist Bot enrolled.  Those teams have acccess to additional features, eg. team private Rug archives.  Once you used the \u2018login\u2019 command, you can run \u2018configure repositories\u2019 to configure access to your team\u2019s artifact repositories.  Command aliases:   lg  Command options:   --mfa-code=MFA_CODE  GitHub MFA code (only required if MFA is enabled)  --username=USERNAME  GitHub username",
            "title": "login"
        },
        {
            "location": "/reference/rug-cli/#path",
            "text": "Evaluate a path expression against a project  Usage:  $  rug path  [ OPTION ] ...  [ EXPRESSION ]   EXPRESSION can be any valid Rug path expression.  Depending on your expression you might need to put it in quotes.  Use \u2018\u2013values\u2019 to display values of tree nodes; caution as this option might lead to a lot of data being printed.  Command aliases:   tree  Command options:   -C DIR ,  --change-dir=DIR  Evaluate expression against project in directory DIR, default is \u2018.\u2019  -v ,  --values  Displays tree node values",
            "title": "path"
        },
        {
            "location": "/reference/rug-cli/#publish",
            "text": "Create and publish an archive into a remote repository  Usage:  $  rug publish  [ OPTION ] ...  Create a Rug archive from the current repo and publish it into a remote repository.  Use -i to specify what repository configuration should be used to publish.  ID should refer to a repository name in cli.yml  Command options:   --archive-artifact=AA  Override archive artifact with AA  --archive-group=AG  Override archive group with AG  -a AV ,  --archive-version=AV  Override archive version with AV  -F ,  --force  Force publish if working tree isn\u2019t clean  -i ID ,  --id=ID  ID identifying the repository to publish into  -P ,  --publish-all  Publish archive into all repositories it exists",
            "title": "publish"
        },
        {
            "location": "/reference/rug-cli/#search",
            "text": "Search online catalog of available archives  Usage:  $  rug search  [ OPTION ] ...  [ SEARCH ]   SEARCH could be any text used to search the catalog.  TAG can be any valid tag, eg. spring or elm.  TYPE can be either \u2018editor\u2019, \u2018generator\u2019, \u2018command_handler\u2019, \u2018event_handler\u2019 or \u2018response_handler\u2019.  Command options:   -K TYPE ,  --type=TYPE  Specify a TYPE to filter search based on Rug type  -O ,  --operations  List operations  -T TAG ,  --tag=TAG  Specify a TAG to filter search",
            "title": "search"
        },
        {
            "location": "/reference/rug-cli/#shell",
            "text": "Start a shell for a specified Rug archive  Usage:  $  rug shell  [ OPTION ] ... ARCHIVE  ARCHIVE should be a full name of an Rug archive, e.g., \u201catomist:spring-service\u201d.  Command aliases:   repl ,  load  Command options:   -a AV ,  --archive-version=AV  Use archive version AV  -l ,  --local  Use local working directory as archive",
            "title": "shell"
        },
        {
            "location": "/reference/rug-cli/#test",
            "text": "Run test scenarios  Usage:  $  rug  test   [ OPTION ] ...  [ TEST ]   TEST is the name of a test feature or feature file.  If no TEST is specified, all scenarios will run.  Command options:   --disable-console-log  Disable console logging",
            "title": "test"
        },
        {
            "location": "/reference/rug-cli/#to-path",
            "text": "Display path expression to a point in a file within a project  Usage:  $  rug to-path  [ OPTION ] ... PATH  PATH must be a valid path within the project at DIR or \u2018.\u2019.    Command options:   -C DIR ,  --change-dir=DIR  Evaluate expression against project in directory DIR, default is \u2018.\u2019  --column=COLUMN  Column within file at LINE  --kind=KIND  Rug Extension kind, eg. \u2018ScalaFile\u2019 or \u2018Pom\u2019  --line=LINE  Line within the file",
            "title": "to path"
        }
    ]
}